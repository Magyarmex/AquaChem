<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aquarium O‚ÇÇ Demand Planner (DO + oxygenation model)</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop stop-color='%237aa2ff'/%3E%3Cstop offset='1' stop-color='%2363e6be'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='14' fill='%230b1020'/%3E%3Cpath d='M32 10c9.5 0 17.2 7.7 17.2 17.2S41.5 50 32 50 14.8 42.3 14.8 32 22.5 10 32 10Z' fill='url(%23g)' fill-opacity='.35'/%3E%3Cpath d='M32 17c7.2 0 13 5.8 13 13s-5.8 13-13 13-13-5.8-13-13 5.8-13 13-13Z' fill='url(%23g)'/%3E%3Cpath d='M31.7 23.5c2.7 4 5.3 7.2 5.3 10.2 0 3-2.4 5.4-5.3 5.4s-5.3-2.4-5.3-5.4c0-3 2.6-6.2 5.3-10.2Z' fill='%230b1020' fill-opacity='.85'/%3E%3C/svg%3E" />
  <style>
    :root{
      --bg:#0b1020; --panel:#111a33; --panel2:#0f1730; --text:#e7ecff; --muted:#a9b3d6;
      --line:#2a3766; --accent:#7aa2ff; --warn:#ffcf5a; --danger:#ff6b6b; --ok:#63e6be;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 15% -10%, rgba(122,162,255,.18), transparent 60%),
        radial-gradient(900px 400px at 90% 0%, rgba(99,230,190,.12), transparent 55%),
        linear-gradient(180deg,#070a14,#0b1020 25%,#0b1020);
      color:var(--text);
      font-family:var(--sans);
      min-height:100vh;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background-image: linear-gradient(rgba(255,255,255,.04) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,.03) 1px, transparent 1px);
      background-size: 42px 42px, 42px 42px;
      opacity:.25;
      z-index:0;
    }
    header{
      padding:18px 20px 14px;
      border-bottom:1px solid rgba(122,162,255,.18);
      position:sticky;
      top:0;
      background:linear-gradient(180deg, rgba(10,15,30,.98), rgba(10,15,30,.92));
      backdrop-filter: blur(12px);
      z-index:10;
    }
    .app-title{
      display:flex;
      align-items:center;
      gap:12px;
    }
    .app-mark{
      width:44px;
      height:44px;
      border-radius:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      background:linear-gradient(140deg, rgba(122,162,255,.28), rgba(99,230,190,.16));
      border:1px solid rgba(122,162,255,.35);
      box-shadow:0 10px 18px rgba(0,0,0,.3);
      font-size:20px;
    }
    header h1{margin:0;font-size:18px;font-weight:700;letter-spacing:.4px}
    .app-subtitle{
      margin:4px 0 0;
      color:rgba(231,236,255,.78);
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
    }
    header p{margin:10px 0 0;color:var(--muted);font-size:12px;max-width:960px;line-height:1.45}
    .wrap{max-width:1280px;margin:0 auto;padding:20px;display:grid;gap:16px;grid-template-columns: 480px 1fr;position:relative;z-index:1;}
    @media (max-width: 1100px){ .wrap{grid-template-columns:1fr;} header{position:static;} }
    .card{
      background:linear-gradient(180deg,rgba(17,26,51,.98),rgba(13,20,44,.96));
      border:1px solid rgba(122,162,255,.16);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:16px;
      backdrop-filter: blur(6px);
    }
    .card h2{margin:0 0 12px;font-size:14px;color:#dfe6ff;text-transform:uppercase;letter-spacing:.12em}
    .left-panel{
      position:relative;
      background:linear-gradient(180deg,rgba(15,22,44,.98),rgba(12,18,38,.97));
    }
    .panel-section{
      position:relative;
      padding:10px 12px 10px 14px;
      border-radius:16px;
      background:linear-gradient(180deg,rgba(12,19,39,.92),rgba(9,14,30,.92));
      border:1px solid rgba(122,162,255,.14);
      box-shadow:0 12px 24px rgba(0,0,0,.28);
      display:grid;
      gap:8px;
      overflow:hidden;
    }
    .panel-section::before{
      content:"";
      position:absolute;
      left:0;
      top:0;
      bottom:0;
      width:4px;
      background:linear-gradient(180deg, rgba(122,162,255,.75), rgba(99,230,190,.35));
      opacity:.7;
    }
    .panel-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding-left:8px;
    }
    .panel-title{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:#dfe6ff;
      font-weight:700;
    }
    .panel-title .icon{
      width:28px;
      height:28px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius:10px;
      background:rgba(122,162,255,.18);
      border:1px solid rgba(122,162,255,.25);
      font-size:13px;
    }
    .panel-sub{
      color:var(--muted);
      font-size:11px;
      line-height:1.45;
      padding-left:8px;
    }
    .panel-badges{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 8px;
      border-radius:999px;
      font-size:10px;
      text-transform:uppercase;
      letter-spacing:.12em;
      border:1px solid transparent;
      background:rgba(122,162,255,.12);
      color:#dfe6ff;
    }
    .badge.warn{background:rgba(255,207,90,.18); border-color:rgba(255,207,90,.35); color:#fff3d1;}
    .badge.ok{background:rgba(99,230,190,.16); border-color:rgba(99,230,190,.35); color:#d5fff1;}
    .badge.note{background:rgba(122,162,255,.2); border-color:rgba(122,162,255,.35);}
    .badge.alert{background:rgba(255,107,107,.18); border-color:rgba(255,107,107,.35); color:#ffd1d1;}
    .panel-divider{height:1px;background:rgba(255,255,255,.08);margin:4px 0}
    .panel-quick{
      display:grid;
      gap:8px;
      padding:8px 10px;
      border-radius:16px;
      background:linear-gradient(140deg, rgba(122,162,255,.16), rgba(99,230,190,.08));
      border:1px solid rgba(122,162,255,.2);
    }
    .panel-quick .row{margin:0}
    .panel-drawer{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:6px 8px;
      background:rgba(0,0,0,.18);
    }
    .panel-drawer summary{font-size:12px;color:#dfe6ff;font-weight:600}
    .panel-drawer .drawer-text{color:var(--muted);font-size:11px;line-height:1.45;margin-top:6px}
    .left-panel .row label{font-size:11px;letter-spacing:.03em}
    .left-panel input[type="number"],
    .left-panel input[type="text"],
    .left-panel select{padding:8px 10px;font-size:12px;border-radius:10px}
    .control-active{
      box-shadow:0 0 0 3px rgba(122,162,255,.18), 0 0 18px rgba(122,162,255,.22);
      border-color:rgba(122,162,255,.6);
    }
    .left-panel .row input[type="range"]{min-width:180px}
    .left-panel .grid2{gap:6px}
    .left-panel .grid3{gap:6px}
    .left-panel .small{font-size:11px}
    .left-panel .note{font-size:11px}
    .panel-section.compact{
      padding:8px 10px 8px 12px;
      gap:6px;
    }
    .panel-section.compact .panel-title{font-size:11px}
    .panel-section.compact .panel-title .icon{width:24px;height:24px;font-size:12px}
    .panel-section.compact .panel-sub{font-size:10px}
    .grid2{display:grid;gap:10px;grid-template-columns:1fr 1fr;}

    .grid3{display:grid;gap:10px;grid-template-columns:1fr 1fr 1fr;}
    .grid4{display:grid;gap:10px;grid-template-columns:1fr 1fr 1fr 1fr;}
    @media (max-width: 900px){
      .grid3{grid-template-columns:1fr 1fr;}
      .grid4{grid-template-columns:1fr 1fr;}
    }
    @media (max-width: 560px){
      .grid3{grid-template-columns:1fr;}
      .grid4{grid-template-columns:1fr;}
    }
    .row{display:flex;gap:16px;align-items:flex-start;flex-wrap:wrap}
    .row label{flex:1 1 180px;min-width:160px;color:var(--muted);font-size:12px;letter-spacing:.02em}
    .row input[type="range"]{flex:1 1 220px;min-width:220px}
    .row input[type="number"]{flex:0 0 140px}
    .row select{flex:1 1 220px;min-width:220px}
    .card .row + .row{margin-top:12px}
    input[type="range"]{width:100%}
    input[type="number"], input[type="text"], select{
      background:#0a1024;border:1px solid rgba(122,162,255,.26);color:var(--text);
      border-radius:12px;padding:9px 12px;font-size:13px;outline:none;
      transition:border-color .2s ease, box-shadow .2s ease, transform .2s ease;
    }
    input[type="number"]:focus, input[type="text"]:focus, select:focus{
      border-color:rgba(122,162,255,.55);
      box-shadow:0 0 0 3px rgba(122,162,255,.18);
      transform:translateY(-1px);
    }
    input[type="range"]{accent-color:var(--accent)}
    input[type="number"]{width:120px}
    select{width:100%}
    .small{font-size:12px;color:var(--muted);line-height:1.35}
    .mono{font-family:var(--mono)}
    .pill{
      display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.16); background:rgba(255,255,255,.05); font-size:12px;
    }
    .pill.ok{border-color:rgba(99,230,190,.35);} .pill.warn{border-color:rgba(255,207,90,.45);} .pill.danger{border-color:rgba(255,107,107,.45);}
    .flags{display:grid;gap:12px}
    .flag-card{
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04);
      overflow:hidden;
      box-shadow:var(--shadow);
    }
    .flag-tag{
      padding:6px 12px;
      font-weight:700;
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .flag-tag.ok{background:rgba(99,230,190,.18); color:#d5fff1;}
    .flag-tag.warn{background:rgba(255,207,90,.22); color:#fff3d1;}
    .flag-tag.danger{background:rgba(255,107,107,.22); color:#ffd1d1;}
    .flag-tag.note{background:rgba(122,162,255,.18); color:#dfe6ff;}
    .flag-body{padding:10px 12px;color:var(--text)}
    .tag-stack{display:grid;gap:8px}
    .tag-line{
      border:1px solid rgba(255,255,255,.14);
      border-radius:12px;
      padding:8px 12px;
      background:rgba(0,0,0,.18);
    }
    .tag-line summary{
      display:flex;
      align-items:center;
      gap:10px;
      list-style:none;
      cursor:pointer;
      color:#dfe6ff;
      font-weight:600;
      font-size:13px;
    }
    .tag-line summary::-webkit-details-marker{display:none}
    .tag-line .tag-title{flex:1;min-width:0}
    .tag-line .tag-meta{color:var(--muted);font-weight:500;font-size:12px;white-space:nowrap}
    .tag-line .tag-spark{
      width:90px;
      height:26px;
      flex:0 0 auto;
      border-radius:8px;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.12);
    }
    .tag-line .tag-chip{
      padding:2px 8px;
      border-radius:999px;
      font-size:10px;
      letter-spacing:.08em;
      text-transform:uppercase;
      border:1px solid transparent;
    }
    .tag-line.tone-ok{border-color:rgba(99,230,190,.32)}
    .tag-line.tone-warn{border-color:rgba(255,207,90,.32)}
    .tag-line.tone-danger{border-color:rgba(255,107,107,.32)}
    .tag-line .tag-chip.ok{background:rgba(99,230,190,.18); color:#d5fff1; border-color:rgba(99,230,190,.45)}
    .tag-line .tag-chip.warn{background:rgba(255,207,90,.18); color:#fff3d1; border-color:rgba(255,207,90,.45)}
    .tag-line .tag-chip.danger{background:rgba(255,107,107,.18); color:#ffd1d1; border-color:rgba(255,107,107,.45)}
    .tag-details{margin-top:8px;color:var(--muted);font-size:12px;line-height:1.45}
    .calendar{
      display:grid;
      gap:8px;
      margin-top:6px;
    }
    .calendar.tiles{
      grid-template-columns:repeat(2, minmax(0, 1fr));
    }
    @media (max-width: 900px){
      .calendar.tiles{grid-template-columns:1fr;}
    }
    @media (max-width: 560px){
      .calendar.tiles{grid-template-columns:1fr;}
    }
    .calendar-month{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:8px 7px;
      background:rgba(0,0,0,.18);
      display:grid;
      gap:4px;
      position:relative;
      min-width:0;
    }
    .calendar-month.expanded{
      grid-column:1 / -1;
      padding:12px;
      background:linear-gradient(180deg, rgba(17,26,51,.96), rgba(10,16,34,.94));
      border-color:rgba(122,162,255,.3);
      box-shadow:0 18px 30px rgba(0,0,0,.35);
    }
    .calendar-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      font-size:11px;
      color:#dfe6ff;
      letter-spacing:.08em;
      text-transform:uppercase;
      gap:6px;
      flex-wrap:wrap;
    }
    .calendar-header .summary{
      color:var(--muted);
      font-size:9px;
      letter-spacing:.04em;
    }
    .calendar-header .month-actions{
      display:flex;
      gap:4px;
      align-items:center;
    }
    .calendar-header .month-toggle{
      border:1px solid rgba(122,162,255,.35);
      background:rgba(122,162,255,.16);
      color:#dfe6ff;
      border-radius:999px;
      padding:2px 6px;
      font-size:10px;
      letter-spacing:.08em;
      text-transform:uppercase;
      cursor:pointer;
    }
    .calendar-grid{
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      gap:3px;
      margin-top:2px;
    }
    .cal-cell{
      border:1px solid rgba(255,255,255,.12);
      border-radius:8px;
      padding:3px 3px;
      background:rgba(0,0,0,.18);
      min-height:30px;
      position:relative;
      font-size:9.5px;
      line-height:1.2;
      overflow:hidden;
    }
    .cal-cell.empty{
      background:transparent;
      border-color:transparent;
      box-shadow:none;
    }
    .cal-cell .day-num{font-weight:600;color:#dfe6ff;font-size:10px}
    .cal-cell .day-meta{display:none}
    .cal-cell.feed{background:rgba(99,230,190,.12); border-color:rgba(99,230,190,.4)}
    .cal-cell.pop{background:rgba(255,207,90,.14); border-color:rgba(255,207,90,.4)}
    .cal-cell.feed.pop{
      background:linear-gradient(135deg, rgba(99,230,190,.18) 0%, rgba(99,230,190,.18) 45%, rgba(255,207,90,.18) 55%, rgba(255,207,90,.18) 100%);
    }
    .cal-label{
      text-transform:uppercase;
      letter-spacing:.08em;
      font-size:10px;
      color:rgba(231,236,255,.65);
      text-align:center;
    }
    .btn{
      background:rgba(122,162,255,.18);
      border:1px solid rgba(122,162,255,.35);
      color:var(--text);
      border-radius:12px;
      padding:9px 12px;
      font-size:13px;
      cursor:pointer;
      user-select:none;
      transition:transform .2s ease, box-shadow .2s ease, background .2s ease;
    }
    .btn:hover{background:rgba(122,162,255,.26);transform:translateY(-1px);box-shadow:0 8px 18px rgba(0,0,0,.25)}
    .btn.danger{border-color:rgba(255,107,107,.55); background:rgba(255,107,107,.12)}
    .btn.danger:hover{background:rgba(255,107,107,.18)}
    .btn.ghost{background:transparent;border-color:rgba(255,255,255,.18)}
    .btn.ghost:hover{background:rgba(255,255,255,.06)}
    details{border:1px solid rgba(255,255,255,.14);border-radius:12px;padding:12px;background:rgba(0,0,0,.16)}
    details summary{cursor:pointer;color:#dfe6ff;font-weight:600;font-size:13px}
    details.panel-drawer{border:1px solid rgba(255,255,255,.12);padding:8px 10px;background:rgba(0,0,0,.18)}
    details.panel-drawer summary{font-size:12px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px 6px;border-bottom:1px solid rgba(255,255,255,.08);font-size:12px;color:var(--muted)}
    tr:nth-child(even) td{background:rgba(255,255,255,.02)}
    th{color:#dfe6ff;text-align:left;font-weight:600}
    td input[type="number"]{width:90px}
    canvas{width:100%;height:300px;border-radius:14px;background:linear-gradient(180deg,#070b18,#070f1d);border:1px solid rgba(255,255,255,.08)}
    .charts{display:grid;gap:12px;grid-template-columns:1fr}
    .legend{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
    .leg{
      display:flex;gap:8px;align-items:center;font-size:12px;color:var(--muted);
      padding:6px 10px;border:1px solid rgba(255,255,255,.12);border-radius:12px;background:rgba(255,255,255,.05);
      cursor:pointer; user-select:none;
    }
    .dot{width:10px;height:10px;border-radius:50%}
    .leg.off{opacity:.35}
    .tooltip{
      position:fixed; pointer-events:none; z-index:99;
      background:rgba(17,26,51,.95); border:1px solid rgba(255,255,255,.14);
      border-radius:12px; padding:10px 12px; box-shadow:var(--shadow);
      font-size:12px; color:var(--text); max-width:360px; display:none;
    }
    .kbd{font-family:var(--mono);font-size:11px;padding:2px 6px;border:1px solid rgba(255,255,255,.16);border-radius:8px;background:rgba(255,255,255,.06);color:#dfe6ff}
    .note{color:var(--muted);font-size:12px;line-height:1.45}
    .footer{margin-top:8px;color:var(--muted);font-size:11px}
    .hr{height:1px;background:rgba(255,255,255,.10);margin:10px 0}
    .errbox{border:1px solid rgba(255,107,107,.35);background:rgba(255,107,107,.08);padding:10px;border-radius:12px;color:#ffd1d1;font-size:12px;display:none}
    .errbox pre{margin:8px 0 0;white-space:pre-wrap;word-break:break-word;color:#ffd1d1}
    .copy-toast{
      font-size:11px;
      color:var(--ok);
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(99,230,190,.35);
      background:rgba(99,230,190,.12);
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .copy-toast.warn{
      color:#fff3d1;
      border-color:rgba(255,207,90,.45);
      background:rgba(255,207,90,.16);
    }
    .calendar-month.expanded .cal-cell{
      min-height:52px;
      font-size:11px;
      padding:6px;
    }
  </style>
</head>
<body>
<header class="app-header">
  <div class="app-title">
    <div class="app-mark">ü´ß</div>
    <div>
      <h1>Aquarium Oxygen Planner</h1>
      <div class="app-subtitle">Demand modeling ¬∑ Oxygenation inference ¬∑ Feeding cadence</div>
    </div>
  </div>
  <p>
    Estimate oxygen demand from feed decomposition and nitrification, then simulate dissolved oxygen with bubble + surface transfer.
    Calibrate with real-world measurements to tighten uncertainty bands over time.
  </p>
</header>

<div class="wrap">
  <div class="card left-panel">
    <div class="panel-quick">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">‚ö°</span>Quick Controls</div>
        <div class="panel-badges">
          <span class="badge note">Most adjusted</span>
        </div>
      </div>

      <div class="row">
        <label>Pellets per feeding (count)</label>
        <input id="pelMass" type="range" min="0" max="200" step="1" value="20"/>
        <input id="pelMassN" type="number" min="0" max="500" step="1" value="20"/>
      </div>
      <div class="small" style="margin-top:-6px">
        This rate ‚âà <b id="pelCount">‚Äî</b> (<span id="pelEach">‚Äî</span> each).
      </div>

      <div class="row">
        <label>Powder mass per feeding (as-fed, g)</label>
        <input id="powMass" type="range" min="0" max="5" step="0.01" value="0.00"/>
        <input id="powMassN" type="number" min="0" max="50" step="0.01" value="0.00"/>
      </div>

      <div class="row">
        <label>Feeding interval (days)</label>
        <input id="feedInterval" type="number" min="0.25" step="0.25" value="1"/>
      </div>

      <div class="row">
        <label>Blanket cover (%) ‚Äî uncovered = chimney</label>
        <input id="blanket" type="range" min="0" max="100" step="1" value="80"/>
        <input id="blanketN" type="number" min="0" max="100" step="1" value="80"/>
      </div>

      <div class="row">
        <label>Simulation time (days)</label>
        <input id="days" type="range" min="7" max="180" step="1" value="30"/>
        <input id="daysN" type="number" min="1" max="365" step="1" value="30"/>
      </div>
    </div>

    <div class="panel-section" id="uncModeDetails" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üß≠</span>Uncertainty Mode</div>
        <div class="panel-badges">
          <span class="badge warn">Uncertainty Mode</span>
        </div>
      </div>
      <div class="panel-sub">
        Runs multiple plausible realities and shows a confidence band instead of a single line.
      </div>
      <details class="panel-drawer">
        <summary>What this means</summary>
        <div class="drawer-text">
          Default mode: the sim runs many plausible ‚Äúnearby realities‚Äù and shows a band (not a single pretend-precise line).
          Without a real DO measurement, this is the honest way to use the model.
        </div>
      </details>

      <div class="grid2">
        <div class="row">
          <label>Run mode</label>
          <select id="runMode">
            <option value="uncertainty" selected>Uncertainty (recommended)</option>
            <option value="single">Single run (deterministic)</option>
          </select>
        </div>
        <div class="row">
          <label>Uncertainty level</label>
          <select id="uncLevel">
            <option value="tight">Tight (you measured most things)</option>
            <option value="typical" selected>Typical (some guesses)</option>
            <option value="wide">Wide (many guesses)</option>
          </select>
        </div>

        <div class="row">
          <label>Monte Carlo runs</label>
          <input id="mcRunsRange" type="range" min="50" max="800" step="10" value="200"/>
          <input id="mcRuns" type="number" min="10" max="2000" step="10" value="200"/>
        </div>

        <div class="row">
          <label>Band shown</label>
          <select id="bandPreset">
            <option value="10-90" selected>10‚Äì90% (wide)</option>
            <option value="25-75">25‚Äì75% (mid)</option>
            <option value="5-95">5‚Äì95% (very wide)</option>
          </select>
        </div>

        <div class="row">
          <label>Random seed</label>
          <input id="seed" type="number" step="1" value="12345"/>
        </div>
        <div class="row">
          <label>Live recompute</label>
          <select id="liveRecompute">
            <option value="on" selected>On (debounced)</option>
            <option value="off">Off (click Recompute)</option>
          </select>
        </div>
      </div>

      <div>
        <button class="btn" id="recomputeBtn" style="display:none">Recompute</button>
      </div>

      <div class="panel-divider"></div>

      <div class="small"><b>What varies across runs:</b></div>
      <div class="grid2">
        <div class="row"><label><input id="uAir" type="checkbox" checked> Pump delivered airflow</label></div>
        <div class="row"><label><input id="uDiff" type="checkbox" checked> Bubble transfer efficiency</label></div>
        <div class="row"><label><input id="uSurf" type="checkbox" checked> Surface exchange (k values)</label></div>
        <div class="row"><label><input id="uTight" type="checkbox" checked> Blanket ‚Äútightness‚Äù / leakiness</label></div>
        <div class="row"><label><input id="uBio" type="checkbox" checked> Biology speed (microbes, kinetics)</label></div>
        <div class="row"><label><input id="uTemp" type="checkbox" checked> Water temperature</label></div>
        <div class="row"><label><input id="uInitDO" type="checkbox" checked> Initial DO</label></div>
      </div>

      <details class="panel-drawer">
        <summary>What this means</summary>
        <div class="drawer-text">
          The band is a <b>distribution</b>, not a promise. If you calibrate with real DO data later, the band shrinks and gets less ‚Äúvibes, more physics‚Äù.
        </div>
      </details>
    </div>

    <div class="panel-section" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üìÖ</span>Feeding Calendar</div>
        <div class="panel-badges">
          <span class="badge ok">Feeding Calendar</span>
        </div>
      </div>
      <details class="panel-drawer">
        <summary>What this means</summary>
        <div class="drawer-text">
          Feeding events add pellets + powder at your chosen interval. Green = feed day, yellow = pellet pop day.
        </div>
      </details>
      <div class="calendar tiles" id="feedCalendar"></div>
    </div>

    <div class="panel-section compact" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üí•</span>Pop Events</div>
        <div class="panel-badges">
          <span class="badge warn">Pop Events</span>
        </div>
      </div>
      <details class="panel-drawer">
        <summary>What this means</summary>
        <div class="drawer-text">
          Click the <span class="kbd">RATE</span> graph to add an event at that day, or use the table below.
          Each event converts whole pellets into powder at that moment (mass is conserved).
        </div>
      </details>
      <div class="grid3">
        <div class="row">
          <label>Event day</label>
          <input id="evDay" type="number" min="0" step="0.1" value="3.0"/>
        </div>
        <div class="row">
          <label>Pellets to pop</label>
          <input id="evPellets" type="number" min="0" step="1" value="10"/>
        </div>
        <div class="row" style="justify-content:flex-end">
          <button class="btn" id="addEventBtn">Add event</button>
        </div>
      </div>
      <div>
        <button class="btn ghost" id="clearEventsBtn">Clear events</button>
      </div>

      <div style="max-height:220px; overflow:auto;">
        <table id="eventsTable">
          <thead>
            <tr><th>Day</th><th>Pellets to pop</th><th></th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="panel-section compact" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üßØ</span>Model Status</div>
        <div class="panel-badges">
          <span class="badge alert">Alerts</span>
        </div>
      </div>
      <div class="small" id="modelStatusNote">No errors reported yet.</div>
      <div class="errbox" id="errBox">
        <b>Model error</b>
        <div class="small" style="margin-top:6px">
          If this repeats, open Dev / debug and copy the stack trace.
        </div>
        <pre id="errText"></pre>
      </div>
    </div>

    <div class="panel-section" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üß™</span>Environment & Tank</div>
        <div class="panel-badges">
          <span class="badge note">Advanced</span>
        </div>
      </div>
      <details class="panel-drawer" open>
        <summary>Controls</summary>
        <div class="grid2" style="margin-top:10px">
          <div class="row">
            <label>Tank water volume (L)</label>
            <input id="volL" type="number" step="0.1" value="65.0"/>
          </div>
          <div class="row">
            <label>Water temp (¬∞C) at current blanket setting</label>
            <input id="Tnow" type="number" step="0.1" value="22.0"/>
          </div>

          <div class="row">
            <label>Water pH (for NH‚ÇÉ fraction)</label>
            <input id="pH" type="number" step="0.05" value="7.4"/>
          </div>
          <div class="row">
            <label>Altitude (m)</label>
            <input id="altM" type="number" step="10" value="2300"/>
          </div>
          <div class="row">
            <label>TDS (mg/L)</label>
            <input id="tds" type="number" step="10" value="660"/>
          </div>

          <div class="row">
            <label>Tank length (cm)</label>
            <input id="lenCm" type="number" step="0.1" value="78.0"/>
          </div>
          <div class="row">
            <label>Tank width (cm)</label>
            <input id="widCm" type="number" step="0.1" value="31.0"/>
          </div>
          <div class="row">
            <label>Tank height (cm)</label>
            <input id="tankHCm" type="number" step="0.1" value="48.0"/>
          </div>
          <div class="row">
            <label>Water surface from bottom (cm)</label>
            <input id="waterSurfCm" type="number" step="0.1" value="22.0"/>
          </div>
          <div class="row">
            <label>Blanket gap above rim (cm)</label>
            <input id="blanketGapCm" type="number" step="0.1" value="0.0"/>
          </div>
          <div class="row">
            <label>Diffuser depth below surface (cm)</label>
            <input id="diffDepthCm" type="number" step="0.1" value="17.0"/>
          </div>
          <div class="row">
            <label>Water column heaters (0‚Äì2)</label>
            <input id="heaters" type="number" step="1" min="0" max="2" value="0"/>
          </div>
        </div>
      </details>
    </div>

    <div class="panel-section" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üå¨Ô∏è</span>Aeration & Surface Exchange</div>
        <div class="panel-badges">
          <span class="badge note">Advanced</span>
        </div>
      </div>
      <details class="panel-drawer" open>
        <summary>Controls</summary>
        <div class="grid2" style="margin-top:10px">
          <div class="row">
            <label>Air pump delivered flow (L/min)</label>
            <input id="airFlow" type="number" step="0.1" value="4.0"/>
          </div>
          <div class="row">
            <label>Surface ripples (% of surface)</label>
            <input id="ripplePct" type="number" step="1" value="50"/>
          </div>

          <div class="row">
            <label>Bubble transfer preset</label>
            <select id="diffType">
              <option value="airstone_med" selected>Typical airstones (medium bubbles)</option>
              <option value="airstone_fine">Fine airstone (smaller bubbles)</option>
              <option value="microbubble">Microbubble diffuser (very fine)</option>
              <option value="wood">Wooden airstone (very fine, higher backpressure)</option>
              <option value="custom">Custom</option>
            </select>
          </div>

          <div class="row">
            <label>Custom bubble efficiency: SOTE per meter (%)</label>
            <input id="sotePerM" type="number" step="0.1" value="2.5"/>
          </div>
          <div class="small" style="margin-top:-6px; opacity:.85">
            SOTE per meter is a <b>rough transfer efficiency</b> (how much O‚ÇÇ in the air actually dissolves per meter of bubble travel).
            If you‚Äôre unsure, use the preset ‚Äî the uncertainty mode already widens results around it.
          </div>

          <div class="row" style="margin-top:10px">
            <label>Surface exchange preset</label>
            <select id="surfacePreset">
              <option value="still">Still water (low exchange)</option>
              <option value="typical" selected>Typical aquarium (some ripples)</option>
              <option value="rippling">Strong ripples (good exchange)</option>
              <option value="splashy">Splashy / fan / very agitated (very high)</option>
              <option value="custom">Custom</option>
            </select>
          </div>

          <div class="row">
            <label>Surface k (calm) (m/day)</label>
            <input id="kCalm" type="number" step="0.05" value="0.30"/>
          </div>
          <div class="row">
            <label>Surface k (rippling) (m/day)</label>
            <input id="kRipple" type="number" step="0.05" value="1.00"/>
          </div>

          <div class="row" style="margin-top:10px">
            <label>Cover leakiness preset</label>
            <select id="tightPreset">
              <option value="open">No cover (open tank)</option>
              <option value="loose_high" selected>Loose blanket (high above water)</option>
              <option value="typical">Typical blanket (some restriction)</option>
              <option value="near_sealed">Near-sealed lid (strong restriction)</option>
              <option value="custom">Custom</option>
            </select>
          </div>
          <div class="row">
            <label>Leakiness number (0 drafty ‚Üí 1 sealed)</label>
            <input id="tight" type="number" step="0.05" min="0" max="1" value="0.25"/>
          </div>

          <div class="row" style="margin-top:10px">
            <label>Aeration performance preset</label>
            <select id="otrPreset">
              <option value="typical" selected>Typical (as expected)</option>
              <option value="under">Underperforming (backpressure / leaks)</option>
              <option value="over">Overperforming (very efficient)</option>
              <option value="custom">Custom</option>
            </select>
          </div>
          <div class="row">
            <label>Aeration performance factor</label>
            <input id="otrCal" type="number" step="0.05" value="1.00"/>
          </div>
        </div>
      </details>
      <details class="panel-drawer">
        <summary>What this means</summary>
        <div class="drawer-text">
          <b>Bubble side</b>: compute O‚ÇÇ mass entering per day from the airflow (altitude affects pressure), then multiply by an efficiency fraction that scales with depth and diffuser type.
          <br/><b>Surface side</b>: use a gas-film ‚Äúspeed‚Äù k (m/day) times surface area. Ripples get a higher k. Covered area gets k multiplied by a leak factor based on tightness + headspace ventilation.
          <br/><b>OTRmax</b> combines both sides (g/day at DO‚âà0) and becomes an inferred <b>kLa</b> so supply increases as DO drops: supply = kLa¬∑(C*‚àíDO)¬∑V.
        </div>
      </details>
    </div>

    <div class="panel-section" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üß¨</span>Biology & Chemistry</div>
        <div class="panel-badges">
          <span class="badge note">Advanced</span>
        </div>
      </div>
      <details class="panel-drawer" open>
        <summary>Controls</summary>
        <div class="grid2" style="margin-top:10px">
          <div class="row">
            <label>Initial DO assumption</label>
            <select id="initDOPreset">
              <option value="100">Near saturation (100%)</option>
              <option value="95" selected>High (95%)</option>
              <option value="85">Moderate (85%)</option>
              <option value="70">Low (70%)</option>
              <option value="custom">Custom</option>
            </select>
          </div>
          <div class="row">
            <label>Initial DO (% of local saturation)</label>
            <input id="doInitPct" type="number" step="1" min="0" max="150" value="95"/>
          </div>

          <div class="row">
            <label>Heterotroph biomass (g) ‚Äî respiration inferred</label>
            <input id="heteroMass" type="number" step="1" min="0" value="0"/>
          </div>
          <div class="row">
            <label>Photosynthetic mass (g wet biomass)</label>
            <input id="photoMass" type="number" step="1" min="0" value="0"/>
          </div>
          <div class="small" style="margin-top:-6px; opacity:.85">
            Photosynthetic mass combines plants, algae, and phytoplankton. Oxygen production + nutrient uptake are inferred from this.
          </div>

          <div class="row">
            <label>Diurnal temp amplitude (¬∞C)</label>
            <input id="tempAmp" type="number" step="0.1" min="0" value="0.6"/>
          </div>
          <div class="row">
            <label>Lights on (hour 0‚Äì23)</label>
            <input id="lightHour" type="number" step="1" min="0" max="23" value="9"/>
          </div>

          <div class="row">
            <label>Enable oxygen limitation for nitrification</label>
            <select id="o2Limit">
              <option value="off">Off (demand not reduced when DO is low)</option>
              <option value="on">On (nitrification slows as DO drops)</option>
            </select>
          </div>
          <div class="row">
            <label>Nitrifier DO half-saturation K (mg/L)</label>
            <input id="kDoNit" type="number" step="0.05" value="0.50"/>
          </div>
          <div class="row">
            <label>NH‚ÇÑ half-saturation K (mg/L as N)</label>
            <input id="kNH4Nit" type="number" step="0.05" value="0.40"/>
          </div>
          <div class="row">
            <label>NO‚ÇÇ half-saturation K (mg/L as N)</label>
            <input id="kNO2Nit" type="number" step="0.05" value="0.25"/>
          </div>
          <div class="row">
            <label>Nitrifier capacity (0‚Äì1)</label>
            <input id="nitCap" type="number" step="0.05" min="0" max="1" value="0.80"/>
          </div>
          <div class="row">
            <label>Nitrifier Q10 (temperature response)</label>
            <input id="nitQ10" type="number" step="0.05" value="2.0"/>
          </div>
          <div class="row">
            <label>Heterotroph DO half-saturation K (mg/L)</label>
            <input id="kDoHet" type="number" step="0.05" value="0.80"/>
          </div>
          <div class="row">
            <label>Refractory fraction (slow COD)</label>
            <input id="slowFrac" type="number" step="0.05" min="0" max="0.9" value="0.25"/>
          </div>
          <div class="row">
            <label>Biofilm thickness proxy (mm)</label>
            <input id="biofilmMm" type="number" step="0.1" min="0" value="0.6"/>
          </div>
          <div class="row">
            <label>Denitrification rate (1/day)</label>
            <input id="kDenit" type="number" step="0.05" value="0.15"/>
          </div>
          <div class="row">
            <label>Denitrifier capacity (0‚Äì1)</label>
            <input id="denitCap" type="number" step="0.05" min="0" max="1" value="0.60"/>
          </div>

          <div class="row">
            <label>Nitrogen display units</label>
            <select id="nUnits">
              <option value="asN" selected>as N (mg/L)</option>
              <option value="asIon">as ion (mg/L)</option>
            </select>
          </div>
          <div class="row">
            <label>Chemistry audit (nerd mode)</label>
            <input id="chemNerd" type="checkbox"/>
          </div>
        </div>
      </details>
    </div>

    <div class="panel-section" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üî¨</span>Pellet Geometry</div>
        <div class="panel-badges">
          <span class="badge note">Advanced</span>
        </div>
      </div>
      <details class="panel-drawer" open>
        <summary>Controls</summary>
        <div class="grid2" style="margin-top:10px">
          <div class="row">
            <label>Pellet length (cm)</label>
            <input id="pelLen" type="number" step="0.01" value="1.00" disabled title="Hardcoded: 1.00 cm"/>
          </div>
          <div class="row">
            <label>Pellet diameter (cm)</label>
            <input id="pelDia" type="number" step="0.01" value="0.20" disabled title="Hardcoded: 0.20 cm"/>
          </div>
          <div class="row">
            <label>Pellet density (g/cm¬≥)</label>
            <input id="pelRho" type="number" step="0.01" value="0.55"/>
          </div>
        </div>
      </details>
    </div>

  </div>

  <div class="card">
    <h2>Charts</h2>
    <div class="charts">
      <div>
        <canvas id="rateCanvas" width="1200" height="360"></canvas>
        <div class="small" style="margin-top:6px">Rate chart (g O‚ÇÇ/day). Click to add a ‚Äúpop‚Äù event at that day.</div>
      </div>
      <div>
        <canvas id="doCanvas" width="1200" height="360"></canvas>
        <div class="small" style="margin-top:6px">Dissolved oxygen (mg/L). Dashed line is local saturation C*.</div>
      </div>
      <div>
        <canvas id="chemCanvas" width="1200" height="360"></canvas>
        <div class="small" style="margin-top:6px">Chemistry / compounds (mg/L). Choose net concentrations, production-only, or cumulative production; toggle NH‚ÇÑ/NO‚ÇÇ/NO‚ÇÉ units in Advanced.</div>
        <div class="row" style="margin-top:8px">
          <label>Chemistry display mode</label>
          <select id="chemDisplay">
            <option value="bio" selected>Net concentrations (after consumption)</option>
            <option value="prod">Production only (no consumption)</option>
            <option value="cum">Cumulative production</option>
          </select>
        </div>
      </div>
      <div>
        <canvas id="bioCanvas" width="1200" height="320"></canvas>
        <div class="small" style="margin-top:6px">Expected biomass fluctuations (heterotroph + phyto). Right axis shows % change from initial mass.</div>
      </div>
    </div>

    <div class="small" style="margin-top:8px">Rate chart series</div>
    <div class="legend" id="legendRate"></div>
    <div class="small" style="margin-top:12px">Chemistry chart series</div>
    <div class="legend" id="legendChem"></div>
    <div class="small" style="margin-top:12px">Biomass chart series</div>
    <div class="legend" id="legendBio"></div>

    <div class="hr"></div>

    <h2>Chemistry overview</h2>
    <div class="small">Tag lines summarize modeled peaks/mins (including NO‚ÇÇ, NO‚ÇÉ, and copper proxy). Tap a line to expand details and see safe vs caution vs dangerous reference bands.</div>
    <div class="tag-stack" id="chemTags" style="margin-top:10px"></div>

    <details id="chemAuditDetails" style="margin-top:10px; display:none;">
      <summary>Chemistry audit (nerd mode)</summary>
      <div class="small" style="margin-top:8px">Audit trails for nitrogen + CO‚ÇÇ + nutrients.</div>
      <pre id="chemAudit" class="mono" style="white-space:pre-wrap; word-break:break-word; color:rgba(231,236,255,.82)"></pre>
    </details>

    <div class="hr"></div>

    <div class="note">
      <b>Interpretation tip:</b> When DO is high, supply is smaller because (C*‚àíDO) is smaller. As DO falls, the same aeration becomes more ‚Äúhungry‚Äù and transfers more O‚ÇÇ.
      If the DO curve still crashes, the model is saying ‚Äúeven when the water is starving for O‚ÇÇ, your demand beats your supply.‚Äù
    </div>


<details id="dbgDetails" style="margin-top:14px">
  <summary>Dev / debug</summary>
  <div class="small" style="margin-top:10px">
    Errors and warnings also show in the browser console.
  </div>
  <div class="hr"></div>
  <div class="small"><b>Last recompute diagnostics</b></div>
  <div class="row" style="margin-top:8px; align-items:center;">
    <button class="btn ghost" id="copyDebugBtn">Copy Debug Log</button>
    <span class="copy-toast" id="copyDebugStatus" style="display:none"></span>
  </div>
  <pre id="dbg" class="mono" style="white-space:pre-wrap; word-break:break-word; color:rgba(231,236,255,.82)"></pre>
</details>


  </div>
</div>

<div class="tooltip" id="tip"></div>

<script>

/* =========================================================
   Series registry (rate + chemistry charts)
========================================================= */
const RATE_SERIES = [
  {key:"carb",  name:"Carbs ‚Üí CO‚ÇÇ (direct)", color:"#54a0ff"},
  {key:"prot",  name:"Protein ‚Üí CO‚ÇÇ + NH‚ÇÑ (direct)", color:"#ff9f43"},
  {key:"fat",   name:"Fat ‚Üí CO‚ÇÇ (direct)", color:"#2ecc71"},
  {key:"endog", name:"Endogenous respiration", color:"#ff6b6b"},
  {key:"nh4",   name:"NH‚ÇÑ ‚Üí NO‚ÇÇ (nitrification)", color:"#a29bfe"},
  {key:"no2",   name:"NO‚ÇÇ ‚Üí NO‚ÇÉ (nitrification)", color:"#c8d6e5"},
  {key:"hetero",  name:"Heterotroph respiration", color:"#ff9ff3"},
  {key:"plant", name:"Phyto O‚ÇÇ production", color:"#1dd1a1"},
  {key:"total", name:"TOTAL demand", color:"#ff5fd2", bold:true},
  {key:"supply",name:"O‚ÇÇ transfer into water (dynamic)", color:"#63e6be", dash:true},
];

const CHEM_SERIES = [
  {key:"nh4", name:"NH‚ÇÑ (total ammonia)", color:"#ffd166"},
  {key:"nh3", name:"NH‚ÇÉ (unionized)", color:"#ff8fab"},
  {key:"no2", name:"NO‚ÇÇ", color:"#a29bfe"},
  {key:"no3", name:"NO‚ÇÉ", color:"#63e6be"},
  {key:"co2", name:"CO‚ÇÇ free", color:"#54a0ff"},
  {key:"dic", name:"DIC (buffered)", color:"#48dbfb"},
  {key:"store", name:"Nutrient stores", color:"#feca57"},
  {key:"micro", name:"Micros (proxy)", color:"#b8c0ff"},
];

const BIOMASS_SERIES = [
  {key:"hetero_g", name:"Heterotroph mass (g)", color:"#ff9f43", bold:true},
  {key:"phyto_g", name:"Phyto mass (g)", color:"#1dd1a1", bold:true},
  {key:"hetero_pct", name:"Heterotroph Œî% (right axis)", color:"#ffd166", dash:true},
  {key:"phyto_pct", name:"Phyto Œî% (right axis)", color:"#a8e6cf", dash:true}
];

let visibleRate = Object.fromEntries(RATE_SERIES.map(s=>[s.key, true]));
let visibleChem = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, true]));
let calendarExpandedKey = null;

function updateChemSeriesLabels(nUnits){
  if(nUnits === 'asIon'){
    CHEM_SERIES.find(s=>s.key==='nh4').name = 'NH‚ÇÑ‚Å∫ (ion)';
    CHEM_SERIES.find(s=>s.key==='no2').name = 'NO‚ÇÇ‚Åª (ion)';
    CHEM_SERIES.find(s=>s.key==='no3').name = 'NO‚ÇÉ‚Åª (ion)';
  }else{
    CHEM_SERIES.find(s=>s.key==='nh4').name = 'NH‚ÇÑ-N';
    CHEM_SERIES.find(s=>s.key==='no2').name = 'NO‚ÇÇ-N';
    CHEM_SERIES.find(s=>s.key==='no3').name = 'NO‚ÇÉ-N';
  }
}

function buildCumulativeSeries(seriesDict, dt){
  const series = {};
  const totals = {};
  let invalidCount = 0;
  for(const [key, arr] of Object.entries(seriesDict || {})){
    const cum = new Array(arr.length);
    let sum = 0;
    let bad = 0;
    for(let i=0;i<arr.length;i++){
      const v = arr[i];
      const safe = Number.isFinite(v) ? v : 0;
      if(!Number.isFinite(v)) bad++;
      sum += safe * dt;
      cum[i] = sum;
    }
    series[key] = cum;
    totals[key] = sum;
    invalidCount += bad;
  }
  return {series, info:{invalidCount, totals, dt}};
}

function sanitizeBand(band, fallback, label){
  if(!band || !band.lo || !band.hi) return {band, invalid:0, inverted:0};
  const n = band.lo.length;
  const out = {
    lo: new Float32Array(n),
    mid: new Float32Array(n),
    hi: new Float32Array(n)
  };
  let invalid = 0;
  let inverted = 0;
  for(let i=0;i<n;i++){
    const fallbackValue = Array.isArray(fallback) || fallback instanceof Float32Array ? fallback[i] : 0;
    let lo = Number.isFinite(band.lo[i]) ? band.lo[i] : fallbackValue;
    let hi = Number.isFinite(band.hi[i]) ? band.hi[i] : fallbackValue;
    let mid = Number.isFinite(band.mid?.[i]) ? band.mid[i] : (Number.isFinite(fallbackValue) ? fallbackValue : (lo + hi) / 2);
    if(!Number.isFinite(lo) || !Number.isFinite(hi) || !Number.isFinite(mid)){
      invalid++;
      lo = Number.isFinite(lo) ? lo : 0;
      hi = Number.isFinite(hi) ? hi : lo;
      mid = Number.isFinite(mid) ? mid : lo;
    }
    if(lo > hi){
      const tmp = lo; lo = hi; hi = tmp;
      inverted++;
    }
    out.lo[i] = lo;
    out.mid[i] = mid;
    out.hi[i] = hi;
  }
  if((invalid || inverted) && label){
    addWarning(`Uncertainty band sanitized for ${label}: ${invalid} non-finite, ${inverted} inverted samples.`);
  }
  return {band: out, invalid, inverted};
}

function buildFeedSchedule(params, pelletEach_g){
  const interval = Number(params.feedIntervalDays ?? 0);
  const pelletsPerFeed = Math.max(0, Math.round(Number(params.feedPellets ?? 0)));
  const powderPerFeed_g = Math.max(0, Number(params.feedPowder_g ?? 0));
  if(!Number.isFinite(interval) || interval <= 0) return [];
  if(pelletsPerFeed <= 0 && powderPerFeed_g <= 0) return [];
  const totalDays = Math.max(0, Number(params.days ?? 0));
  const schedule = [];
  let day = 0;
  while(day <= totalDays + 1e-9){
    schedule.push({
      day,
      pellets: pelletsPerFeed,
      powder_g: powderPerFeed_g,
      mass_g: pelletsPerFeed * pelletEach_g + powderPerFeed_g
    });
    day += interval;
  }
  return schedule;
}

function buildFeedPulse(feedPlan, dt, days, windowDays){
  const n = Math.floor(days/dt) + 1;
  const pellets = new Float32Array(n);
  const powder = new Float32Array(n);
  const windowSteps = Math.max(1, Math.round(windowDays / dt));
  let totalPellets = 0;
  let totalPowder = 0;
  for(const feed of feedPlan){
    if(!Number.isFinite(feed.day)) continue;
    const startIdx = clamp(Math.floor(feed.day / dt), 0, n - 1);
    const p = Number(feed.pellets || 0);
    const w = Number(feed.powder_g || 0);
    const perStepPellets = p / windowSteps;
    const perStepPowder = w / windowSteps;
    for(let s=0;s<windowSteps;s++){
      const idx = startIdx + s;
      if(idx >= n) break;
      pellets[idx] += perStepPellets;
      powder[idx] += perStepPowder;
    }
    totalPellets += p;
    totalPowder += w;
  }
  return {pellets, powder, windowSteps, windowDays, totalPellets, totalPowder};
}

function setCalendarTileFocus(targetKey){
  const nextKey = calendarExpandedKey === targetKey ? null : targetKey;
  calendarExpandedKey = nextKey;
  DEBUG_STATE.lastCalendarExpandedKey = calendarExpandedKey;
  document.querySelectorAll('.calendar-month').forEach((month)=>{
    const key = month.dataset.monthKey;
    month.classList.toggle('expanded', Boolean(calendarExpandedKey && key === calendarExpandedKey));
  });
  syncCalendarToggleState();
}

function syncCalendarToggleState(){
  const btns = document.querySelectorAll('[data-month-toggle]');
  btns.forEach((btn)=>{
    const key = btn.getAttribute('data-month-toggle');
    const expanded = Boolean(calendarExpandedKey && key === calendarExpandedKey);
    btn.textContent = expanded ? '‚§¢' : '‚§°';
    btn.setAttribute('title', expanded ? 'Collapse month' : 'Expand month');
    btn.setAttribute('aria-pressed', expanded ? 'true' : 'false');
  });
}

function renderFeedingCalendar(params, feedPlan, popEvents){
  const cal = el('feedCalendar');
  if(!cal){
    addWarning('Feeding calendar missing (#feedCalendar).');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'feedCalendar', context:'renderFeedingCalendar'});
    return;
  }
  const days = Math.max(0, Math.ceil(Number(params.days ?? 0)));
  DEBUG_STATE.lastFeedCalendarDays = days;
  const compact = days > 45;
  cal.classList.toggle('tiles', true);
  const startDate = new Date();
  startDate.setHours(12, 0, 0, 0);
  DEBUG_STATE.lastFeedCalendarStartISO = startDate.toISOString();
  cal.innerHTML = '';
  const labels = ['S','M','T','W','T','F','S'];
  const feedMap = new Map();
  for(const f of feedPlan){
    const idx = Math.floor(f.day);
    if(idx < 0 || idx >= days) continue;
    const prev = feedMap.get(idx) || {pellets:0, powder_g:0};
    prev.pellets += Number(f.pellets || 0);
    prev.powder_g += Number(f.powder_g || 0);
    feedMap.set(idx, prev);
  }
  const popMap = new Map();
  for(const e of popEvents || []){
    const idx = Math.floor(Number(e.day || 0));
    if(idx < 0 || idx >= days) continue;
    const prev = popMap.get(idx) || 0;
    popMap.set(idx, prev + Number(e.pellets || 0));
  }
  const monthStats = new Map();
  for(let i=0;i<days;i++){
    const dayDate = new Date(startDate);
    dayDate.setDate(startDate.getDate() + i);
    const key = `${dayDate.getFullYear()}-${dayDate.getMonth()}`;
    const stats = monthStats.get(key) || {feedDays:0, popDays:0, totalDays:0, label:''};
    stats.totalDays++;
    stats.label = dayDate.toLocaleString(undefined, {month:'long', year:'numeric'});
    if(feedMap.get(i)) stats.feedDays++;
    if(popMap.get(i)) stats.popDays++;
    monthStats.set(key, stats);
  }

  let currentKey = null;
  let monthGrid = null;
  let monthCount = 0;
  for(let i=0;i<days;i++){
    const dayDate = new Date(startDate);
    dayDate.setDate(startDate.getDate() + i);
    const key = `${dayDate.getFullYear()}-${dayDate.getMonth()}`;
    if(key !== currentKey){
      currentKey = key;
      monthCount++;
      const month = document.createElement('div');
      month.className = 'calendar-month';
      month.dataset.monthKey = key;
      if(calendarExpandedKey === key){
        month.classList.add('expanded');
      }
      const header = document.createElement('div');
      header.className = 'calendar-header';
      const stats = monthStats.get(key);
      const summary = stats ? `${stats.feedDays} feed ‚Ä¢ ${stats.popDays} pop` : '';
      const monthLabel = stats
        ? dayDate.toLocaleString(undefined, {month:'short', year:'2-digit'})
        : 'Month';
      const labelSpan = document.createElement('span');
      labelSpan.textContent = monthLabel;
      const actionWrap = document.createElement('div');
      actionWrap.className = 'month-actions';
      const summarySpan = document.createElement('span');
      summarySpan.className = 'summary';
      summarySpan.textContent = summary;
      const toggleBtn = document.createElement('button');
      toggleBtn.className = 'month-toggle';
      toggleBtn.type = 'button';
      toggleBtn.setAttribute('data-month-toggle', key);
      toggleBtn.addEventListener('click', (event)=>{
        event.stopPropagation();
        setCalendarTileFocus(key);
      });
      actionWrap.appendChild(summarySpan);
      actionWrap.appendChild(toggleBtn);
      header.appendChild(labelSpan);
      header.appendChild(actionWrap);
      month.appendChild(header);
      monthGrid = document.createElement('div');
      monthGrid.className = 'calendar-grid';
      for(const label of labels){
        const div = document.createElement('div');
        div.className = 'cal-label';
        div.textContent = label;
        monthGrid.appendChild(div);
      }
      const monthStart = new Date(dayDate.getFullYear(), dayDate.getMonth(), 1);
      const offset = monthStart.getDay();
      for(let o=0;o<offset;o++){
        const pad = document.createElement('div');
        pad.className = 'cal-cell empty';
        monthGrid.appendChild(pad);
      }
      month.appendChild(monthGrid);
      cal.appendChild(month);
    }

    const cell = document.createElement('div');
    const feed = feedMap.get(i);
    const pop = popMap.get(i);
    if(feed) cell.classList.add('feed');
    if(pop) cell.classList.add('pop');
    cell.classList.add('cal-cell');
    const meta = [];
    if(feed){
      if(feed.pellets) meta.push(`${feed.pellets} pel`);
      if(feed.powder_g) meta.push(`${feed.powder_g.toFixed(2)} g pow`);
    }
    if(pop) meta.push(`pop ${Math.round(pop)}`);
    const metaText = meta.join(' ‚Ä¢ ');
    if(!metaText){
      cell.classList.add('no-meta');
    }
    cell.innerHTML = `
      <div class="day-num">${dayDate.getDate()}</div>
      <div class="day-meta"></div>
    `;
    monthGrid.appendChild(cell);
  }
  DEBUG_STATE.lastFeedCalendarMonths = monthCount;
  DEBUG_STATE.lastFeedCalendarCompact = compact;
  const calWidth = cal.getBoundingClientRect().width;
  DEBUG_STATE.lastCalendarTileWidth = Number.isFinite(calWidth) ? (calWidth / Math.max(1, monthCount)) : null;
  DEBUG_STATE.lastCalendarMetaHidden = true;
  const columnCount = getComputedStyle(cal).gridTemplateColumns.split(' ').length;
  DEBUG_STATE.lastCalendarColumns = Number.isFinite(columnCount) ? columnCount : null;
  if(Number.isFinite(DEBUG_STATE.lastCalendarTileWidth) && DEBUG_STATE.lastCalendarTileWidth < 180){
    if(!DEBUG_STATE.lastCalendarTileWarnedISO){
      addWarning('Calendar tiles are narrow; consider expanding a month for readability.');
      DEBUG_STATE.lastCalendarTileWarnedISO = new Date().toISOString();
    }
  }else{
    DEBUG_STATE.lastCalendarTileWarnedISO = null;
  }
  if(calendarExpandedKey && !cal.querySelector(`[data-month-key="${calendarExpandedKey}"]`)){
    calendarExpandedKey = null;
  }
  DEBUG_STATE.lastCalendarExpandedKey = calendarExpandedKey;
  syncCalendarToggleState();
}

/* =========================================================
   DOM helpers + error plumbing
========================================================= */
const el = id => document.getElementById(id);
const setText = (id, value)=>{
  const node = el(id);
  if(node) node.textContent = value;
};

function ensureTooltip(){
  // Robust: support either #tip or legacy #tooltip. Create if missing.
  let t = el('tip') || el('tooltip');
  if(!t){
    t = document.createElement('div');
    t.className = 'tooltip';
    t.id = 'tip';
    document.body.appendChild(t);
  }
  return t;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

function showError(err){
  let box = el('errBox');
  let txt = el('errText');
  const note = el('modelStatusNote');
  const msg = (err && err.stack) ? err.stack : String(err);

  if(!box || !txt){
    box = document.createElement('div');
    box.id = 'errBox';
    box.className = 'errbox';
    box.style.display = 'block';
    box.innerHTML = `<b>Model error</b><pre id="errText"></pre>`;
    document.body.appendChild(box);
    txt = el('errText');
  }

  // Visible error banner
  if(box) box.style.display = 'block';
  if(txt) txt.textContent = msg;
  if(note) note.style.display = 'none';

  // Record into debug state
  try{
    DEBUG_STATE.errors.push({
      timeISO: new Date().toISOString(),
      name: (err && err.name) ? err.name : 'Error',
      message: (err && err.message) ? err.message : String(err),
      stack: (err && err.stack) ? err.stack : '',
      stage: DEBUG_STATE.stage,
      stageExtra: DEBUG_STATE.stageExtra
    });
  }catch(_){}

  // Populate debug panel with a snapshot + full stack
  try{
    const extra = [
      'Error:',
      msg
    ];
    setDebugText(buildDebugSnapshot(extra));
    const det = el('dbgDetails');
    if(det) det.open = true;
  }catch(_){}

  console.error(err);
}
function clearError(){
  const box = el('errBox');
  const text = el('errText');
  const note = el('modelStatusNote');
  if(box) box.style.display = 'none';
  if(text) text.textContent = '';
  if(note) note.style.display = 'block';
}


// ---------------- Debug state (for ‚Äúwhat just happened?‚Äù) ----------------
const DEBUG_STATE = {
  stage: 'init',
  stageExtra: '',
  lastParams: null,
  lastOxy: null,
  lastMode: null,
  lastSimMeta: null,
  lastScalars: null,
  lastChemCumInfo: null,
  lastRecomputeMs: null,
  lastFlagsCount: null,
  lastFlagsMode: null,
  lastPhotoModel: null,
  lastFeedProfileId: null,
  lastFeedProfileStoredAt: null,
  lastRateBandKeys: null,
  lastChemBandKeys: null,
  lastBandDiagnostics: null,
  lastOxygenClampCount: null,
  lastPlantLimitedSteps: null,
  lastBiomassSummary: null,
  lastTagSparkCount: null,
  lastFeedScheduleCount: null,
  lastFeedCalendarDays: null,
  lastFeedCalendarMonths: null,
  lastFeedCalendarCompact: null,
  lastFeedCalendarStartISO: null,
  lastCalendarExpandedKey: null,
  lastCalendarTileWidth: null,
  lastCalendarMetaHidden: null,
  lastCalendarColumns: null,
  lastCalendarTileWarnedISO: null,
  panelOverflowPx: null,
  panelOverflowLimitPx: 0,
  panelOverflowWarnedISO: null,
  lastPanelMeasureISO: null,
  lastDebugCopyStatus: null,
  lastDebugCopyError: null,
  lastUpdateISO: null,
  debounceQueued: 0,
  debounceMs: null,
  missingContainers: [],
  initReadyState: null,
  errors: [],  // newest last
  warnings: []
};

function setStage(stage, extra=null){
  DEBUG_STATE.stage = String(stage || '');
  DEBUG_STATE.stageExtra = extra ? String(extra) : '';
}

function addWarning(message){
  if(!message) return;
  DEBUG_STATE.warnings.push({
    timeISO: new Date().toISOString(),
    message: String(message),
    stage: DEBUG_STATE.stage,
    stageExtra: DEBUG_STATE.stageExtra
  });
}

function ensureFeedProfileMemory(){
  try{
    const key = 'aquachem.feedProfile';
    const existing = localStorage.getItem(key);
    if(!existing){
      localStorage.setItem(key, JSON.stringify(FEED_PROFILE));
      DEBUG_STATE.lastFeedProfileStoredAt = new Date().toISOString();
    }else{
      try{
        const parsed = JSON.parse(existing);
        if(parsed?.id !== FEED_PROFILE.id){
          localStorage.setItem(key, JSON.stringify(FEED_PROFILE));
          DEBUG_STATE.lastFeedProfileStoredAt = new Date().toISOString();
        }
      }catch(_){
        localStorage.setItem(key, JSON.stringify(FEED_PROFILE));
        DEBUG_STATE.lastFeedProfileStoredAt = new Date().toISOString();
      }
    }
    DEBUG_STATE.lastFeedProfileId = FEED_PROFILE.id;
  }catch(err){
    addWarning(`Unable to store feed profile memory: ${err?.message || err}`);
  }
}

function setDebugText(lines){
  const pre = el('dbg');
  if(!pre) return;
  pre.textContent = Array.isArray(lines) ? lines.join('\n') : String(lines ?? '');
}

function compactJSON(obj, maxLen=2200){
  try{
    const s = JSON.stringify(obj, (k,v)=>{
      // avoid dumping giant arrays into the debug panel
      if(Array.isArray(v) && v.length > 60){
        return {__array__: true, length: v.length, head: v.slice(0, 10), tail: v.slice(-10)};
      }
      return v;
    }, 2);
    return s.length > maxLen ? (s.slice(0, maxLen) + "\n‚Ä¶(truncated)‚Ä¶") : s;
  }catch(e){
    return `[unserializable: ${e}]`;
  }
}

function buildDebugSnapshot(extraLines=[]){
  const lines = [];
  lines.push(`Time: ${new Date().toISOString()}`);
  lines.push(`Stage: ${DEBUG_STATE.stage}${DEBUG_STATE.stageExtra ? ' ‚Äî ' + DEBUG_STATE.stageExtra : ''}`);
  if(DEBUG_STATE.lastMode) lines.push(`Mode: ${DEBUG_STATE.lastMode}`);
  lines.push(`devicePixelRatio: ${devicePixelRatio}`);
  lines.push(`UserAgent: ${navigator.userAgent}`);
  // DOM sanity
  try{
    const tipEl = el('tip') || el('tooltip');
    lines.push(`TooltipEl: ${tipEl ? ('#'+tipEl.id+' .' + (tipEl.className||'')) : 'missing'}`);
    const dbg = el('dbg');
    lines.push(`DebugEl: ${dbg ? '#dbg OK' : 'missing'}`);
  }catch(_){}
  if(DEBUG_STATE.lastParams){
    lines.push('');
    lines.push('--- Params (last) ---');
    const p = DEBUG_STATE.lastParams;
    // small, human-relevant subset first
    const dtDays = (p.dt != null) ? p.dt : (DEBUG_STATE.lastSimMeta && DEBUG_STATE.lastSimMeta.dt != null ? DEBUG_STATE.lastSimMeta.dt : null);
    const dtHours = (dtDays != null && Number.isFinite(dtDays)) ? (dtDays*24) : NaN;
    lines.push(`volL=${p.volL}, days=${p.days}, dtHours‚âà${Number.isFinite(dtHours) ? dtHours.toFixed(2) : 'n/a'}, airFlow=${p.airFlow} L/min @ alt=${p.altM} m`);
lines.push(`surface=${p.lenCm}√ó${p.widCm} cm, blanket=${p.blanketPct}%, ripple=${p.ripplePct}%`);
    lines.push(`diffuser=${p.diffType || 'n/a'}, depth=${p.diffDepthCm} cm, tight=${p.tight}`);
    lines.push(`pH=${p.pH}, heaters=${p.heaters}, nitCap=${p.nitCap}, nUnits=${p.nUnits}`);
    lines.push('');
    lines.push(compactJSON(p, 1600));
  }
  if(DEBUG_STATE.lastOxy){
    lines.push('');
    lines.push('--- Oxygenation (last) ---');
    const o = DEBUG_STATE.lastOxy;
    try{
      lines.push(`C*‚âà${(o.Cstar!=null?Number(o.Cstar).toFixed(2):(o.Cstar_mgL!=null?Number(o.Cstar_mgL).toFixed(2):'n/a'))} mg/L; OTRmax‚âà${(o.OTR_max!=null?Number(o.OTR_max).toFixed(3):(o.OTR_max_g_day!=null?Number(o.OTR_max_g_day).toFixed(3):'n/a'))} g/day; kLa‚âà${(o.kLa!=null?Number(o.kLa).toFixed(4):'n/a')} 1/day`);
      if(o.OTR_bubble_max!=null && o.OTR_surface_max!=null){
        lines.push(`bubble‚âà${Number(o.OTR_bubble_max).toFixed(3)} g/day; surface‚âà${Number(o.OTR_surface_max).toFixed(3)} g/day`);
      }
    }catch(_){}
    lines.push(compactJSON(o, 1800));
  }
  if(DEBUG_STATE.lastSimMeta){
    lines.push('');
    lines.push('--- Sim meta (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastSimMeta, 900));
  }
  if(DEBUG_STATE.lastBandDiagnostics){
    lines.push('');
    lines.push('--- Band diagnostics (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastBandDiagnostics, 600));
  }
  if(DEBUG_STATE.lastFeedCalendarDays != null){
    lines.push('');
    lines.push('--- Calendar (last) ---');
    lines.push(`days=${DEBUG_STATE.lastFeedCalendarDays}, months=${DEBUG_STATE.lastFeedCalendarMonths}, compact=${DEBUG_STATE.lastFeedCalendarCompact}, start=${DEBUG_STATE.lastFeedCalendarStartISO}`);
    if(DEBUG_STATE.lastCalendarExpandedKey){
      lines.push(`expanded=${DEBUG_STATE.lastCalendarExpandedKey}`);
    }
    if(Number.isFinite(DEBUG_STATE.lastCalendarTileWidth)){
      lines.push(`tileWidth=${DEBUG_STATE.lastCalendarTileWidth.toFixed(1)}px`);
    }
    if(DEBUG_STATE.lastCalendarMetaHidden != null){
      lines.push(`metaHidden=${DEBUG_STATE.lastCalendarMetaHidden ? 'yes' : 'no'}`);
    }
    if(Number.isFinite(DEBUG_STATE.lastCalendarColumns)){
      lines.push(`columns=${DEBUG_STATE.lastCalendarColumns}`);
    }
  }
  if(Number.isFinite(DEBUG_STATE.panelOverflowPx)){
    lines.push('');
    lines.push('--- Panel overflow ---');
    lines.push(`panelOverflowPx=${DEBUG_STATE.panelOverflowPx.toFixed(1)} (limit ${DEBUG_STATE.panelOverflowLimitPx}px)`);
    if(DEBUG_STATE.lastPanelMeasureISO){
      lines.push(`measured=${DEBUG_STATE.lastPanelMeasureISO}`);
    }
  }
  if(DEBUG_STATE.lastTagSummary){
    lines.push('');
    lines.push('--- Chemistry tags (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastTagSummary, 1200));
  }
  if(DEBUG_STATE.lastScalars){
    lines.push('');
    lines.push('--- Uncertainty scalars (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastScalars, 1200));
  }
  if(Number.isFinite(DEBUG_STATE.lastFlagsCount)){
    lines.push('');
    lines.push('--- Flags rendered (last) ---');
    lines.push(`Cards: ${DEBUG_STATE.lastFlagsCount}`);
    if(DEBUG_STATE.lastFlagsMode){
      lines.push(`Mode: ${DEBUG_STATE.lastFlagsMode}`);
    }
  }
  if(DEBUG_STATE.lastPhotoModel){
    lines.push('');
    lines.push('--- Photosynthesis model (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastPhotoModel, 900));
  }
  if(DEBUG_STATE.lastFeedProfileId){
    lines.push('');
    lines.push('--- Feed profile memory ---');
    lines.push(`Profile: ${DEBUG_STATE.lastFeedProfileId}`);
    if(DEBUG_STATE.lastFeedProfileStoredAt){
      lines.push(`Stored: ${DEBUG_STATE.lastFeedProfileStoredAt}`);
    }
  }
  if(DEBUG_STATE.lastDebugCopyStatus){
    lines.push('');
    lines.push('--- Debug copy ---');
    lines.push(`status=${DEBUG_STATE.lastDebugCopyStatus}`);
    if(DEBUG_STATE.lastDebugCopyError){
      lines.push(`error=${DEBUG_STATE.lastDebugCopyError}`);
    }
  }
  if(DEBUG_STATE.lastBiomassSummary){
    lines.push('');
    lines.push('--- Biomass summary (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastBiomassSummary, 800));
  }
  if(Number.isFinite(DEBUG_STATE.lastTagSparkCount)){
    lines.push('');
    lines.push('--- Chemistry tag sparklines ---');
    lines.push(`Rendered: ${DEBUG_STATE.lastTagSparkCount}`);
  }
  if(Number.isFinite(DEBUG_STATE.lastFeedScheduleCount)){
    lines.push('');
    lines.push('--- Feeding schedule ---');
    lines.push(`Feed events: ${DEBUG_STATE.lastFeedScheduleCount}`);
    if(Number.isFinite(DEBUG_STATE.lastFeedCalendarDays)){
      lines.push(`Calendar days: ${DEBUG_STATE.lastFeedCalendarDays}`);
    }
  }
  if(DEBUG_STATE.lastRateBandKeys){
    lines.push('');
    lines.push('--- Uncertainty bands (rate) ---');
    lines.push(DEBUG_STATE.lastRateBandKeys.join(', '));
  }
  if(DEBUG_STATE.lastChemBandKeys){
    lines.push('');
    lines.push('--- Uncertainty bands (chem) ---');
    lines.push(DEBUG_STATE.lastChemBandKeys.join(', '));
  }
  if(Number.isFinite(DEBUG_STATE.lastOxygenClampCount)){
    lines.push('');
    lines.push('--- Oxygen saturation clamps ---');
    lines.push(`DO clamped steps: ${DEBUG_STATE.lastOxygenClampCount}`);
    if(Number.isFinite(DEBUG_STATE.lastPlantLimitedSteps)){
      lines.push(`O2 degassed steps: ${DEBUG_STATE.lastPlantLimitedSteps}`);
    }
  }
  if(DEBUG_STATE.missingContainers.length){
    lines.push('');
    lines.push('--- Missing containers (recent) ---');
    const recent = DEBUG_STATE.missingContainers.slice(-3);
    recent.forEach((m, i)=>{
      lines.push(`#${DEBUG_STATE.missingContainers.length - recent.length + i + 1} ${m.timeISO} ‚Äî ${m.id} (${m.context})`);
    });
  }
  if(Number.isFinite(DEBUG_STATE.lastRecomputeMs)){
    lines.push('');
    lines.push('--- Recompute timing (last) ---');
    lines.push(`Total recompute: ${DEBUG_STATE.lastRecomputeMs.toFixed(1)} ms`);
  }
  if(Number.isFinite(DEBUG_STATE.debounceQueued) || Number.isFinite(DEBUG_STATE.debounceMs)){
    lines.push('');
    lines.push('--- Debounce ---');
    lines.push(`Queued recomputes: ${Number.isFinite(DEBUG_STATE.debounceQueued) ? DEBUG_STATE.debounceQueued : 0}`);
    if(Number.isFinite(DEBUG_STATE.debounceMs)){
      lines.push(`Delay: ${DEBUG_STATE.debounceMs} ms`);
    }
  }
  if(DEBUG_STATE.initReadyState){
    lines.push('');
    lines.push('--- Init ---');
    lines.push(`ReadyState at init: ${DEBUG_STATE.initReadyState}`);
  }
  if(DEBUG_STATE.lastChemCumInfo){
    lines.push('');
    lines.push('--- Chemistry cumulative (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastChemCumInfo, 900));
  }
  if(extraLines && extraLines.length){
    lines.push('');
    lines.push('--- Notes ---');
    for(const l of extraLines) lines.push(String(l));
  }
  // recent errors
  if(DEBUG_STATE.errors.length){
    lines.push('');
    lines.push('--- Recent errors ---');
    const recent = DEBUG_STATE.errors.slice(-3);
    recent.forEach((e, i)=>{
      lines.push(`#${DEBUG_STATE.errors.length - recent.length + i + 1} ${e.timeISO} ‚Äî ${e.name}: ${e.message}`);
      if(e.stage) lines.push(`  stage: ${e.stage}${e.stageExtra ? ' ‚Äî ' + e.stageExtra : ''}`);
      if(e.stack) lines.push('  stack: ' + e.stack.split('\n').slice(0,5).join(' | '));
    });
  }
  if(DEBUG_STATE.warnings.length){
    lines.push('');
    lines.push('--- Recent warnings ---');
    const recent = DEBUG_STATE.warnings.slice(-3);
    recent.forEach((w, i)=>{
      lines.push(`#${DEBUG_STATE.warnings.length - recent.length + i + 1} ${w.timeISO} ‚Äî ${w.message}`);
      if(w.stage) lines.push(`  stage: ${w.stage}${w.stageExtra ? ' ‚Äî ' + w.stageExtra : ''}`);
    });
  }
  return lines;
}
function assertFinite(name, v){
  if(!Number.isFinite(v)) throw new Error(`Non-finite value for ${name}: ${v}`);
  return v;
}

function installGlobalErrorHandlers(){
  if(window.__o2planner_err_bound) return;
  window.__o2planner_err_bound = true;
  window.addEventListener('error', (event)=>{
    const err = event?.error || new Error(event?.message || 'Unknown error');
    showError(err);
  });
  window.addEventListener('unhandledrejection', (event)=>{
    const err = event?.reason instanceof Error ? event.reason : new Error(String(event?.reason || 'Unhandled rejection'));
    showError(err);
  });
}

function linkRangeAndNumber(rangeEl, numEl, onChange){
  const sync = (src, dst)=>{ dst.value = src.value; onChange(); };
  rangeEl.addEventListener("input", ()=>sync(rangeEl, numEl));
  numEl.addEventListener("input", ()=>sync(numEl, rangeEl));
}

function wireActiveControlGlow(){
  const inputs = Array.from(document.querySelectorAll('input, select, textarea'));
  if(!inputs.length) return;
  inputs.forEach((input)=>{
    if(input.__glowBound) return;
    input.__glowBound = true;
    input.addEventListener('focus', ()=>{
      if(input.matches('input[type="range"]')) return;
      input.classList.add('control-active');
    });
    input.addEventListener('blur', ()=>{
      input.classList.remove('control-active');
    });
    input.addEventListener('change', ()=>{
      if(input.matches('select')){
        input.classList.add('control-active');
        setTimeout(()=>input.classList.remove('control-active'), 450);
      }
    });
  });
}

function measurePanelOverflow(){
  const panel = document.querySelector('.left-panel');
  if(!panel){
    addWarning('Left panel missing for overflow metrics.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'left-panel', context:'measurePanelOverflow'});
    return;
  }
  const panelHeight = panel.getBoundingClientRect().height;
  const viewportHeight = window.innerHeight || 0;
  const limit = Math.max(140, Math.round(viewportHeight * 0.18));
  const overflow = Math.max(0, panelHeight - (viewportHeight - 24));
  DEBUG_STATE.panelOverflowPx = overflow;
  DEBUG_STATE.panelOverflowLimitPx = limit;
  DEBUG_STATE.lastPanelMeasureISO = new Date().toISOString();
  if(overflow > limit){
    if(!DEBUG_STATE.panelOverflowWarnedISO){
      addWarning(`Left panel exceeds viewport by ${overflow.toFixed(0)}px; consider collapsing drawers.`);
      DEBUG_STATE.panelOverflowWarnedISO = new Date().toISOString();
    }
  }else{
    DEBUG_STATE.panelOverflowWarnedISO = null;
  }
}

function enableDebugCopyRoutine(){
  const btn = el('copyDebugBtn');
  const status = el('copyDebugStatus');
  if(!btn || !status){
    addWarning('Copy debug controls missing (#copyDebugBtn or #copyDebugStatus).');
    return;
  }
  const announce = (message, isWarn=false)=>{
    status.textContent = message;
    status.classList.toggle('warn', isWarn);
    status.style.display = 'inline-flex';
    setTimeout(()=>{ status.style.display = 'none'; }, 2400);
  };
  if(btn.__copyBound) return;
  btn.__copyBound = true;
  btn.addEventListener('click', async ()=>{
    const dbgText = el('dbg') ? el('dbg').textContent : '';
    if(!dbgText || !dbgText.trim()){
      DEBUG_STATE.lastDebugCopyStatus = 'empty';
      DEBUG_STATE.lastDebugCopyError = 'Debug log empty';
      addWarning('Debug log copy requested but debug log is empty.');
      announce('Nothing to copy', true);
      return;
    }
    try{
      if(navigator.clipboard?.writeText){
        await navigator.clipboard.writeText(dbgText);
      }else{
        const helper = document.createElement('textarea');
        helper.value = dbgText;
        helper.setAttribute('readonly', '');
        helper.style.position = 'absolute';
        helper.style.left = '-9999px';
        document.body.appendChild(helper);
        helper.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(helper);
        if(!ok) throw new Error('execCommand copy failed');
      }
      DEBUG_STATE.lastDebugCopyStatus = 'copied';
      DEBUG_STATE.lastDebugCopyError = null;
      announce('Debug log copied');
    }catch(err){
      const message = err?.message || String(err);
      DEBUG_STATE.lastDebugCopyStatus = 'failed';
      DEBUG_STATE.lastDebugCopyError = message;
      addWarning(`Debug log copy failed: ${message}`);
      announce('Copy failed', true);
    }
  });
}

window.addEventListener('error', (e)=>{ try{ showError(e.error || e.message || e); }catch(_){ }});
window.addEventListener('unhandledrejection', (e)=>{ try{ showError(e.reason || e); }catch(_){ }});

/* =========================================================
   Oxygenation / DO model (inference)
========================================================= */
const PHYS = {
  R: 8.314462618,     // J/mol/K
  O2_FRACTION: 0.2095,
  M_O2: 31.998,       // g/mol
  P0_kPa: 101.325
};

function pressureFromAltitude_kPa(alt_m){
  // Standard atmosphere approximation:
  // P = 101.325 * (1 - 2.25577e-5*h)^5.25588
  const h = Math.max(0, alt_m);
  const P = PHYS.P0_kPa * Math.pow(1 - 2.25577e-5*h, 5.25588);
  return clamp(P, 30, 110);
}

function doSatSeaLevel_mgL_fresh(T_C){
  // Common polynomial for freshwater DO saturation at 1 atm.
  const T = T_C;
  const sat = 14.652 - 0.41022*T + 0.007991*T*T - 0.000077774*T*T*T;
  return Math.max(0, sat);
}

function doSat_mgL(T_C, alt_m, tds_mgL){
  const P = pressureFromAltitude_kPa(alt_m);
  const sat0 = doSatSeaLevel_mgL_fresh(T_C);

  // Very light salinity-ish correction from TDS (ppt ~ g/L).
  // This is intentionally conservative/rough: you can override with calibration later.
  const sal_ppt = Math.max(0, tds_mgL/1000);
  const salFactor = clamp(1 - 0.01*sal_ppt, 0.80, 1.0); // ~1% per ppt (rough)

  const pressFactor = P / PHYS.P0_kPa;
  return sat0 * salFactor * pressFactor;
}

function oxygenMassInPumpedAir_g_per_day(airFlow_L_min, T_C, alt_m){
  // PV=nRT to convert airflow at ambient pressure into moles of gas, then oxygen mass.
  const P_kPa = pressureFromAltitude_kPa(alt_m);
  const P_Pa = P_kPa * 1000;
  const T_K = (T_C + 273.15);

  const V_m3_per_min = Math.max(0, airFlow_L_min) / 1000;
  const n_total_per_min = (P_Pa * V_m3_per_min) / (PHYS.R * T_K);
  const n_O2_per_min = n_total_per_min * PHYS.O2_FRACTION;
  const g_O2_per_min = n_O2_per_min * PHYS.M_O2;

  return g_O2_per_min * 1440;
}

function computeAreas(params){
  const L = Math.max(1e-6, params.lenCm/100);
  const W = Math.max(1e-6, params.widCm/100);
  const A_total = L * W;

  const openFrac = clamp(1 - params.blanketPct/100, 0, 1);
  const A_open = A_total * openFrac;
  const A_cov  = A_total - A_open;

  const rippleFrac = clamp(params.ripplePct/100, 0, 1);
  const A_ripple = A_total * rippleFrac;

  // Assume ripple happens mostly where bubbles are (uncovered zone), but allow overflow.
  const A_ripple_open = Math.min(A_ripple, A_open);
  const A_ripple_cov  = Math.max(0, A_ripple - A_ripple_open);

  const A_calm_open = Math.max(0, A_open - A_ripple_open);
  const A_calm_cov  = Math.max(0, A_cov  - A_ripple_cov);

  return {A_total, A_open, A_cov, A_ripple_open, A_ripple_cov, A_calm_open, A_calm_cov};
}

function computeHeadspace(params, areas){
  // Headspace height = (tank height - water surface height) + extra blanket gap above rim.
  const tankH_m = Math.max(0, params.tankHCm/100);
  const waterSurf_m = Math.max(0, params.waterSurfCm/100);
  const gap_m = Math.max(0, params.blanketGapCm/100);
  const headH_m = Math.max(0, (tankH_m - waterSurf_m) + gap_m);

  const V_head_m3 = areas.A_total * headH_m;
  const V_head_L = V_head_m3 * 1000;

  // How often the pump could replace the headspace volume, if air actually circulates.
  const turnover_min = (params.airFlow > 1e-9) ? (V_head_L / params.airFlow) : Infinity;

  return {headH_m, V_head_L, turnover_min};
}

function coverLeakFactor(params, head){
  // Blanket penalty is mostly about how well the headspace exchanges with room air.
  // Two forgiving factors:
  //   (a) pump constantly flushing the headspace (short turnover)
  //   (b) large headspace buffers composition drift (slower change)
  //
  // We fold those into an effective tightness and map it to a multiplier on surface k.

  const tight = clamp(params.tight, 0, 1);

  // If turnover is fast (<30 min), ventilation is strong ‚Üí penalty shrinks.
  const ventScore = Number.isFinite(head.turnover_min)
    ? clamp(30 / Math.max(1e-6, head.turnover_min), 0, 1)
    : 0;

  // Larger headspace is more forgiving even if tight (composition changes slower).
  const Vref = 15; // L (tunable)
  const bufferScore = clamp(Vref / (Vref + Math.max(0, head.V_head_L)), 0, 1);

  const effTight = tight * (1 - ventScore) * bufferScore;

  // effTight=0 ‚Üí almost no penalty
  // effTight=1 ‚Üí strong penalty (nearly sealed, small headspace, poor ventilation)
  return (1 - effTight) * 0.90 + effTight * 0.05;
}

function oxygenationModel(params){
  const T = params.Tnow;
  const Cstar = doSat_mgL(T, params.altM, params.tds); // mg/L

  const areas = computeAreas(params);
  const head  = computeHeadspace(params, areas);

  // Bubble transfer:
  // O2_in_air_g_day scales with pressure (altitude) and airflow.
  const depth_m = Math.max(0, params.diffDepthCm/100);
  const sote_per_m = Math.max(0, params.sotePerM/100); // fraction per meter
  const O2_in_air_g_day = oxygenMassInPumpedAir_g_per_day(params.airFlow, T, params.altM);

  // Efficiency fraction over depth. Cap to avoid silly inputs.
  const eff_bubble = clamp(sote_per_m * depth_m * Math.max(0.05, params.otrCal), 0, 0.35);
  const OTR_bubble_max = O2_in_air_g_day * eff_bubble;

  // Surface transfer:
  // Treat k as a "film speed" (m/day). OTR_surface_max = C* (g/m^3) * k*A (m^3/day).
  // Note: mg/L == g/m^3 numerically.
  const kC = clamp(params.kCalm,   0, 10);
  const kR = clamp(params.kRipple, 0, 10);

  const leak = coverLeakFactor(params, head);

  const kA_open = kC*areas.A_calm_open + kR*areas.A_ripple_open;
  const kA_cov  = (kC*areas.A_calm_cov + kR*areas.A_ripple_cov) * leak;

  const Cstar_g_m3 = Cstar;
  const OTR_surface_max = Cstar_g_m3 * (kA_open + kA_cov);

  // Total max transfer at DO‚âà0.
  const OTR_max = OTR_bubble_max + OTR_surface_max;

  // Infer kLa from OTR_max = kLa * C* * V
  const volL = Math.max(1e-6, params.volL);
  const kLa = (Cstar > 1e-9) ? ((OTR_max*1000) / (Cstar * volL)) : 0; // 1/day

  return {
    T, Cstar, areas, head,
    leak, O2_in_air_g_day, eff_bubble,
    OTR_bubble_max, OTR_surface_max, OTR_max, kLa
  };
}

/* =========================================================
   Demand model (mostly carried over)
========================================================= */
const FEED_PROFILE = {
  id: 'lomas-premium-reptile-sticks',
  name: 'Store Lomas Premium Reptile Sticks',
  guaranteedAnalysis: {
    proteinMin: 0.40,
    fatMin: 0.08,
    fiberMax: 0.04,
    moistureMax: 0.10
  },
  ingredients: [
    'fish meal', 'chicken meal', 'crab meal', 'soybean meal', 'wheat flour/byproducts',
    'corn gluten', 'stabilized fish oil', 'orthophosphate',
    'vitamins (A, D3, B12, riboflavin, niacin, pantothenic acid, pyridoxine, thiamine, biotin, E, stabilized C)',
    'choline chloride',
    'minerals (selenium, manganese, zinc, copper, iodine)',
    'propionic acid', 'ethoxyquin'
  ],
  modeling: {
    proteinFraction: 0.40,
    fatFraction: 0.08,
    moistureFraction: 0.10,
    ashFraction: 0.10,
    carbFraction: 0.28,
    ashRange: [0.08, 0.12],
    carbRange: [0.26, 0.30],
    nitrogenFraction: 0.40/6.25,
    macroRelease_mgL_per_g: 8.0,
    microRelease_mgL_per_g: 1.2,
    macroUptake_mgL_per_g_photo_day: 0.6,
    microUptake_mgL_per_g_photo_day: 0.12,
    copperFractionOfMicro: 0.05
  },
  notes: 'Stored feed profile for future aquarium calculations (retailer/brand listing).'
};

const PHOTO_MODEL = {
  o2_mg_g_day_peak: 6.0,
  co2_consumption_per_gO2: 1.0,
  q10: 2.0,
  refTempC: 25,
  mu_max_per_day: 0.55,
  decay_per_day: 0.05,
  resp_mg_g_day: 2.0,
  co2_per_g_growth: 1.5
};

const PHYTO_SPLIT = {
  algae: 0.4,
  plankton: 0.35,
  plants: 0.25
};

const HET_SPLIT = {
  biofilm: 0.65,
  predator: 0.35
};

const PHYTO_COMPARTMENTS = {
  algae: {
    mu_max_per_day: 0.78,
    decay_per_day: 0.08,
    reserveFrac: 0.32,
    reserveCapFrac: 0.28,
    nightGrowthFrac: 0.18
  },
  plankton: {
    mu_max_per_day: 0.72,
    decay_per_day: 0.075,
    reserveFrac: 0.3,
    reserveCapFrac: 0.26,
    nightGrowthFrac: 0.2
  },
  plants: {
    mu_max_per_day: 0.32,
    decay_per_day: 0.03,
    reserveFrac: 0.62,
    reserveCapFrac: 0.65,
    nightGrowthFrac: 0.5
  }
};

const FISH_MODEL = {
  o2_mg_g_day_base: 5.0,
  q10: 2.0,
  refTempC: 25
};

const HET_MODEL = {
  growth_per_day: 0.35,
  decay_per_day: 0.08,
  macroUptake_mgL_per_g_day: 0.18,
  microUptake_mgL_per_g_day: 0.04
};

const TROPHIC_MODEL = {
  biofilm: {
    grazingMax_g_g_day: 0.16,
    decay_per_day: 0.07,
    yield: 0.48,
    assimEff: 0.76,
    lagDays: 0.5
  },
  predator: {
    grazingMax_g_g_day: 0.1,
    decay_per_day: 0.1,
    yield: 0.42,
    assimEff: 0.68,
    lagDays: 0.7
  }
};

const FRACTIONS = {
  protein: FEED_PROFILE.modeling.proteinFraction,
  fat: FEED_PROFILE.modeling.fatFraction,
  carb: FEED_PROFILE.modeling.carbFraction
};
const CHEM = {
  // g O2 per g substrate oxidized to CO2 (approx)
  O2_protein_C: 1.42,
  O2_fat: 2.90,
  O2_carb: 1.185,
  CO2_per_gO2: 1.0,
  N_bio_per_COD: 0.1,

  // crude protein nitrogen fraction
  gN_per_g_protein: 1/6.25,

  // ion conversion ratios (mg/L as ion per mg/L as N)
  NH4_ion_per_N: 18.038/14.007,
  NO2_ion_per_N: 46.0055/14.007,
  NO3_ion_per_N: 62.0049/14.007,
  NH3_ion_per_N: 17.031/14.007,

  // nitrification stoich: per g N
  // NH4+ + 1.5 O2 -> NO2- + H2O + 2H+   (48 g O2 per 14 g N)
  // NO2- + 0.5 O2 -> NO3-              (16 g O2 per 14 g N)
  O2_per_gN_NH4_to_NO2: 48/14,
  O2_per_gN_NO2_to_NO3: 16/14
};

function pelletMassEach(pelLen_cm, pelDia_cm, rho_g_cm3){
  const r = pelDia_cm/2;
  const vol = Math.PI * r*r * pelLen_cm; // cm^3
  return vol * rho_g_cm3; // g
}

function nh3Fraction(pH, tempC){
  const T = tempC + 273.15;
  const pKa = 0.09018 + (2729.92 / T);
  const frac = 1 / (1 + Math.pow(10, pKa - pH));
  return clamp(frac, 0, 1);
}

function calcCO2EquilMgL(tempC){
  const tempAdj = clamp(1 - 0.02 * (tempC - 25), 0.5, 1.4);
  return clamp(0.6 * tempAdj, 0.2, 1.2);
}

function calcCO2SaturationMgL(tempC, altM){
  const tempAdj = clamp(1 - 0.03 * (tempC - 20), 0.4, 1.6);
  const pressureAdj = clamp(pressureFromAltitude_kPa(altM) / 101.325, 0.6, 1.2);
  return clamp(2.5 * tempAdj * pressureAdj, 0.5, 6.0);
}

function estimateCarbonatePartitioning(tempC, pH, alkalinity_mgL, dic_g, volL){
  const pKa1 = 6.35 - 0.015 * (tempC - 25);
  const pKa2 = 10.33 - 0.018 * (tempC - 25);
  const H = Math.pow(10, -clamp(pH, 5.5, 9.5));
  const K1 = Math.pow(10, -pKa1);
  const K2 = Math.pow(10, -pKa2);
  const alpha0 = 1 / (1 + (K1 / H) + (K1 * K2) / (H * H));
  const dic_mgL = (dic_g * 1000) / Math.max(1e-9, volL);
  const co2Free_mgL = dic_mgL * alpha0;
  const bufferCapacity = clamp(alkalinity_mgL / (alkalinity_mgL + dic_mgL + 1e-9), 0, 1);
  return {
    alpha0,
    dic_mgL,
    co2Free_mgL,
    co2Free_g: (co2Free_mgL * volL) / 1000,
    bufferCapacity
  };
}

// crude "sinks over first few days"
function sinkingHazard(day){
  if(day < 1) return 0;
  if(day >= 3) return 50;
  return 1 / Math.max(3 - day, 0.05);
}

function estimateBiofilmMass(params){
  const len = Math.max(0, Number(params.lenCm ?? 0));
  const wid = Math.max(0, Number(params.widCm ?? 0));
  const tankH = Math.max(0, Number(params.tankHCm ?? 0));
  const waterDepth = clamp(Number(params.waterSurfCm ?? tankH), 0, tankH);
  const area_cm2 = (len * wid) + 2 * (len * waterDepth + wid * waterDepth);
  const thickness_cm = Math.max(0, Number(params.biofilmMm ?? 0)) / 10;
  const density_g_cm3 = 0.12; // wet biofilm solids-equivalent density
  return Math.max(0, area_cm2 * thickness_cm * density_g_cm3);
}

function runSimulation(params){
  // dt: keep ~1200 points for smooth plots
  const targetPts = 1200;
  let dt = params.days/targetPts;
  dt = clamp(dt, 1/48, 1/6); // between 0.5h and 4h
  const n = Math.floor(params.days/dt) + 1;

  const oxy = oxygenationModel(params);

  // temperature factor (this is for biology only, not for physics C*)
  const Q10 = 2.0;
  const bioMult = (Number.isFinite(params.bioMult) ? params.bioMult : 1.0);

  // Kinetics base (1/day). Pellets slower than powder.
  const k_h_pel = {carb:0.35, prot:0.20, fat:0.08};
  const k_ox_pel= {carb:0.65, prot:0.40, fat:0.22};
  const Y_pel   = {carb:0.30, prot:0.42, fat:0.28};
  const k_endog_pel = 0.12;
  const k_nit_pel   = {nh4:0.75, no2:1.05};

  const k_h_pow = {carb:1.10, prot:0.80, fat:0.35};
  const k_ox_pow= {carb:1.60, prot:1.05, fat:0.55};
  const Y_pow   = {carb:0.34, prot:0.46, fat:0.30};
  const k_endog_pow = 0.18;
  const k_nit_pow   = {nh4:1.20, no2:1.70};

  const accessFloat = 1.00;
  const heaterLevel = clamp(Math.round(params.heaters || 0), 0, 2);
  const accessBottom= (heaterLevel === 2) ? 0.55 : (heaterLevel === 1 ? 0.40 : 0.30);
  const oxFloat = 1.00;
  const oxBottom= (heaterLevel === 2) ? 0.75 : (heaterLevel === 1 ? 0.55 : 0.45);

  // Pools (g as-fed broken into components)
  let pelFloat = {carb:0, prot:0, fat:0};
  let pelBot = {carb:0, prot:0, fat:0};
  let powBot = {carb:0, prot:0, fat:0};

  let S = {carb:0, prot:0, fat:0}; // soluble pool (g)
  let S_slow = {carb:0, prot:0, fat:0}; // refractory pool (g)
  let COD_bio = 0; // g O2-eq stored in heterotroph biomass
  let N_bio = 0;   // g N stored in biomass
  let NH4 = 0;     // g N
  let NO2 = 0;     // g N
  let NO3 = 0;     // g N
  let DIC_g = 0;   // g total dissolved inorganic carbon
  let CO2_free_g = 0; // g free CO2 (aqueous)
  let macro_g = 0; // g (proxy)
  let micro_g = 0; // g (proxy)
  let phytoAlgae_g = Math.max(0, Number(params.phytoAlgae_g ?? (params.photoMass ?? 0) * PHYTO_SPLIT.algae));
  let phytoPlankton_g = Math.max(0, Number(params.phytoPlankton_g ?? (params.photoMass ?? 0) * PHYTO_SPLIT.plankton));
  let phytoPlants_g = Math.max(0, Number(params.phytoPlants_g ?? (params.photoMass ?? 0) * PHYTO_SPLIT.plants));
  let phytoMass_g = Math.max(0, phytoAlgae_g + phytoPlankton_g + phytoPlants_g);
  let biofilm_g = Math.max(0, Number(params.biofilm_g ?? (params.heteroMass ?? 0) * HET_SPLIT.biofilm));
  let predator_g = Math.max(0, Number(params.predator_g ?? (params.heteroMass ?? 0) * HET_SPLIT.predator));
  let heteroMass_g = Math.max(0, biofilm_g + predator_g);
  const heteroMass0 = heteroMass_g;
  const phytoMass0 = phytoMass_g;
  const phytoAlgae0 = phytoAlgae_g;
  const phytoPlankton0 = phytoPlankton_g;
  const phytoPlants0 = phytoPlants_g;
  const biofilm0 = biofilm_g;
  const predator0 = predator_g;
  let phytoAlgaeOpen_g = phytoAlgae_g;
  let phytoAlgaeRefuge_g = 0;
  let phytoPlanktonOpen_g = phytoPlankton_g;
  let phytoPlanktonRefuge_g = 0;
  let phytoAlgaeReserve_g = 0;
  let phytoPlanktonReserve_g = 0;
  let phytoPlantsReserve_g = 0;
  let phytoN_store_g = 0;
  let phytoP_store_g = 0;
  let heteroExtinctHits = 0;
  let phytoExtinctHits = 0;
  let phytoAlgaeExtinctHits = 0;
  let phytoPlanktonExtinctHits = 0;
  let phytoPlantsExtinctHits = 0;
  let biofilmExtinctHits = 0;
  let predatorExtinctHits = 0;
  let heteroExtinctWarned = false;
  let phytoExtinctWarned = false;
  let phytoAlgaeExtinctWarned = false;
  let phytoPlanktonExtinctWarned = false;
  let phytoPlantsExtinctWarned = false;
  let biofilmExtinctWarned = false;
  let predatorExtinctWarned = false;
  let macroConsumed_g = 0;
  let microConsumed_g = 0;
  let co2Consumed_g = 0;
  let no3Denit_g = 0;
  let heteroGrowthTotal = 0;
  let heteroConsumedTotal = 0;
  let phytoGrowthTotal = 0;
  let phytoAlgaeGrowthTotal = 0;
  let phytoPlanktonGrowthTotal = 0;
  let phytoPlantsGrowthTotal = 0;
  let phytoConsumedTotal = 0;
  let phytoDecayTotal = 0;
  let phytoGrazedTotal = 0;
  let biofilmGrazedTotal = 0;
  let predatorGrazedTotal = 0;
  let phytoNightGrowthTotal = 0;
  let phytoReserveBuilt = 0;
  let phytoReserveUsed = 0;
  let luxuryUptakeTotal = 0;
  let phytoStoreNegativeHits = 0;
  let phytoStoreDepleteHits = 0;
  let phytoStoreFillLast = 0;
  let phytoMuMaxLast = 0;
  let phytoMuEffLast = 0;
  let phytoMuCapHits = 0;
  let refugeFractionLast = 0;
  let refugeExchangeLast = 0;
  let refugeOverrunHits = 0;
  let refugeEmptyHits = 0;
  let phytoRecruitTotal = 0;
  let co2ZeroHits = 0;
  let co2DegasSteps = 0;
  let co2Degassed_g = 0;
  let oxygenClampCount = 0;
  let oxygenDegasSteps = 0;
  let oxygenDegassed_g = 0;
  let grazingLimitedSteps = 0;
  let predatorGrazingLimitedSteps = 0;
  let grazingShieldMin = 1;
  let predatorShieldMin = 1;
  let co2AirIn_g = 0;
  let co2AirOut_g = 0;
  let bufferDepletionHits = 0;
  let bufferCapacityMin = 1;
  let bufferCapacityLast = 1;
  let co2FreeMin_mgL = Infinity;
  let co2FreeLast_mgL = 0;
  let dicMin_mgL = Infinity;
  let dicLast_mgL = 0;
  let biofilmActivity = 0.2;
  let biofilmActivityMin = 1;
  let predatorActivity = 0.15;
  let predatorActivityMin = 1;
  let laggedBiofilmConsumptionTotal = 0;
  let laggedPredatorConsumptionTotal = 0;
  let grazingLagCollapseHits = 0;
  let predatorLagCollapseHits = 0;
  let biomassNonFiniteHits = 0;
  let phytoAlgaeNonFiniteHits = 0;
  let phytoPlanktonNonFiniteHits = 0;
  let phytoPlantsNonFiniteHits = 0;
  let biofilmNonFiniteHits = 0;
  let predatorNonFiniteHits = 0;
  let biofilmStableCollapseHits = 0;
  let predatorStableCollapseHits = 0;

  // Activity states (dimensionless 0..1)
  let Bhet = 0.04;
  let Bnit = 0.02;
  let Bden = 0.01;

  const Ks = 0.006; // g
  const Kn = 0.0012; // g N
  const rHet_base = 2.2;
  const dHet_base = 0.12;
  const nitQ10 = Number.isFinite(params.nitQ10) ? params.nitQ10 : 2.0;
  const rNit_base = 1.2;
  const dNit_base = 0.08;
  const rDen_base = 0.9;
  const dDen_base = 0.08;

  // DO dynamics
  const Cstar = oxy.Cstar;
  let DO = clamp(Cstar * (params.doInitPct/100), 0, Cstar*1.2);
  const kLa = oxy.kLa;

  const nitCap = clamp(Number(params.nitCap ?? 1), 0, 1);
  const denitCap = clamp(Number(params.denitCap ?? 1), 0, 1);
  const kNH4_g = (Number(params.kNH4Nit ?? 0) * params.volL) / 1000;
  const kNO2_g = (Number(params.kNO2Nit ?? 0) * params.volL) / 1000;
  const kDoHet = Math.max(0, Number(params.kDoHet ?? 0));
  const slowFrac = clamp(Number(params.slowFrac ?? 0), 0, 0.9);
  const biofilmMass_g = estimateBiofilmMass(params);
  const biofilmRef_g = Math.max(5, params.volL * 0.05);
  const biofilmMult = clamp(0.3 + Math.sqrt(biofilmMass_g / biofilmRef_g), 0.3, 2.5);
  const kDenit = Math.max(0, Number(params.kDenit ?? 0));
  const heteroMass = heteroMass_g;
  const photoMass = phytoMass_g;
  const tempAmp = Number(params.tempAmp ?? 0);
  const lightHour = Number(params.lightHour ?? 0);
  const macroRelease = FEED_PROFILE.modeling.macroRelease_mgL_per_g;
  const microRelease = FEED_PROFILE.modeling.microRelease_mgL_per_g;
  const biofilmGrazingHalfSat_g = Math.max(0.5, (phytoAlgae_g + phytoPlankton_g) * 0.25);
  const predatorGrazingHalfSat_g = Math.max(0.3, biofilm_g * 0.3);
  const phytoRefugiaFrac = 0.18;
  const phytoRecruitFrac = 0.04;
  const phytoStoreNCapFrac = 0.45;
  const phytoStorePCapFrac = 0.25;
  const phytoStoreNFrac = 0.7;
  const phytoStorePFrac = 0.3;
  const refugeExchangeRate = 0.12;

  phytoAlgaeRefuge_g = phytoAlgae_g * phytoRefugiaFrac;
  phytoAlgaeOpen_g = Math.max(0, phytoAlgae_g - phytoAlgaeRefuge_g);
  phytoPlanktonRefuge_g = phytoPlankton_g * phytoRefugiaFrac;
  phytoPlanktonOpen_g = Math.max(0, phytoPlankton_g - phytoPlanktonRefuge_g);

  // Outputs
  const out = {
    t: new Array(n),
    rate: {
      carb:new Array(n).fill(0),
      prot:new Array(n).fill(0),
      fat:new Array(n).fill(0),
      endog:new Array(n).fill(0),
      nh4:new Array(n).fill(0),
      no2:new Array(n).fill(0),
      hetero:new Array(n).fill(0),
      plant:new Array(n).fill(0),
      total:new Array(n).fill(0),
      supply:new Array(n).fill(0),
    },
    cum: {},
    DO_mgL: new Array(n).fill(0),
    DO_pct: new Array(n).fill(0),
    NH4_mgL: new Array(n).fill(0),
    NO2_mgL: new Array(n).fill(0),
    NO3_mgL: new Array(n).fill(0),
    NH3_mgL: new Array(n).fill(0),
    CO2_mgL: new Array(n).fill(0),
    DIC_mgL: new Array(n).fill(0),
    macro_mgL: new Array(n).fill(0),
    micro_mgL: new Array(n).fill(0),
    store_mgL: new Array(n).fill(0),
    chem: {
      nh4: new Array(n).fill(0),
      nh3: new Array(n).fill(0),
      no2: new Array(n).fill(0),
      no3: new Array(n).fill(0),
      co2: new Array(n).fill(0),
      dic: new Array(n).fill(0),
      store: new Array(n).fill(0),
      macro: new Array(n).fill(0),
      micro: new Array(n).fill(0),
    },
    audit: {
      nh4_from_pro:0,
      nh4_from_endog:0,
      nh4_to_no2:0,
      no2_to_no3:0,
      no3_to_n2:0,
      co2_from_ox:0,
      co2_from_endog:0,
      co2_from_denit:0,
      co2_degassed:0,
      co2_air_in:0,
      co2_air_out:0,
      o2_degassed:0,
      macro_release:0,
      macro_uptake:0,
      micro_release:0,
      micro_uptake:0,
      phyto_grazed:0,
      phyto_algae_grazed:0,
      phyto_plankton_grazed:0,
      biofilm_grazed:0,
      predator_grazed:0,
      biofilm_grazing_waste:0,
      predator_grazing_waste:0,
      n_balance_init:0,
      n_balance_end:0,
      c_balance_init:0,
      c_balance_end:0
    },
    meta: {
      dt,
      oxy,
      kLa,
      nitCap,
      denitCap,
      feedProfileId: FEED_PROFILE.id,
      photoModel: {
        photoMass_g: photoMass,
        o2_mg_g_day_peak: PHOTO_MODEL.o2_mg_g_day_peak,
        mu_max_per_day: PHOTO_MODEL.mu_max_per_day,
        resp_mg_g_day: PHOTO_MODEL.resp_mg_g_day,
        macroUptake_mgL_per_g_photo_day: FEED_PROFILE.modeling.macroUptake_mgL_per_g_photo_day,
        microUptake_mgL_per_g_photo_day: FEED_PROFILE.modeling.microUptake_mgL_per_g_photo_day,
        copperFractionOfMicro: FEED_PROFILE.modeling.copperFractionOfMicro
      },
      phytoCompartments: {
        algae: {...PHYTO_COMPARTMENTS.algae, mass_g: phytoAlgae_g},
        plankton: {...PHYTO_COMPARTMENTS.plankton, mass_g: phytoPlankton_g},
        plants: {...PHYTO_COMPARTMENTS.plants, mass_g: phytoPlants_g}
      },
      heteroModel: {
        heteroMass_g: heteroMass,
        o2_mg_g_day_base: FISH_MODEL.o2_mg_g_day_base,
        q10: FISH_MODEL.q10
      },
      trophicModel: {
        biofilm: {...TROPHIC_MODEL.biofilm, mass_g: biofilm_g},
        predator: {...TROPHIC_MODEL.predator, mass_g: predator_g}
      },
      feedStart:0,
      feedEnd:0,
      maxDemand:0,
      maxSupply:0,
      biofilmMass_g: biofilmMass_g,
      biofilmMult: biofilmMult,
      biofilmGrazingHalfSat_g: biofilmGrazingHalfSat_g,
      predatorGrazingHalfSat_g: predatorGrazingHalfSat_g,
      biofilmGrazingMax_g_g_day: TROPHIC_MODEL.biofilm.grazingMax_g_g_day,
      predatorGrazingMax_g_g_day: TROPHIC_MODEL.predator.grazingMax_g_g_day,
      phytoRefugiaFrac: phytoRefugiaFrac,
      phytoRecruitFrac: phytoRecruitFrac
    }
  };
  out.biomass = {
    hetero_g: new Array(n).fill(heteroMass_g),
    phyto_g: new Array(n).fill(phytoMass_g),
    hetero_pct: new Array(n).fill(0),
    phyto_pct: new Array(n).fill(0)
  };
  out.chemProd = {
    nh4: new Array(n).fill(0),
    nh3: new Array(n).fill(0),
    no2: new Array(n).fill(0),
    no3: new Array(n).fill(0),
      co2: new Array(n).fill(0),
      dic: new Array(n).fill(0),
      store: new Array(n).fill(0),
    macro: new Array(n).fill(0),
    micro: new Array(n).fill(0),
  };

  const pelletEachMass_g = pelletMassEach(params.pelLen, params.pelDia, params.pelRho);
  let simFeedPlan = params.feedSchedule || buildFeedSchedule(params, pelletEachMass_g);
  if(!Array.isArray(simFeedPlan)){
    addWarning('Feed plan invalid; defaulting to empty schedule.');
    simFeedPlan = [];
  }
  const feedWindowHours = clamp(Number(params.feedWindowHours ?? 4), 0.5, 24);
  const feedPulse = buildFeedPulse(simFeedPlan, dt, params.days, feedWindowHours / 24);

  // Events sorted
  const ev = [...params.events]
    .filter(e=>Number.isFinite(e.day) && Number.isFinite(e.pellets) && e.pellets>0)
    .sort((a,b)=>a.day-b.day);
  let evIdx = 0;

  function blend(a,b,w){ return a*(1-w) + b*w; }

  function pelTotalComp(){
    return {
      carb: pelFloat.carb + pelBot.carb,
      prot: pelFloat.prot + pelBot.prot,
      fat:  pelFloat.fat  + pelBot.fat
    };
  }
  function removeFromPellets(compMass){
    for(const k of ["carb","prot","fat"]){
      let need = compMass[k];
      const takeF = Math.min(need, pelFloat[k]);
      pelFloat[k] -= takeF;
      need -= takeF;
      const takeB = Math.min(need, pelBot[k]);
      pelBot[k] -= takeB;
    }
  }
  function addToPowder(compMass){
    for(const k of ["carb","prot","fat"]) powBot[k] += compMass[k];
  }

  function fluxPellet(Pmass, k, access){
    // surface-limited intact pellet: ~ M^(2/3)
    return k * access * Math.pow(Math.max(Pmass,0), 2/3);
  }
  function fluxPowder(Pmass, k){
    // distributed powder: first-order
    return k * Math.max(Pmass,0);
  }
  function capFlux(flux, mass){
    if(mass <= 0) return 0;
    return Math.min(flux, mass/dt);
  }

  let feedAddedN_g = 0;
  let feedAddedC_g = 0;
  out.audit.n_balance_init = 0;
  out.audit.c_balance_init = 0;
  out.meta.feedStart = 0;
  const photoO2_g_day_peak = (PHOTO_MODEL.o2_mg_g_day_peak * photoMass) / 1000;
  const macroUptakeRate_g_day = (FEED_PROFILE.modeling.macroUptake_mgL_per_g_photo_day * photoMass * params.volL) / 1000;
  const microUptakeRate_g_day = (FEED_PROFILE.modeling.microUptake_mgL_per_g_photo_day * photoMass * params.volL) / 1000;
  const alkalinity_mgL = clamp(Number(params.alkalinity_mgL ?? 80), 10, 400);
  const co2Init_mgL = calcCO2EquilMgL(oxy.T);
  const co2Init_free_g = (co2Init_mgL * params.volL) / 1000;
  const initPartition = estimateCarbonatePartitioning(oxy.T, params.pH ?? 7.0, alkalinity_mgL, co2Init_free_g, params.volL);
  const dicInit_g = initPartition.alpha0 > 1e-8 ? (co2Init_free_g / initPartition.alpha0) : co2Init_free_g;
  DIC_g = Math.max(DIC_g, dicInit_g);
  const co2HalfSat_g = Math.max(co2Init_free_g * 0.6, 1e-6);
  const co2Sat_mgL = calcCO2SaturationMgL(oxy.T, params.altM ?? 0);
  const co2Sat_g = (co2Sat_mgL * params.volL) / 1000;
  out.meta.co2Init_mgL = co2Init_mgL;
  out.meta.co2Sat_mgL = co2Sat_mgL;

  const tempTauHours = clamp(Number(params.tempTauHours ?? 8), 1, 24);
  const tempTauDays = tempTauHours / 24;
  let tempSmooth = oxy.T;
  let tempSmoothMin = tempSmooth;
  let tempSmoothMax = tempSmooth;

  for(let i=0;i<n;i++){
    const day = i*dt;
    out.t[i] = day;

    const dielPhase = 2 * Math.PI * ((day + lightHour/24) % 1);
    const lightFactor = Math.max(0, Math.sin(dielPhase));
    const tempTarget = oxy.T + tempAmp * Math.sin(dielPhase);
    const tempBlend = clamp(tempTauDays > 1e-6 ? (dt / tempTauDays) : 1, 0, 1);
    tempSmooth = tempSmooth + (tempTarget - tempSmooth) * tempBlend;
    tempSmoothMin = Math.min(tempSmoothMin, tempSmooth);
    tempSmoothMax = Math.max(tempSmoothMax, tempSmooth);
    const tempF = clamp(Math.pow(Q10, (tempSmooth - 25.0)/10) * bioMult, 0.25, 6.0);
    const tempFNit = Math.pow(nitQ10, (tempSmooth - 25.0)/10);
    const heteroO2Rate = FISH_MODEL.o2_mg_g_day_base * Math.pow(FISH_MODEL.q10, (tempSmooth - FISH_MODEL.refTempC)/10);
    const rHet = rHet_base * tempF;
    const dHet = dHet_base * tempF;
    const rNit = rNit_base * tempFNit;
    const dNit = dNit_base * tempFNit;
    const rDen_grow = rDen_base * tempF;
    const dDen = dDen_base * tempF;

    // Apply feed events at this time slice
    const feedPellets = Math.max(0, feedPulse.pellets[i] || 0);
    const feedPowder_g = Math.max(0, feedPulse.powder[i] || 0);
    if(feedPellets > 0){
      const feedMass = feedPellets * pelletEachMass_g;
      pelFloat.carb += feedMass * FRACTIONS.carb;
      pelFloat.prot += feedMass * FRACTIONS.protein;
      pelFloat.fat += feedMass * FRACTIONS.fat;
      feedAddedC_g += feedMass;
      feedAddedN_g += feedMass * FRACTIONS.protein * CHEM.gN_per_g_protein;
    }
    if(feedPowder_g > 0){
      powBot.carb += feedPowder_g * FRACTIONS.carb;
      powBot.prot += feedPowder_g * FRACTIONS.protein;
      powBot.fat += feedPowder_g * FRACTIONS.fat;
      feedAddedC_g += feedPowder_g;
      feedAddedN_g += feedPowder_g * FRACTIONS.protein * CHEM.gN_per_g_protein;
    }

    // Apply pop events at this time slice
    while(evIdx < ev.length && ev[evIdx].day <= day + dt/2){
      const e = ev[evIdx];
      const popMass_asfed = e.pellets * pelletEachMass_g;
      const popComp = {
        carb: popMass_asfed * FRACTIONS.carb,
        prot: popMass_asfed * FRACTIONS.protein,
        fat:  popMass_asfed * FRACTIONS.fat
      };
      const avail = pelTotalComp();
      const availTot = avail.carb+avail.prot+avail.fat;
      const wantTot = popComp.carb+popComp.prot+popComp.fat;
      const scale = (availTot>0 && wantTot>0) ? Math.min(1.0, availTot/wantTot) : 0;
      if(scale>0){
        const capped = {carb: popComp.carb*scale, prot: popComp.prot*scale, fat: popComp.fat*scale};
        removeFromPellets(capped);
        addToPowder(capped);
      }
      evIdx++;
    }

    // Sinking
    const hz = sinkingHazard(day);
    for(const k of ["carb","prot","fat"]){
      const dM = Math.min(hz * pelFloat[k] * dt, pelFloat[k]);
      pelFloat[k] -= dM;
      pelBot[k]   += dM;
    }
    const resus = clamp((params.ripplePct/100) * 0.15 + (params.airFlow/10) * 0.02, 0, 0.25);
    for(const k of ["carb","prot","fat"]){
      const up = Math.min(resus * pelBot[k] * dt, pelBot[k]);
      pelBot[k] -= up;
      pelFloat[k] += up;
    }

    // Blend kinetics based on how much is in powder state
    const pelMassNow = pelFloat.carb+pelFloat.prot+pelFloat.fat + pelBot.carb+pelBot.prot+pelBot.fat;
    const powMassNow = powBot.carb+powBot.prot+powBot.fat;
    const wPow = (pelMassNow + powMassNow) > 0 ? (powMassNow/(pelMassNow+powMassNow)) : 0;

    // Blend oxidation coefficients and yields
    const k_ox = {
      carb: tempF * blend(k_ox_pel.carb, k_ox_pow.carb, wPow),
      prot: tempF * blend(k_ox_pel.prot, k_ox_pow.prot, wPow),
      fat:  tempF * blend(k_ox_pel.fat,  k_ox_pow.fat,  wPow)
    };
    const Y = {
      carb: blend(Y_pel.carb, Y_pow.carb, wPow),
      prot: blend(Y_pel.prot, Y_pow.prot, wPow),
      fat:  blend(Y_pel.fat,  Y_pow.fat,  wPow)
    };
    const k_endog = tempF * blend(k_endog_pel, k_endog_pow, wPow);
    const k_nit_base = {
      nh4: tempFNit * blend(k_nit_pel.nh4, k_nit_pow.nh4, wPow),
      no2: tempFNit * blend(k_nit_pel.no2, k_nit_pow.no2, wPow)
    };

    // Optionally slow nitrification at low DO (a simple Monod term).
    let nitO2Mult = 1.0;
    if(params.o2Limit === "on"){
      const K = Math.max(1e-6, params.kDoNit);
      nitO2Mult = DO / (K + DO);
    }
    const k_nit = { nh4: k_nit_base.nh4 * nitO2Mult, no2: k_nit_base.no2 * nitO2Mult };

    // Hydrolysis coefficients
    const k_h_p = {
      carb: tempF * k_h_pel.carb,
      prot: tempF * k_h_pel.prot,
      fat:  tempF * k_h_pel.fat
    };
    const k_h_w = {
      carb: tempF * k_h_pow.carb,
      prot: tempF * k_h_pow.prot,
      fat:  tempF * k_h_pow.fat
    };

    let hydroTot = 0;
    // Hydrolysis fluxes per component
    for(const k of ["carb","prot","fat"]){
      const hf = capFlux(fluxPellet(pelFloat[k], k_h_p[k], accessFloat), pelFloat[k]);
      const hb = capFlux(fluxPellet(pelBot[k],   k_h_p[k], accessBottom), pelBot[k]);
      const hw = capFlux(fluxPowder(powBot[k],   k_h_w[k]), powBot[k]);

      pelFloat[k] -= hf*dt;
      pelBot[k]   -= hb*dt;
      powBot[k]   -= hw*dt;

      const fast = (hf+hb+hw) * (1 - slowFrac) * dt;
      const slow = (hf+hb+hw) * slowFrac * dt;
      S[k] += fast;
      S_slow[k] += slow;
      hydroTot += (hf+hb+hw)*dt;
    }

    for(const k of ["carb","prot","fat"]){
      const rel = Math.min(S_slow[k], (0.08 * tempF) * S_slow[k] * dt);
      S_slow[k] -= rel;
      S[k] += rel;
    }

    // Mixing penalty when hydrolysis happens mostly in bottom pellets
    const hPelFloat = fluxPellet(pelFloat.carb,k_h_p.carb,accessFloat)+fluxPellet(pelFloat.prot,k_h_p.prot,accessFloat)+fluxPellet(pelFloat.fat,k_h_p.fat,accessFloat);
    const hPelBot   = fluxPellet(pelBot.carb,k_h_p.carb,accessBottom)+fluxPellet(pelBot.prot,k_h_p.prot,accessBottom)+fluxPellet(pelBot.fat,k_h_p.fat,accessBottom);
    const hPow      = fluxPowder(powBot.carb,k_h_w.carb)+fluxPowder(powBot.prot,k_h_w.prot)+fluxPowder(powBot.fat,k_h_w.fat);
    const denom = (hPelFloat+hPelBot+hPow) + 1e-12;
    const mixMult = (oxFloat*hPelFloat + oxBottom*hPelBot + 1.0*hPow) / denom;

    // Nutrient release from hydrolyzed food (macro/micro proxy)
    const macroAdd_g = (macroRelease * hydroTot * params.volL) / 1000;
    const microAdd_g = (microRelease * hydroTot * params.volL) / 1000;
    macro_g += macroAdd_g;
    micro_g += microAdd_g;
    out.audit.macro_release += macroAdd_g;
    out.audit.micro_release += microAdd_g;

    // Biomass growth + nutrient consumption
    phytoMass_g = Math.max(0, phytoAlgaeOpen_g + phytoAlgaeRefuge_g + phytoPlanktonOpen_g + phytoPlanktonRefuge_g + phytoPlants_g);
    let S_tot = S.carb + S.prot + S.fat;
    let nutrientPool = macro_g + micro_g;
    let inorgN_g = Math.max(0, NH4 + NO3);
    const co2Partition = estimateCarbonatePartitioning(tempSmooth, params.pH ?? 7.0, alkalinity_mgL, DIC_g, params.volL);
    CO2_free_g = co2Partition.co2Free_g;
    bufferCapacityMin = Math.min(bufferCapacityMin, co2Partition.bufferCapacity);
    bufferCapacityLast = co2Partition.bufferCapacity;
    co2FreeMin_mgL = Math.min(co2FreeMin_mgL, co2Partition.co2Free_mgL);
    co2FreeLast_mgL = co2Partition.co2Free_mgL;
    dicMin_mgL = Math.min(dicMin_mgL, co2Partition.dic_mgL);
    dicLast_mgL = co2Partition.dic_mgL;
    if(co2Partition.bufferCapacity < 0.15 && co2Partition.co2Free_mgL < 0.4){
      bufferDepletionHits++;
    }
    const co2Index = clamp(CO2_free_g / (CO2_free_g + co2HalfSat_g), 0, 1);

    const storeCapN = Math.max(0, phytoMass_g * phytoStoreNCapFrac);
    const storeCapP = Math.max(0, phytoMass_g * phytoStorePCapFrac);
    const storeCapTotal = storeCapN + storeCapP;
    const storeFillPct = storeCapTotal > 1e-9 ? clamp((phytoN_store_g + phytoP_store_g) / storeCapTotal, 0, 1) : 0;

    const uptakeN_potential = (FEED_PROFILE.modeling.macroUptake_mgL_per_g_photo_day * phytoMass_g * params.volL / 1000) * tempF * dt;
    const uptakeP_potential = (FEED_PROFILE.modeling.microUptake_mgL_per_g_photo_day * phytoMass_g * params.volL / 1000) * tempF * dt;
    const storeRoomN = Math.max(0, storeCapN - phytoN_store_g);
    const storeRoomP = Math.max(0, storeCapP - phytoP_store_g);
    const nAvailableExternal = macro_g + inorgN_g * 0.6;
    const uptakeN = Math.min(uptakeN_potential, nAvailableExternal, storeRoomN);
    const uptakeP = Math.min(uptakeP_potential, micro_g, storeRoomP);
    if(uptakeN > 0){
      const macroShare = nAvailableExternal > 0 ? (macro_g / nAvailableExternal) : 0;
      const fromMacro = Math.min(macro_g, uptakeN * macroShare);
      macro_g = Math.max(0, macro_g - fromMacro);
      const fromInorg = uptakeN - fromMacro;
      if(fromInorg > 0){
        const inTot = inorgN_g || 1;
        const takeNH4 = Math.min(NH4, fromInorg * (NH4 / inTot));
        const takeNO3 = Math.min(NO3, fromInorg * (NO3 / inTot));
        NH4 = Math.max(0, NH4 - takeNH4);
        NO3 = Math.max(0, NO3 - takeNO3);
      }
      phytoN_store_g += uptakeN;
      luxuryUptakeTotal += uptakeN;
      macroConsumed_g += fromMacro;
      out.audit.macro_uptake += fromMacro;
    }
    if(uptakeP > 0){
      micro_g = Math.max(0, micro_g - uptakeP);
      phytoP_store_g += uptakeP;
      luxuryUptakeTotal += uptakeP;
      microConsumed_g += uptakeP;
      out.audit.micro_uptake += uptakeP;
    }

    const nAvailTotal = macro_g + inorgN_g * 0.6 + phytoN_store_g;
    const pAvailTotal = micro_g + phytoP_store_g;
    const nIndex = clamp(nAvailTotal / (nAvailTotal + 0.35), 0, 1);
    const pIndex = clamp(pAvailTotal / (pAvailTotal + 0.18), 0, 1);
    const phytoNutrientIndex = Math.min(nIndex, pIndex);
    const storeCapFactor = clamp(storeFillPct / 0.6, 0, 1);

    const algaeMuMax = PHYTO_COMPARTMENTS.algae.mu_max_per_day * tempF * (0.4 + 0.6 * phytoNutrientIndex);
    const planktonMuMax = PHYTO_COMPARTMENTS.plankton.mu_max_per_day * tempF * (0.4 + 0.6 * phytoNutrientIndex);
    const plantsMuMax = PHYTO_COMPARTMENTS.plants.mu_max_per_day * tempF * (0.4 + 0.6 * phytoNutrientIndex);
    const algaeMuEff = algaeMuMax * lightFactor * co2Index * storeCapFactor;
    const planktonMuEff = planktonMuMax * lightFactor * co2Index * storeCapFactor;
    const plantsMuEff = plantsMuMax * lightFactor * co2Index * storeCapFactor;

    phytoStoreFillLast = storeFillPct;
    phytoMuMaxLast = phytoMass_g > 1e-9
      ? (algaeMuMax * phytoAlgae_g + planktonMuMax * phytoPlankton_g + plantsMuMax * phytoPlants_g) / phytoMass_g
      : 0;
    phytoMuEffLast = phytoMass_g > 1e-9
      ? (algaeMuEff * phytoAlgae_g + planktonMuEff * phytoPlankton_g + plantsMuEff * phytoPlants_g) / phytoMass_g
      : 0;
    if(lightFactor > 0.2){
      if(algaeMuEff < algaeMuMax * lightFactor * co2Index * 0.9) phytoMuCapHits++;
      if(planktonMuEff < planktonMuMax * lightFactor * co2Index * 0.9) phytoMuCapHits++;
      if(plantsMuEff < plantsMuMax * lightFactor * co2Index * 0.9) phytoMuCapHits++;
    }

    const algaeRescueFactor = phytoAlgae0 > 0 ? clamp(1 - (phytoAlgae_g / phytoAlgae0), 0, 1) : 0;
    const planktonRescueFactor = phytoPlankton0 > 0 ? clamp(1 - (phytoPlankton_g / phytoPlankton0), 0, 1) : 0;
    const plantsRescueFactor = phytoPlants0 > 0 ? clamp(1 - (phytoPlants_g / phytoPlants0), 0, 1) : 0;
    const algaeRecruit = phytoAlgae0 * phytoRecruitFrac * algaeRescueFactor * lightFactor * phytoNutrientIndex * co2Index * dt;
    const planktonRecruit = phytoPlankton0 * phytoRecruitFrac * planktonRescueFactor * lightFactor * phytoNutrientIndex * co2Index * dt;
    const plantsRecruit = phytoPlants0 * phytoRecruitFrac * plantsRescueFactor * lightFactor * phytoNutrientIndex * co2Index * dt;
    phytoRecruitTotal += algaeRecruit + planktonRecruit + plantsRecruit;

    let algaeGrowthRaw = phytoAlgae_g * algaeMuEff * dt + algaeRecruit;
    let planktonGrowthRaw = phytoPlankton_g * planktonMuEff * dt + planktonRecruit;
    let plantsGrowthRaw = phytoPlants_g * plantsMuEff * dt + plantsRecruit;

    const algaeReserveAdd = algaeGrowthRaw * PHYTO_COMPARTMENTS.algae.reserveFrac;
    const planktonReserveAdd = planktonGrowthRaw * PHYTO_COMPARTMENTS.plankton.reserveFrac;
    const plantsReserveAdd = plantsGrowthRaw * PHYTO_COMPARTMENTS.plants.reserveFrac;
    algaeGrowthRaw -= algaeReserveAdd;
    planktonGrowthRaw -= planktonReserveAdd;
    plantsGrowthRaw -= plantsReserveAdd;
    phytoAlgaeReserve_g += algaeReserveAdd;
    phytoPlanktonReserve_g += planktonReserveAdd;
    phytoPlantsReserve_g += plantsReserveAdd;
    phytoReserveBuilt += algaeReserveAdd + planktonReserveAdd + plantsReserveAdd;

    const algaeReserveCap = Math.max(0, phytoAlgae_g * PHYTO_COMPARTMENTS.algae.reserveCapFrac);
    const planktonReserveCap = Math.max(0, phytoPlankton_g * PHYTO_COMPARTMENTS.plankton.reserveCapFrac);
    const plantsReserveCap = Math.max(0, phytoPlants_g * PHYTO_COMPARTMENTS.plants.reserveCapFrac);
    const algaeReserveOverflow = Math.max(0, phytoAlgaeReserve_g - algaeReserveCap);
    const planktonReserveOverflow = Math.max(0, phytoPlanktonReserve_g - planktonReserveCap);
    const plantsReserveOverflow = Math.max(0, phytoPlantsReserve_g - plantsReserveCap);
    if(algaeReserveOverflow > 0){
      phytoAlgaeReserve_g = algaeReserveCap;
      algaeGrowthRaw += algaeReserveOverflow;
    }
    if(planktonReserveOverflow > 0){
      phytoPlanktonReserve_g = planktonReserveCap;
      planktonGrowthRaw += planktonReserveOverflow;
    }
    if(plantsReserveOverflow > 0){
      phytoPlantsReserve_g = plantsReserveCap;
      plantsGrowthRaw += plantsReserveOverflow;
    }

    const algaeNightPotential = phytoAlgae_g * algaeMuMax * PHYTO_COMPARTMENTS.algae.nightGrowthFrac * (1 - lightFactor) * co2Index * storeCapFactor * dt;
    const planktonNightPotential = phytoPlankton_g * planktonMuMax * PHYTO_COMPARTMENTS.plankton.nightGrowthFrac * (1 - lightFactor) * co2Index * storeCapFactor * dt;
    const plantsNightPotential = phytoPlants_g * plantsMuMax * PHYTO_COMPARTMENTS.plants.nightGrowthFrac * (1 - lightFactor) * co2Index * storeCapFactor * dt;
    const algaeReserveUsePlanned = Math.min(phytoAlgaeReserve_g, algaeNightPotential);
    const planktonReserveUsePlanned = Math.min(phytoPlanktonReserve_g, planktonNightPotential);
    const plantsReserveUsePlanned = Math.min(phytoPlantsReserve_g, plantsNightPotential);

    const phytoYield = 0.55;
    const algaePotential = algaeGrowthRaw + algaeReserveUsePlanned;
    const planktonPotential = planktonGrowthRaw + planktonReserveUsePlanned;
    const plantsPotential = plantsGrowthRaw + plantsReserveUsePlanned;
    const algaeRequired = algaePotential / phytoYield;
    const planktonRequired = planktonPotential / phytoYield;
    const plantsRequired = plantsPotential / phytoYield;
    const phytoRequiredTotal = algaeRequired + planktonRequired + plantsRequired;
    const nDemand = phytoRequiredTotal * phytoStoreNFrac;
    const pDemand = phytoRequiredTotal * phytoStorePFrac;
    const nutrientScale = Math.min(
      1,
      nAvailTotal / Math.max(1e-9, nDemand),
      pAvailTotal / Math.max(1e-9, pDemand)
    );

    const algaeConsumed = algaeRequired * nutrientScale;
    const planktonConsumed = planktonRequired * nutrientScale;
    const plantsConsumed = plantsRequired * nutrientScale;
    const algaeGrowth = algaeConsumed * phytoYield;
    const planktonGrowth = planktonConsumed * phytoYield;
    const plantsGrowth = plantsConsumed * phytoYield;

    const algaeReserveUseActual = clamp(algaeGrowth - algaeGrowthRaw, 0, algaeReserveUsePlanned);
    const planktonReserveUseActual = clamp(planktonGrowth - planktonGrowthRaw, 0, planktonReserveUsePlanned);
    const plantsReserveUseActual = clamp(plantsGrowth - plantsGrowthRaw, 0, plantsReserveUsePlanned);
    if(algaeReserveUseActual > 0){
      phytoAlgaeReserve_g = Math.max(0, phytoAlgaeReserve_g - algaeReserveUseActual);
      phytoReserveUsed += algaeReserveUseActual;
      phytoNightGrowthTotal += algaeReserveUseActual;
    }
    if(planktonReserveUseActual > 0){
      phytoPlanktonReserve_g = Math.max(0, phytoPlanktonReserve_g - planktonReserveUseActual);
      phytoReserveUsed += planktonReserveUseActual;
      phytoNightGrowthTotal += planktonReserveUseActual;
    }
    if(plantsReserveUseActual > 0){
      phytoPlantsReserve_g = Math.max(0, phytoPlantsReserve_g - plantsReserveUseActual);
      phytoReserveUsed += plantsReserveUseActual;
      phytoNightGrowthTotal += plantsReserveUseActual;
    }
    const algaeReserveUnused = algaeReserveUsePlanned - algaeReserveUseActual;
    const planktonReserveUnused = planktonReserveUsePlanned - planktonReserveUseActual;
    const plantsReserveUnused = plantsReserveUsePlanned - plantsReserveUseActual;
    if(algaeReserveUnused > 0) phytoAlgaeReserve_g += algaeReserveUnused;
    if(planktonReserveUnused > 0) phytoPlanktonReserve_g += planktonReserveUnused;
    if(plantsReserveUnused > 0) phytoPlantsReserve_g += plantsReserveUnused;
    if(nutrientScale < 1 && (phytoN_store_g + phytoP_store_g) <= 1e-8 && phytoRequiredTotal > 1e-9){
      phytoStoreDepleteHits++;
    }

    const algaeDecay = phytoAlgae_g * PHYTO_COMPARTMENTS.algae.decay_per_day * tempF * dt;
    const planktonDecay = phytoPlankton_g * PHYTO_COMPARTMENTS.plankton.decay_per_day * tempF * dt;
    const plantsDecay = phytoPlants_g * PHYTO_COMPARTMENTS.plants.decay_per_day * tempF * dt;

    const algaeTotal = phytoAlgaeOpen_g + phytoAlgaeRefuge_g;
    const planktonTotal = phytoPlanktonOpen_g + phytoPlanktonRefuge_g;
    const algaeRefugeShare = algaeTotal > 1e-9 ? (phytoAlgaeRefuge_g / algaeTotal) : phytoRefugiaFrac;
    const planktonRefugeShare = planktonTotal > 1e-9 ? (phytoPlanktonRefuge_g / planktonTotal) : phytoRefugiaFrac;
    phytoAlgaeRefuge_g = Math.max(0, phytoAlgaeRefuge_g + algaeGrowth * algaeRefugeShare - algaeDecay * algaeRefugeShare);
    phytoAlgaeOpen_g = Math.max(0, phytoAlgaeOpen_g + algaeGrowth * (1 - algaeRefugeShare) - algaeDecay * (1 - algaeRefugeShare));
    phytoPlanktonRefuge_g = Math.max(0, phytoPlanktonRefuge_g + planktonGrowth * planktonRefugeShare - planktonDecay * planktonRefugeShare);
    phytoPlanktonOpen_g = Math.max(0, phytoPlanktonOpen_g + planktonGrowth * (1 - planktonRefugeShare) - planktonDecay * (1 - planktonRefugeShare));
    phytoPlants_g = Math.max(0, phytoPlants_g + plantsGrowth - plantsDecay);

    phytoAlgae_g = phytoAlgaeOpen_g + phytoAlgaeRefuge_g;
    phytoPlankton_g = phytoPlanktonOpen_g + phytoPlanktonRefuge_g;
    phytoMass_g = phytoAlgae_g + phytoPlankton_g + phytoPlants_g;

    phytoGrowthTotal += algaeGrowth + planktonGrowth + plantsGrowth;
    phytoAlgaeGrowthTotal += algaeGrowth;
    phytoPlanktonGrowthTotal += planktonGrowth;
    phytoPlantsGrowthTotal += plantsGrowth;
    phytoConsumedTotal += algaeConsumed + planktonConsumed + plantsConsumed;
    phytoDecayTotal += algaeDecay + planktonDecay + plantsDecay;

    if(phytoAlgae_g <= 1e-9){
      phytoAlgaeExtinctHits++;
      if(!phytoAlgaeExtinctWarned && params.runMode !== 'uncertainty'){
        addWarning('Phyto algae biomass reached 0 g; algae compartment extinct.');
        phytoAlgaeExtinctWarned = true;
      }
    }
    if(phytoPlankton_g <= 1e-9){
      phytoPlanktonExtinctHits++;
      if(!phytoPlanktonExtinctWarned && params.runMode !== 'uncertainty'){
        addWarning('Phyto plankton biomass reached 0 g; plankton compartment extinct.');
        phytoPlanktonExtinctWarned = true;
      }
    }
    if(phytoPlants_g <= 1e-9){
      phytoPlantsExtinctHits++;
      if(!phytoPlantsExtinctWarned && params.runMode !== 'uncertainty'){
        addWarning('Phyto plants biomass reached 0 g; plant compartment extinct.');
        phytoPlantsExtinctWarned = true;
      }
    }
    if(phytoMass_g <= 1e-9){
      phytoExtinctHits++;
      if(!phytoExtinctWarned && params.runMode !== 'uncertainty'){
        addWarning('Phyto biomass reached 0 g; autotroph population extinct.');
        phytoExtinctWarned = true;
      }
    }

    if(!Number.isFinite(phytoAlgae_g)){
      addWarning('Phyto algae mass became non-finite; resetting to 0.');
      biomassNonFiniteHits++;
      phytoAlgaeNonFiniteHits++;
      phytoAlgae_g = 0;
      phytoAlgaeOpen_g = 0;
      phytoAlgaeRefuge_g = 0;
      phytoAlgaeReserve_g = 0;
    }
    if(!Number.isFinite(phytoPlankton_g)){
      addWarning('Phyto plankton mass became non-finite; resetting to 0.');
      biomassNonFiniteHits++;
      phytoPlanktonNonFiniteHits++;
      phytoPlankton_g = 0;
      phytoPlanktonOpen_g = 0;
      phytoPlanktonRefuge_g = 0;
      phytoPlanktonReserve_g = 0;
    }
    if(!Number.isFinite(phytoPlants_g)){
      addWarning('Phyto plants mass became non-finite; resetting to 0.');
      biomassNonFiniteHits++;
      phytoPlantsNonFiniteHits++;
      phytoPlants_g = 0;
      phytoPlantsReserve_g = 0;
    }
    phytoMass_g = phytoAlgae_g + phytoPlankton_g + phytoPlants_g;

    const phytoConsumedStep = algaeConsumed + planktonConsumed + plantsConsumed;
    if(phytoConsumedStep > 0){
      let nNeed = phytoConsumedStep * phytoStoreNFrac;
      let pNeed = phytoConsumedStep * phytoStorePFrac;
      const nExternalAvail = macro_g + inorgN_g * 0.6;
      const nFromExternal = Math.min(nNeed, nExternalAvail);
      if(nFromExternal > 0){
        const macroShare = nExternalAvail > 0 ? (macro_g / nExternalAvail) : 0;
        const fromMacro = Math.min(macro_g, nFromExternal * macroShare);
        macro_g = Math.max(0, macro_g - fromMacro);
        macroConsumed_g += fromMacro;
        out.audit.macro_uptake += fromMacro;
        const fromInorg = nFromExternal - fromMacro;
        if(fromInorg > 0){
          const inTot = inorgN_g || 1;
          const takeNH4 = Math.min(NH4, fromInorg * (NH4 / inTot));
          const takeNO3 = Math.min(NO3, fromInorg * (NO3 / inTot));
          NH4 = Math.max(0, NH4 - takeNH4);
          NO3 = Math.max(0, NO3 - takeNO3);
        }
        nNeed -= nFromExternal;
      }
      if(nNeed > 0){
        const takeStoreN = Math.min(phytoN_store_g, nNeed);
        phytoN_store_g = Math.max(0, phytoN_store_g - takeStoreN);
      }
      if(pNeed > 0){
        const fromMicro = Math.min(micro_g, pNeed);
        micro_g = Math.max(0, micro_g - fromMicro);
        microConsumed_g += fromMicro;
        out.audit.micro_uptake += fromMicro;
        pNeed -= fromMicro;
        if(pNeed > 0){
          const takeStoreP = Math.min(phytoP_store_g, pNeed);
          phytoP_store_g = Math.max(0, phytoP_store_g - takeStoreP);
        }
      }
    }
    if(phytoN_store_g < 0 || phytoP_store_g < 0 || !Number.isFinite(phytoN_store_g) || !Number.isFinite(phytoP_store_g)){
      phytoStoreNegativeHits++;
      phytoN_store_g = Math.max(0, Number.isFinite(phytoN_store_g) ? phytoN_store_g : 0);
      phytoP_store_g = Math.max(0, Number.isFinite(phytoP_store_g) ? phytoP_store_g : 0);
    }

    nutrientPool = macro_g + micro_g;
    inorgN_g = Math.max(0, NH4 + NO3);
    S_tot = S.carb + S.prot + S.fat;
    const grazableAlgae_g = Math.max(0, phytoAlgaeOpen_g);
    const grazablePlankton_g = Math.max(0, phytoPlanktonOpen_g);
    const grazablePhyto_g = grazableAlgae_g + grazablePlankton_g;
    const biofilmTarget = grazablePhyto_g / (grazablePhyto_g + biofilmGrazingHalfSat_g);
    const biofilmBlend = clamp(TROPHIC_MODEL.biofilm.lagDays > 1e-6 ? (dt / TROPHIC_MODEL.biofilm.lagDays) : 1, 0, 1);
    biofilmActivity = clamp(biofilmActivity + (biofilmTarget - biofilmActivity) * biofilmBlend, 0, 1);
    biofilmActivityMin = Math.min(biofilmActivityMin, biofilmActivity);
    if(biofilmTarget > 0.5 && biofilmActivity < 0.1){
      grazingLagCollapseHits++;
    }
    const grazingShield = grazablePhyto_g / (grazablePhyto_g + Math.max((phytoAlgae0 + phytoPlankton0) * 0.2, 0.5));
    grazingShieldMin = Math.min(grazingShieldMin, grazingShield);
    const grazingSatiation = 1 - Math.exp(-grazablePhyto_g / Math.max((phytoAlgae0 + phytoPlankton0) * 0.5, 1));
    const biofilmGrazeRate_g_day = biofilm_g * TROPHIC_MODEL.biofilm.grazingMax_g_g_day * biofilmActivity * grazingShield * grazingSatiation * tempF;
    const biofilmConsumed = Math.min(biofilmGrazeRate_g_day * dt, grazablePhyto_g);
    if(biofilmConsumed < (biofilmGrazeRate_g_day * dt) - 1e-9) grazingLimitedSteps++;
    laggedBiofilmConsumptionTotal += biofilmConsumed;
    const biofilmGrowth = biofilmConsumed * TROPHIC_MODEL.biofilm.yield * TROPHIC_MODEL.biofilm.assimEff;
    const biofilmDecay = biofilm_g * TROPHIC_MODEL.biofilm.decay_per_day * (1 - biofilmActivity) * dt;
    biofilm_g = Math.max(0, biofilm_g + biofilmGrowth - biofilmDecay);

    let algaeGrazed = 0;
    let planktonGrazed = 0;
    if(biofilmConsumed > 0){
      const algaeShare = grazablePhyto_g > 1e-9 ? (grazableAlgae_g / grazablePhyto_g) : 0;
      algaeGrazed = biofilmConsumed * algaeShare;
      planktonGrazed = biofilmConsumed - algaeGrazed;
      phytoAlgaeOpen_g = Math.max(0, phytoAlgaeOpen_g - algaeGrazed);
      phytoPlanktonOpen_g = Math.max(0, phytoPlanktonOpen_g - planktonGrazed);
      phytoGrazedTotal += biofilmConsumed;
      biofilmGrazedTotal += biofilmConsumed;
      out.audit.phyto_grazed += biofilmConsumed;
      out.audit.phyto_algae_grazed += algaeGrazed;
      out.audit.phyto_plankton_grazed += planktonGrazed;
      const biofilmWaste = Math.max(0, biofilmConsumed - biofilmGrowth);
      if(biofilmWaste > 0){
        S.carb += biofilmWaste * FRACTIONS.carb;
        S.prot += biofilmWaste * FRACTIONS.protein;
        S.fat  += biofilmWaste * FRACTIONS.fat;
        NH4 += biofilmWaste * FRACTIONS.protein * CHEM.gN_per_g_protein * 0.2;
        out.audit.biofilm_grazing_waste += biofilmWaste;
      }
    }

    if(biofilm_g <= 1e-9){
      biofilmExtinctHits++;
      if(!biofilmExtinctWarned && params.runMode !== 'uncertainty'){
        addWarning('Biofilm biomass reached 0 g; biofilm grazers extinct.');
        biofilmExtinctWarned = true;
      }
    }

    const predatorTarget = biofilm_g / (biofilm_g + predatorGrazingHalfSat_g);
    const predatorBlend = clamp(TROPHIC_MODEL.predator.lagDays > 1e-6 ? (dt / TROPHIC_MODEL.predator.lagDays) : 1, 0, 1);
    predatorActivity = clamp(predatorActivity + (predatorTarget - predatorActivity) * predatorBlend, 0, 1);
    predatorActivityMin = Math.min(predatorActivityMin, predatorActivity);
    if(predatorTarget > 0.5 && predatorActivity < 0.1){
      predatorLagCollapseHits++;
    }
    const predatorShield = biofilm_g / (biofilm_g + Math.max(biofilm0 * 0.2, 0.4));
    predatorShieldMin = Math.min(predatorShieldMin, predatorShield);
    const predatorSatiation = 1 - Math.exp(-biofilm_g / Math.max(biofilm0 * 0.5, 0.6));
    const predatorGrazeRate_g_day = predator_g * TROPHIC_MODEL.predator.grazingMax_g_g_day * predatorActivity * predatorShield * predatorSatiation * tempF;
    const predatorConsumed = Math.min(predatorGrazeRate_g_day * dt, biofilm_g);
    if(predatorConsumed < (predatorGrazeRate_g_day * dt) - 1e-9) predatorGrazingLimitedSteps++;
    laggedPredatorConsumptionTotal += predatorConsumed;
    biofilm_g = Math.max(0, biofilm_g - predatorConsumed);

    const predatorGrowth = predatorConsumed * TROPHIC_MODEL.predator.yield * TROPHIC_MODEL.predator.assimEff;
    const predatorDecay = predator_g * TROPHIC_MODEL.predator.decay_per_day * (1 - predatorActivity) * dt;
    predator_g = Math.max(0, predator_g + predatorGrowth - predatorDecay);

    if(predatorConsumed > 0){
      predatorGrazedTotal += predatorConsumed;
      out.audit.biofilm_grazed += predatorConsumed;
      out.audit.predator_grazed += predatorConsumed;
      const predatorWaste = Math.max(0, predatorConsumed - predatorGrowth);
      if(predatorWaste > 0){
        S.carb += predatorWaste * FRACTIONS.carb;
        S.prot += predatorWaste * FRACTIONS.protein;
        S.fat  += predatorWaste * FRACTIONS.fat;
        NH4 += predatorWaste * FRACTIONS.protein * CHEM.gN_per_g_protein * 0.2;
        out.audit.predator_grazing_waste += predatorWaste;
      }
    }

    if(predator_g <= 1e-9){
      predatorExtinctHits++;
      if(!predatorExtinctWarned && params.runMode !== 'uncertainty'){
        addWarning('Predator biomass reached 0 g; predator compartment extinct.');
        predatorExtinctWarned = true;
      }
    }

    heteroMass_g = biofilm_g + predator_g;
    heteroConsumedTotal += biofilmConsumed + predatorConsumed;
    heteroGrowthTotal += biofilmGrowth + predatorGrowth;
    if(heteroMass_g <= 1e-9){
      heteroExtinctHits++;
      if(!heteroExtinctWarned && params.runMode !== 'uncertainty'){
        addWarning('Heterotroph biomass reached 0 g; heterotroph population extinct.');
        heteroExtinctWarned = true;
      }
    }

    if(!Number.isFinite(biofilm_g)){
      addWarning('Biofilm mass became non-finite; resetting to 0.');
      biomassNonFiniteHits++;
      biofilmNonFiniteHits++;
      biofilm_g = 0;
    }
    if(!Number.isFinite(predator_g)){
      addWarning('Predator mass became non-finite; resetting to 0.');
      biomassNonFiniteHits++;
      predatorNonFiniteHits++;
      predator_g = 0;
    }
    heteroMass_g = biofilm_g + predator_g;

    if(heteroMass_g > heteroMass0 * 0.6){
      if(biofilm_g <= 1e-9) biofilmStableCollapseHits++;
      if(predator_g <= 1e-9) predatorStableCollapseHits++;
    }

    const algaeRefugeTarget = (phytoAlgaeOpen_g + phytoAlgaeRefuge_g) * phytoRefugiaFrac;
    const planktonRefugeTarget = (phytoPlanktonOpen_g + phytoPlanktonRefuge_g) * phytoRefugiaFrac;
    const algaeRefugeDelta_g_day = (algaeRefugeTarget - phytoAlgaeRefuge_g) * refugeExchangeRate;
    const planktonRefugeDelta_g_day = (planktonRefugeTarget - phytoPlanktonRefuge_g) * refugeExchangeRate;
    const algaeExchange_g = algaeRefugeDelta_g_day * dt;
    const planktonExchange_g = planktonRefugeDelta_g_day * dt;
    if(algaeExchange_g > 0){
      const move = Math.min(algaeExchange_g, phytoAlgaeOpen_g);
      phytoAlgaeOpen_g -= move;
      phytoAlgaeRefuge_g += move;
    }else if(algaeExchange_g < 0){
      const move = Math.min(-algaeExchange_g, phytoAlgaeRefuge_g);
      phytoAlgaeRefuge_g -= move;
      phytoAlgaeOpen_g += move;
    }
    if(planktonExchange_g > 0){
      const move = Math.min(planktonExchange_g, phytoPlanktonOpen_g);
      phytoPlanktonOpen_g -= move;
      phytoPlanktonRefuge_g += move;
    }else if(planktonExchange_g < 0){
      const move = Math.min(-planktonExchange_g, phytoPlanktonRefuge_g);
      phytoPlanktonRefuge_g -= move;
      phytoPlanktonOpen_g += move;
    }
    phytoAlgae_g = phytoAlgaeOpen_g + phytoAlgaeRefuge_g;
    phytoPlankton_g = phytoPlanktonOpen_g + phytoPlanktonRefuge_g;
    phytoMass_g = phytoAlgae_g + phytoPlankton_g + phytoPlants_g;
    const refugeTotal = phytoAlgaeRefuge_g + phytoPlanktonRefuge_g;
    const refugeTotalMass = (phytoAlgaeOpen_g + phytoAlgaeRefuge_g + phytoPlanktonOpen_g + phytoPlanktonRefuge_g);
    refugeExchangeLast = Math.abs(algaeRefugeDelta_g_day) + Math.abs(planktonRefugeDelta_g_day);
    refugeFractionLast = refugeTotalMass > 1e-9 ? (refugeTotal / refugeTotalMass) : 0;
    if(refugeFractionLast < 0.05) refugeEmptyHits++;
    if(refugeFractionLast > 0.6) refugeOverrunHits++;

    const phytoDecay = algaeDecay + planktonDecay + plantsDecay;
    const heteroDecay = biofilmDecay + predatorDecay;
    const phytoGrowthStep = algaeGrowth + planktonGrowth + plantsGrowth;
    const decayMass = heteroDecay + phytoDecay;
    if(decayMass > 0){
      const decayReturnMass = decayMass * 0.35;
      const decayMacro_g = (macroRelease * decayReturnMass * params.volL) / 1000;
      const decayMicro_g = (microRelease * decayReturnMass * params.volL) / 1000;
      macro_g += decayMacro_g;
      micro_g += decayMicro_g;
      out.audit.macro_release += decayMacro_g;
      out.audit.micro_release += decayMicro_g;
      S.carb += decayReturnMass * FRACTIONS.carb;
      S.prot += decayReturnMass * FRACTIONS.protein;
      S.fat  += decayReturnMass * FRACTIONS.fat;
      NH4 += decayReturnMass * FRACTIONS.protein * CHEM.gN_per_g_protein * 0.3;
    }

    const co2GrowthCons_g = phytoGrowthStep * PHOTO_MODEL.co2_per_g_growth;
    DIC_g = Math.max(0, DIC_g - co2GrowthCons_g);
    if(CO2_free_g <= 1e-9) co2ZeroHits++;
    co2Consumed_g += co2GrowthCons_g;

    // Oxidation of solubles
    const ox = {carb:0, prot:0, fat:0};
    for(const k of ["carb","prot","fat"]){
      const Ks_sub = 0.02;
      const fS = S[k] / (Ks_sub + S[k]);
      const fO2 = DO / (kDoHet + DO);
      const flux = k_ox[k] * Bhet * mixMult * fS * fO2 * S[k];
      ox[k] = Math.min(flux, S[k]/dt);
      S[k] -= ox[k]*dt;
    }

    // Oxygen demand (rates)
    const O2_carb = ox.carb * CHEM.O2_carb * (1 - Y.carb);
    const O2_prot = ox.prot * CHEM.O2_protein_C * (1 - Y.prot);
    const O2_fat  = ox.fat  * CHEM.O2_fat * (1 - Y.fat);

    // Biomass storage and endogenous respiration
    const COD_store = ox.carb*CHEM.O2_carb*Y.carb + ox.prot*CHEM.O2_protein_C*Y.prot + ox.fat*CHEM.O2_fat*Y.fat;
    const N_store   = ox.prot * CHEM.gN_per_g_protein * Y.prot;
    const NH4_prod  = ox.prot * CHEM.gN_per_g_protein * (1 - Y.prot);

    const endog = Math.min(k_endog * COD_bio, COD_bio/dt);
    const O2_endog = endog;
    const N_rel = (COD_bio > 1e-12) ? (N_bio / COD_bio) * endog : 0;

    COD_bio = COD_bio + COD_store*dt - endog*dt;
    const N_need = COD_store * CHEM.N_bio_per_COD;
    const N_assim = Math.min(NH4, Math.max(0, N_need - N_store) * dt);
    NH4 = NH4 - N_assim;
    N_bio   = N_bio   + N_store*dt + N_assim - N_rel*dt;

    // Nitrification (sequential)
    NH4 = NH4 + (NH4_prod + N_rel)*dt;

    const fNH4 = (kNH4_g > 0) ? (NH4 / (kNH4_g + NH4)) : 1.0;
    const fNO2 = (kNO2_g > 0) ? (NO2 / (kNO2_g + NO2)) : 1.0;

    const r1 = Math.min(Bnit * k_nit.nh4 * fNH4 * biofilmMult * NH4, NH4/dt); // g N/day
    NH4 = NH4 - r1*dt;
    NO2 = NO2 + r1*dt;

    const r2 = Math.min(Bnit * k_nit.no2 * fNO2 * biofilmMult * NO2, NO2/dt);
    NO2 = NO2 - r2*dt;
    NO3 = NO3 + r2*dt;

    const O2_nh4 = r1 * CHEM.O2_per_gN_NH4_to_NO2;
    const O2_no2 = r2 * CHEM.O2_per_gN_NO2_to_NO3;

    const fAnox = clamp(1 - DO/(kDoHet + DO), 0, 1);
    const rDen_flux = Math.min(Bden * kDenit * fAnox * NO3, NO3/dt);
    NO3 = NO3 - rDen_flux*dt;
    no3Denit_g += rDen_flux * dt;
    const COD_den = Math.min(COD_bio, rDen_flux * 2.5);
    COD_bio = Math.max(0, COD_bio - COD_den*dt);
    const CO2_den = COD_den;
    DIC_g += CO2_den * dt;
    out.audit.no3_to_n2 += rDen_flux * dt;
    out.audit.co2_from_denit += CO2_den * dt;

    const phytoResp_g_day = (PHOTO_MODEL.resp_mg_g_day * phytoMass_g / 1000) * (1 - lightFactor);
    const demand = O2_carb + O2_prot + O2_fat + O2_endog + O2_nh4 + O2_no2 + phytoResp_g_day;

    const CO2_from_ox = (O2_carb + O2_prot + O2_fat) * CHEM.CO2_per_gO2;
    const CO2_from_endog = O2_endog * CHEM.CO2_per_gO2;
    DIC_g += (CO2_from_ox + CO2_from_endog + phytoResp_g_day * CHEM.CO2_per_gO2) * dt;
    out.audit.co2_from_ox += CO2_from_ox * dt;
    out.audit.co2_from_endog += CO2_from_endog * dt;
    const co2PartitionLate = estimateCarbonatePartitioning(tempSmooth, params.pH ?? 7.0, alkalinity_mgL, DIC_g, params.volL);
    CO2_free_g = co2PartitionLate.co2Free_g;
    bufferCapacityMin = Math.min(bufferCapacityMin, co2PartitionLate.bufferCapacity);
    bufferCapacityLast = co2PartitionLate.bufferCapacity;
    co2FreeMin_mgL = Math.min(co2FreeMin_mgL, co2PartitionLate.co2Free_mgL);
    co2FreeLast_mgL = co2PartitionLate.co2Free_mgL;
    dicMin_mgL = Math.min(dicMin_mgL, co2PartitionLate.dic_mgL);
    dicLast_mgL = co2PartitionLate.dic_mgL;
    const co2Equil_mgL = co2Init_mgL;
    const co2SatDef_mgL = co2Equil_mgL - co2PartitionLate.co2Free_mgL;
    const kLaCO2 = oxy.kLa * 0.6;
    const co2AirFlux_g_day = (kLaCO2 * co2SatDef_mgL * params.volL) / 1000;
    const co2AirFlux_g = co2AirFlux_g_day * dt;
    DIC_g += co2AirFlux_g;
    if(co2AirFlux_g >= 0){
      co2AirIn_g += co2AirFlux_g;
      out.audit.co2_air_in += co2AirFlux_g;
    }else{
      const degas_g = Math.abs(co2AirFlux_g);
      co2AirOut_g += degas_g;
      out.audit.co2_air_out += degas_g;
    }
    if(co2PartitionLate.co2Free_g > co2Sat_g){
      const excessFree_g = co2PartitionLate.co2Free_g - co2Sat_g;
      const dicReduce = excessFree_g / Math.max(co2PartitionLate.alpha0, 1e-6);
      DIC_g = Math.max(0, DIC_g - dicReduce);
      co2DegasSteps++;
      co2Degassed_g += excessFree_g;
      out.audit.co2_degassed += excessFree_g;
    }

    out.audit.nh4_from_pro += NH4_prod * dt;
    out.audit.nh4_from_endog += N_rel * dt;
    out.audit.nh4_to_no2 += r1 * dt;
    out.audit.no2_to_no3 += r2 * dt;

    // DO dynamics (Euler)
    // supply_g_day = kLa*(C* - DO)*V
    const satDef = Math.max(0, (Cstar - DO));
    const supply_g_day = (kLa * satDef * params.volL) / 1000;
    const photoO2_g_day_peak = (PHOTO_MODEL.o2_mg_g_day_peak * phytoMass_g) / 1000;
    const plant_g_day = photoO2_g_day_peak * lightFactor;
    const heteroO2_g_day = (heteroMass_g * heteroO2Rate) / 1000;
    const dDO = ((supply_g_day + plant_g_day - demand - heteroO2_g_day) * 1000 / params.volL) * dt; // mg/L
    const nextDO = DO + dDO;
    if(nextDO > Cstar){
      const excess_mgL = nextDO - Cstar;
      const degas_g = (excess_mgL * params.volL) / 1000;
      oxygenDegassed_g += degas_g;
      out.audit.o2_degassed += degas_g;
      oxygenDegasSteps++;
      oxygenClampCount++;
    }
    DO = clamp(nextDO, 0, Cstar);

    // Record outputs
    out.rate.carb[i]  = O2_carb;
    out.rate.prot[i]  = O2_prot;
    out.rate.fat[i]   = O2_fat;
    out.rate.endog[i] = O2_endog;
    out.rate.nh4[i]   = O2_nh4;
    out.rate.no2[i]   = O2_no2;
    out.rate.hetero[i]  = heteroO2_g_day;
    out.rate.plant[i] = plant_g_day;
    out.rate.total[i] = demand + heteroO2_g_day;
    out.rate.supply[i]= supply_g_day + plant_g_day;
    out.meta.maxDemand = Math.max(out.meta.maxDemand, out.rate.total[i]);
    out.meta.maxSupply = Math.max(out.meta.maxSupply, out.rate.supply[i]);

    out.DO_mgL[i] = DO;
    out.DO_pct[i] = (Cstar>1e-9) ? (100*DO/Cstar) : 0;

    out.NH4_mgL[i] = (NH4*1000)/params.volL;
    out.NO2_mgL[i] = (NO2*1000)/params.volL;
    out.NO3_mgL[i] = (NO3*1000)/params.volL;

    const nh3Frac = nh3Fraction(params.pH ?? 7.0, oxy.T);
    const nh3AsN = out.NH4_mgL[i] * nh3Frac;
    out.NH3_mgL[i] = nh3AsN * CHEM.NH3_ion_per_N;

    const co2PhotoCons_g = plant_g_day * CHEM.CO2_per_gO2 * dt;
    DIC_g = Math.max(0, DIC_g - co2PhotoCons_g);
    if(CO2_free_g <= 1e-9) co2ZeroHits++;
    co2Consumed_g += co2PhotoCons_g;
    out.CO2_mgL[i] = (CO2_free_g*1000)/params.volL;
    out.DIC_mgL[i] = (DIC_g*1000)/params.volL;

    out.macro_mgL[i] = (macro_g*1000)/params.volL;
    out.micro_mgL[i] = (micro_g*1000)/params.volL;
    out.store_mgL[i] = ((phytoN_store_g + phytoP_store_g) * 1000) / params.volL;

    const nh4Disp = params.nUnits === 'asIon' ? out.NH4_mgL[i] * CHEM.NH4_ion_per_N : out.NH4_mgL[i];
    const no2Disp = params.nUnits === 'asIon' ? out.NO2_mgL[i] * CHEM.NO2_ion_per_N : out.NO2_mgL[i];
    const no3Disp = params.nUnits === 'asIon' ? out.NO3_mgL[i] * CHEM.NO3_ion_per_N : out.NO3_mgL[i];

    out.chem.nh4[i] = nh4Disp;
    out.chem.no2[i] = no2Disp;
    out.chem.no3[i] = no3Disp;
    out.chem.nh3[i] = out.NH3_mgL[i];
    out.chem.co2[i] = out.CO2_mgL[i];
    out.chem.dic[i] = out.DIC_mgL[i];
    out.chem.store[i] = out.store_mgL[i];
    out.chem.macro[i] = out.macro_mgL[i];
    out.chem.micro[i] = out.micro_mgL[i];

    const no3Prod_g = NO3 + no3Denit_g;
    const no3ProdDisp = params.nUnits === 'asIon' ? (no3Prod_g*1000/params.volL) * CHEM.NO3_ion_per_N : (no3Prod_g*1000/params.volL);
    out.chemProd.nh4[i] = nh4Disp;
    out.chemProd.no2[i] = no2Disp;
    out.chemProd.no3[i] = no3ProdDisp;
    out.chemProd.nh3[i] = out.NH3_mgL[i];
    out.chemProd.co2[i] = ((CO2_free_g + co2Consumed_g) * 1000) / params.volL;
    out.chemProd.dic[i] = ((DIC_g + co2Consumed_g) * 1000) / params.volL;
    out.chemProd.store[i] = out.store_mgL[i];
    out.chemProd.macro[i] = ((macro_g + macroConsumed_g) * 1000) / params.volL;
    out.chemProd.micro[i] = ((micro_g + microConsumed_g) * 1000) / params.volL;

    out.biomass.hetero_g[i] = heteroMass_g;
    out.biomass.phyto_g[i] = phytoMass_g;
    out.biomass.hetero_pct[i] = heteroMass0 > 0 ? ((heteroMass_g - heteroMass0) / heteroMass0) * 100 : 0;
    out.biomass.phyto_pct[i] = phytoMass0 > 0 ? ((phytoMass_g - phytoMass0) / phytoMass0) * 100 : 0;

    // Update activity states
    const fS = S_tot / (Ks + S_tot);
    const fN = NH4 / (Kn + NH4);

    Bhet = clamp(Bhet + (rHet*fS*(1-Bhet) - dHet*Bhet)*dt, 0.0, 1.0);
    Bnit = clamp(Bnit + (rNit*fN*(nitCap-Bnit) - dNit*Bnit)*dt, 0.0, nitCap);
    const fDen = NO3 / (Kn + NO3);
    Bden = clamp(Bden + (rDen_grow*fDen*(denitCap-Bden) - dDen*Bden)*dt, 0.0, denitCap);
  }

  // cumulative arrays
  out.cum = {};
  for(const k of Object.keys(out.rate)){
    const arr = out.rate[k];
    const cum = new Array(n).fill(0);
    let s = 0;
    for(let i=0;i<n;i++){ s += arr[i]*dt; cum[i] = s; }
    out.cum[k] = cum;
  }
  const chemCumResult = buildCumulativeSeries(out.chem, dt);
  out.chemCum = chemCumResult.series;
  out.meta.chemCumInfo = chemCumResult.info;
  const chemProdCumResult = buildCumulativeSeries(out.chemProd, dt);
  out.chemProdCum = chemProdCumResult.series;
  out.meta.chemProdCumInfo = chemProdCumResult.info;

  out.audit.n_balance_init = feedAddedN_g;
  out.audit.c_balance_init = feedAddedC_g + co2Init_free_g;
  out.audit.n_balance_end = NH4 + NO2 + NO3 + N_bio;
  out.audit.c_balance_end = DIC_g + COD_bio + S.carb + S.prot + S.fat + S_slow.carb + S_slow.prot + S_slow.fat
    + pelFloat.carb + pelFloat.prot + pelFloat.fat + pelBot.carb + pelBot.prot + pelBot.fat + powBot.carb + powBot.prot + powBot.fat;
  out.meta.feedEnd = pelFloat.carb + pelFloat.prot + pelFloat.fat + pelBot.carb + pelBot.prot + pelBot.fat + powBot.carb + powBot.prot + powBot.fat;
  out.meta.oxygenClampCount = oxygenClampCount;
  out.meta.oxygenDegasSteps = oxygenDegasSteps;
  out.meta.oxygenDegassed_g = oxygenDegassed_g;
  out.meta.heteroGrowthTotal = heteroGrowthTotal;
  out.meta.heteroConsumedTotal = heteroConsumedTotal;
  out.meta.phytoGrowthTotal = phytoGrowthTotal;
  out.meta.phytoAlgaeGrowthTotal = phytoAlgaeGrowthTotal;
  out.meta.phytoPlanktonGrowthTotal = phytoPlanktonGrowthTotal;
  out.meta.phytoPlantsGrowthTotal = phytoPlantsGrowthTotal;
  out.meta.phytoConsumedTotal = phytoConsumedTotal;
  out.meta.phytoDecayTotal = phytoDecayTotal;
  out.meta.phytoGrazedTotal = phytoGrazedTotal;
  out.meta.biofilmGrazedTotal = biofilmGrazedTotal;
  out.meta.predatorGrazedTotal = predatorGrazedTotal;
  out.meta.phytoNightGrowthTotal = phytoNightGrowthTotal;
  out.meta.phytoReserveBuilt = phytoReserveBuilt;
  out.meta.phytoReserveUsed = phytoReserveUsed;
  out.meta.phytoAlgae_g = phytoAlgae_g;
  out.meta.phytoPlankton_g = phytoPlankton_g;
  out.meta.phytoPlants_g = phytoPlants_g;
  out.meta.biofilm_g = biofilm_g;
  out.meta.predator_g = predator_g;
  out.meta.phytoStoreFillPct = phytoStoreFillLast;
  out.meta.phytoStoreN_g = phytoN_store_g;
  out.meta.phytoStoreP_g = phytoP_store_g;
  out.meta.luxuryUptakeTotal = luxuryUptakeTotal;
  out.meta.phytoStoreNegativeHits = phytoStoreNegativeHits;
  out.meta.phytoStoreDepleteHits = phytoStoreDepleteHits;
  out.meta.phytoMuMax = phytoMuMaxLast;
  out.meta.phytoMuEff = phytoMuEffLast;
  out.meta.phytoMuCapHits = phytoMuCapHits;
  out.meta.refugeFractionLast = refugeFractionLast;
  out.meta.refugeExchange_g_day = refugeExchangeLast;
  out.meta.refugeEmptyHits = refugeEmptyHits;
  out.meta.refugeOverrunHits = refugeOverrunHits;
  out.meta.biofilmActivityLast = biofilmActivity;
  out.meta.biofilmActivityMin = biofilmActivityMin;
  out.meta.predatorActivityLast = predatorActivity;
  out.meta.predatorActivityMin = predatorActivityMin;
  out.meta.laggedBiofilmConsumptionTotal = laggedBiofilmConsumptionTotal;
  out.meta.laggedPredatorConsumptionTotal = laggedPredatorConsumptionTotal;
  out.meta.grazingLagCollapseHits = grazingLagCollapseHits;
  out.meta.predatorLagCollapseHits = predatorLagCollapseHits;
  out.meta.biomassNonFiniteHits = biomassNonFiniteHits;
  out.meta.phytoAlgaeNonFiniteHits = phytoAlgaeNonFiniteHits;
  out.meta.phytoPlanktonNonFiniteHits = phytoPlanktonNonFiniteHits;
  out.meta.phytoPlantsNonFiniteHits = phytoPlantsNonFiniteHits;
  out.meta.biofilmNonFiniteHits = biofilmNonFiniteHits;
  out.meta.predatorNonFiniteHits = predatorNonFiniteHits;
  out.meta.phytoRecruitTotal = phytoRecruitTotal;
  out.meta.co2ZeroHits = co2ZeroHits;
  out.meta.co2DegasSteps = co2DegasSteps;
  out.meta.co2Degassed_g = co2Degassed_g;
  out.meta.grazingLimitedSteps = grazingLimitedSteps;
  out.meta.predatorGrazingLimitedSteps = predatorGrazingLimitedSteps;
  out.meta.grazingShieldMin = grazingShieldMin;
  out.meta.predatorShieldMin = predatorShieldMin;
  out.meta.biofilmStableCollapseHits = biofilmStableCollapseHits;
  out.meta.predatorStableCollapseHits = predatorStableCollapseHits;
  out.meta.co2AirIn_g = co2AirIn_g;
  out.meta.co2AirOut_g = co2AirOut_g;
  out.meta.alkalinity_mgL = alkalinity_mgL;
  out.meta.co2FreeMin_mgL = co2FreeMin_mgL;
  out.meta.co2FreeLast_mgL = co2FreeLast_mgL;
  out.meta.dicMin_mgL = dicMin_mgL;
  out.meta.dicLast_mgL = dicLast_mgL;
  out.meta.bufferCapacityMin = bufferCapacityMin;
  out.meta.bufferCapacityLast = bufferCapacityLast;
  out.meta.bufferDepletionHits = bufferDepletionHits;
  out.meta.tempTauHours = tempTauHours;
  out.meta.tempSmoothRange = {min: tempSmoothMin, max: tempSmoothMax, targetMin: oxy.T - tempAmp, targetMax: oxy.T + tempAmp};
  out.meta.feedPulse = {
    totalPellets: feedPulse.totalPellets,
    totalPowder_g: feedPulse.totalPowder,
    windowHours: feedWindowHours,
    windowSteps: feedPulse.windowSteps
  };
  out.meta.feedPlanStats = {
    entries: simFeedPlan.length,
    pellets: simFeedPlan.reduce((acc, f)=>acc + (Number(f.pellets) || 0), 0),
    powder_g: simFeedPlan.reduce((acc, f)=>acc + (Number(f.powder_g) || 0), 0)
  };
  out.meta.biomassExtinction = {
    heteroHits: heteroExtinctHits,
    phytoHits: phytoExtinctHits,
    phytoAlgaeHits: phytoAlgaeExtinctHits,
    phytoPlanktonHits: phytoPlanktonExtinctHits,
    phytoPlantsHits: phytoPlantsExtinctHits,
    biofilmHits: biofilmExtinctHits,
    predatorHits: predatorExtinctHits
  };
  if(feedAddedN_g > 0 && Math.abs(out.audit.n_balance_end - feedAddedN_g)/feedAddedN_g > 0.15){
    addWarning('Nitrogen balance drift exceeds 15% ‚Äî check kinetics or timestep.');
  }
  if(feedAddedC_g > 0 && Math.abs(out.audit.c_balance_end - feedAddedC_g)/feedAddedC_g > 0.25){
    addWarning('Carbon balance drift exceeds 25% ‚Äî check hydrolysis/CO2 terms.');
  }
  if(phytoStoreNegativeHits > 0){
    addWarning(`Phyto nutrient stores went negative ${phytoStoreNegativeHits} times; values were clamped to 0.`);
  }
  if(phytoStoreDepleteHits > 0 && params.runMode !== 'uncertainty'){
    addWarning(`Phyto stores depleted while growth demand persisted for ${phytoStoreDepleteHits} steps.`);
  }
  if(refugeEmptyHits > 0 && params.runMode !== 'uncertainty'){
    addWarning(`Refuge compartment emptied for ${refugeEmptyHits} steps; grazing protection was lost.`);
  }
  if(refugeOverrunHits > 0 && params.runMode !== 'uncertainty'){
    addWarning(`Refuge compartment overfilled for ${refugeOverrunHits} steps; open-water grazing access was limited.`);
  }
  if(grazingLagCollapseHits > 0 && params.runMode !== 'uncertainty'){
    addWarning(`Grazer activity lagged behind prey for ${grazingLagCollapseHits} steps; expect delayed grazing response.`);
  }
  if(predatorLagCollapseHits > 0 && params.runMode !== 'uncertainty'){
    addWarning(`Predator response lagged behind biofilm for ${predatorLagCollapseHits} steps; predator buildup may be delayed.`);
  }
  if(biofilmStableCollapseHits > 0 && params.runMode !== 'uncertainty'){
    addWarning(`Biofilm collapsed for ${biofilmStableCollapseHits} steps while total heterotroph mass stayed elevated.`);
  }
  if(predatorStableCollapseHits > 0 && params.runMode !== 'uncertainty'){
    addWarning(`Predator collapsed for ${predatorStableCollapseHits} steps while total heterotroph mass stayed elevated.`);
  }
  if(phytoMuCapHits > 0 && params.runMode !== 'uncertainty'){
    addWarning(`Effective phyto growth was capped by nutrients/stores in ${phytoMuCapHits} steps.`);
  }
  if(biomassNonFiniteHits > 0){
    addWarning(`Biomass values became non-finite ${biomassNonFiniteHits} times; clamped to 0.`);
  }
  if(!Number.isFinite(bufferCapacityMin)){
    addWarning('Buffer capacity became non-finite; check carbonate partitioning math.');
  }
  if(bufferDepletionHits > 0 && params.runMode !== 'uncertainty'){
    addWarning(`Carbonate buffer depleted in ${bufferDepletionHits} steps; free CO‚ÇÇ fell while alkalinity was low.`);
  }

  return out;
}
/* =========================================================
   Uncertainty mode (Monte Carlo)
========================================================= */

// Small PRNG so ‚Äúseed‚Äù is reproducible across browsers.
function mulberry32(seed){
  let a = seed >>> 0;
  return function(){
    a |= 0; a = (a + 0x6D2B79F5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function randn(rng){
  // Box‚ÄìMuller
  let u = 0, v = 0;
  while(u === 0) u = rng();
  while(v === 0) v = rng();
  return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}

function sampleLogNormalMean1(rng, cv){
  // lognormal with mean=1 and desired coefficient of variation
  const sigma = Math.sqrt(Math.log(1 + cv*cv));
  const mu = -0.5 * sigma * sigma;
  return Math.exp(mu + sigma * randn(rng));
}

function bandToQuantiles(bandPreset){
  if(bandPreset === '25-75') return {qLo:0.25, qHi:0.75};
  if(bandPreset === '5-95')  return {qLo:0.05, qHi:0.95};
  return {qLo:0.10, qHi:0.90}; // default 10‚Äì90
}

function profileForLevel(level){
  // These are ‚Äúpriors‚Äù: intentionally conservative. With calibration, shrink these.
  if(level === 'tight'){
    return {cvFlow:0.07, cvSote:0.12, cvSurf:0.18, cvBio:0.18, sdTemp:0.35, sdTight:0.10, cvInit:0.06};
  }
  if(level === 'wide'){
    return {cvFlow:0.25, cvSote:0.55, cvSurf:0.70, cvBio:0.70, sdTemp:1.20, sdTight:0.35, cvInit:0.18};
  }
  return {cvFlow:0.14, cvSote:0.30, cvSurf:0.35, cvBio:0.35, sdTemp:0.70, sdTight:0.20, cvInit:0.10}; // typical
}

function meanDeliveryFactor(diffType){
  // Rated pump flow is often higher than delivered flow once you add depth + diffuser backpressure.
  // This is a gentle, realism-biased default. Uncertainty adds noise around it.
  if(diffType === 'wood') return 0.65;
  if(diffType === 'microbubble') return 0.70;
  if(diffType === 'airstone_fine') return 0.80;
  return 0.90; // airstone_med or custom
}

function quantileFromSorted(sorted, q){
  if(sorted.length === 0) return NaN;
  const x = q * (sorted.length - 1);
  const i0 = Math.floor(x);
  const i1 = Math.min(sorted.length - 1, i0 + 1);
  const t = x - i0;
  return sorted[i0] * (1 - t) + sorted[i1] * t;
}

function scalarStats(values, qLo, qHi){
  const arr = values.slice().sort((a,b)=>a-b);
  return {
    lo: quantileFromSorted(arr, qLo),
    mid: quantileFromSorted(arr, 0.5),
    hi: quantileFromSorted(arr, qHi)
  };
}

function runMonteCarlo(baseParams){
  const runs = clamp(Math.round(baseParams.mcRuns || 0), 10, 5000);
  const {qLo, qHi} = bandToQuantiles(baseParams.bandPreset);
  const prof = profileForLevel(baseParams.uncLevel);
  const rng = mulberry32((Number.isFinite(baseParams.seed) ? baseParams.seed : 12345) | 0);

  // Keep time grid consistent for all runs by using base dt (as implemented inside runSimulation).
  // (runSimulation derives dt only from days.)
  const baseSim = runSimulation(baseParams);
  const n = baseSim.t.length;

  // Store per-run arrays we care about
  const DO_runs = new Array(runs);
  const rate_runs = Object.fromEntries(RATE_SERIES.map(s=>[s.key, new Array(runs)]));
  const cum_runs = new Array(runs);
  const chem_runs = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, new Array(runs)]));
  const chem_prod_runs = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, new Array(runs)]));
  const chem_cum_runs = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, new Array(runs)]));
  const bio_runs = {
    hetero_g: new Array(runs),
    phyto_g: new Array(runs),
    hetero_pct: new Array(runs),
    phyto_pct: new Array(runs)
  };

  // Per-run scalars
  const minDO = new Array(runs);
  const minDO_day = new Array(runs);
  const under2 = new Array(runs);
  const under1 = new Array(runs);
  const deficitArea = new Array(runs);
  const nh4pk = new Array(runs);
  const no2pk = new Array(runs);
  const no3pk = new Array(runs);
  const nh3pk = new Array(runs);
  const co2pk = new Array(runs);
  const macroPk = new Array(runs);
  const microPk = new Array(runs);
  const storeMin = new Array(runs);
  const otrMax = new Array(runs);
  const kLa = new Array(runs);
  const Cstar = new Array(runs);
  const effFlow = new Array(runs);

  for(let r=0;r<runs;r++){
    const p = JSON.parse(JSON.stringify(baseParams)); // cheap clone; fine at these sizes

    // Sample uncertainties around the base choices
    if(baseParams.u && baseParams.u.temp){
      p.Tnow = p.Tnow + randn(rng) * prof.sdTemp;
    }

    if(baseParams.u && baseParams.u.initDO){
      p.doInitPct = clamp(p.doInitPct * sampleLogNormalMean1(rng, prof.cvInit), 10, 150);
    }

    if(baseParams.u && baseParams.u.tight){
      p.tight = clamp(p.tight + randn(rng) * prof.sdTight, 0, 1);
    }

    // Delivered flow: treat user-entered flow as ‚Äúrated-ish‚Äù, then sample delivery factor.
    if(baseParams.u && baseParams.u.air){
      const mean = meanDeliveryFactor(p.diffType);
      const mult = sampleLogNormalMean1(rng, prof.cvFlow);
      p.airFlow = clamp(p.airFlow * mean * mult, 0.05, 50);
      effFlow[r] = p.airFlow;
    }else{
      effFlow[r] = p.airFlow;
    }

    if(baseParams.u && baseParams.u.diff){
      p.sotePerM = clamp(p.sotePerM * sampleLogNormalMean1(rng, prof.cvSote), 0.1, 25);
    }

    if(baseParams.u && baseParams.u.surf){
      const m = sampleLogNormalMean1(rng, prof.cvSurf);
      const m2 = sampleLogNormalMean1(rng, prof.cvSurf * 0.35);
      p.kCalm = clamp(p.kCalm * m, 0.01, 6.0);
      p.kRipple = clamp(p.kRipple * m * m2, 0.01, 10.0);
    }

    if(baseParams.u && baseParams.u.bio){
      p.bioMult = clamp(sampleLogNormalMean1(rng, prof.cvBio), 0.1, 6.0);
    }else{
      p.bioMult = 1.0;
    }

    const sim = runSimulation(p);
    DO_runs[r]  = sim.DO_mgL;
    for(const s of RATE_SERIES){
      rate_runs[s.key][r] = sim.rate[s.key];
    }
    cum_runs[r] = sim.cum.total;
    for(const s of CHEM_SERIES){
      chem_runs[s.key][r] = sim.chem[s.key];
      chem_prod_runs[s.key][r] = sim.chemProd[s.key];
      chem_cum_runs[s.key][r] = sim.chemProdCum[s.key];
    }
    bio_runs.hetero_g[r] = sim.biomass.hetero_g;
    bio_runs.phyto_g[r] = sim.biomass.phyto_g;
    bio_runs.hetero_pct[r] = sim.biomass.hetero_pct;
    bio_runs.phyto_pct[r] = sim.biomass.phyto_pct;

    // scalars
    let dmin = Infinity, dminDay = 0;
    let tU2 = 0, tU1 = 0;
    let defA = 0;
    for(let i=0;i<n;i++){
      const d = sim.DO_mgL[i];
      if(d < dmin){ dmin = d; dminDay = sim.t[i]; }
      if(d < 2.0) tU2 += sim.meta.dt;
      if(d < 1.0) tU1 += sim.meta.dt;
      const def = sim.rate.total[i] - sim.rate.supply[i];
      if(def > 0) defA += def * sim.meta.dt; // g/day * day = g
    }
    minDO[r] = dmin;
    minDO_day[r] = dminDay;
    under2[r] = tU2;
    under1[r] = tU1;
    deficitArea[r] = defA;

    let nh = 0, n2 = 0, n3 = 0, nh3 = 0, co2 = 0, mA = 0, mI = 0;
    let storeFloor = Infinity;
    for(let i=0;i<sim.NH4_mgL.length;i++) if(sim.NH4_mgL[i] > nh) nh = sim.NH4_mgL[i];
    for(let i=0;i<sim.NO2_mgL.length;i++) if(sim.NO2_mgL[i] > n2) n2 = sim.NO2_mgL[i];
    for(let i=0;i<sim.NO3_mgL.length;i++) if(sim.NO3_mgL[i] > n3) n3 = sim.NO3_mgL[i];
    for(let i=0;i<sim.NH3_mgL.length;i++) if(sim.NH3_mgL[i] > nh3) nh3 = sim.NH3_mgL[i];
    for(let i=0;i<sim.CO2_mgL.length;i++) if(sim.CO2_mgL[i] > co2) co2 = sim.CO2_mgL[i];
    for(let i=0;i<sim.macro_mgL.length;i++) if(sim.macro_mgL[i] > mA) mA = sim.macro_mgL[i];
    for(let i=0;i<sim.micro_mgL.length;i++) if(sim.micro_mgL[i] > mI) mI = sim.micro_mgL[i];
    for(let i=0;i<sim.store_mgL.length;i++) if(sim.store_mgL[i] < storeFloor) storeFloor = sim.store_mgL[i];
    nh4pk[r] = nh;
    no2pk[r] = n2;
    no3pk[r] = n3;
    nh3pk[r] = nh3;
    co2pk[r] = co2;
    macroPk[r] = mA;
    microPk[r] = mI;
    storeMin[r] = Number.isFinite(storeFloor) ? storeFloor : 0;

    otrMax[r] = sim.meta.oxy.OTR_max;
    kLa[r] = sim.meta.oxy.kLa;
    Cstar[r] = sim.meta.oxy.Cstar;
  }

  // Quantile arrays (time series)
  const qDO = {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)};
  const qRate = Object.fromEntries(RATE_SERIES.map(s=>[s.key, {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}]));
  const qCum= {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)};
  const qChem = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}]));
  const qChemProd = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}]));
  const qChemCum = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}]));
  const qBio = {
    hetero_g: {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)},
    phyto_g: {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}
  };
  const qBioPct = {
    hetero_pct: {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)},
    phyto_pct: {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}
  };

  const tmp = new Array(runs);

  function fillQ(srcRuns, out){
    for(let i=0;i<n;i++){
      for(let r=0;r<runs;r++) tmp[r] = srcRuns[r][i];
      tmp.sort((a,b)=>a-b);
      out.lo[i]  = quantileFromSorted(tmp, qLo);
      out.mid[i] = quantileFromSorted(tmp, 0.5);
      out.hi[i]  = quantileFromSorted(tmp, qHi);
    }
  }

  fillQ(DO_runs, qDO);
  for(const s of RATE_SERIES){
    fillQ(rate_runs[s.key], qRate[s.key]);
  }
  fillQ(cum_runs, qCum);
  for(const s of CHEM_SERIES){
    fillQ(chem_runs[s.key], qChem[s.key]);
    fillQ(chem_prod_runs[s.key], qChemProd[s.key]);
    fillQ(chem_cum_runs[s.key], qChemCum[s.key]);
  }
  fillQ(bio_runs.hetero_g, qBio.hetero_g);
  fillQ(bio_runs.phyto_g, qBio.phyto_g);
  fillQ(bio_runs.hetero_pct, qBioPct.hetero_pct);
  fillQ(bio_runs.phyto_pct, qBioPct.phyto_pct);

  // Scalar bands
  const sMinDO = scalarStats(minDO, qLo, qHi);
  const sMinDODay = scalarStats(minDO_day, qLo, qHi);
  const sDefA  = scalarStats(deficitArea, qLo, qHi);
  const sNH4   = scalarStats(nh4pk, qLo, qHi);
  const sNO2   = scalarStats(no2pk, qLo, qHi);
  const sNO3   = scalarStats(no3pk, qLo, qHi);
  const sNH3   = scalarStats(nh3pk, qLo, qHi);
  const sCO2   = scalarStats(co2pk, qLo, qHi);
  const sMacro = scalarStats(macroPk, qLo, qHi);
  const sMicro = scalarStats(microPk, qLo, qHi);
  const sStoreMin = scalarStats(storeMin, qLo, qHi);
  const sOTR   = scalarStats(otrMax, qLo, qHi);
  const sKLA   = scalarStats(kLa, qLo, qHi);
  const sCstar = scalarStats(Cstar, qLo, qHi);

  // Probabilities (based on min DO)
  let pU2 = 0, pU1 = 0;
  for(let r=0;r<runs;r++){
    if(minDO[r] < 2.0) pU2++;
    if(minDO[r] < 1.0) pU1++;
  }
  pU2 /= runs; pU1 /= runs;

  return {
    baseSim,
    q: {
      DO:qDO,
      rateBands:qRate,
      rateTotal:qRate.total,
      rateSupply:qRate.supply,
      cumTotal:qCum,
      chemBands:qChem,
      chemProdBands:qChemProd,
      chemCumBands:qChemCum,
      bioBands:qBio,
      bioPctBands:qBioPct
    },
    scalars: {
      minDO:sMinDO,
      minDO_day:sMinDODay,
      deficitArea:sDefA,
      nh4pk:sNH4,
      no2pk:sNO2,
      no3pk:sNO3,
      nh3pk:sNH3,
      co2pk:sCO2,
      macroPk:sMacro,
      microPk:sMicro,
      storeMin:sStoreMin,
      otrMax:sOTR,
      kLa:sKLA,
      Cstar:sCstar,
      runs
    },
    probs: {anyUnder2:pU2, anyUnder1:pU1}
  };
}


/* =========================================================
   Plotting (canvas)
========================================================= */


// ---- Chart scaling helpers (avoid ‚Äúmystery math‚Äù, just readable axes) ----
// niceTop(yMax): round the plot ceiling to 1/2/5 * 10^n
function niceTop(max){
  max = Math.max(0, max);
  if(max === 0) return 1;
  const p = Math.pow(10, Math.floor(Math.log10(max)));
  const n = max / p;
  let top;
  if(n <= 1) top = 1;
  else if(n <= 2) top = 2;
  else if(n <= 5) top = 5;
  else top = 10;
  return top * p;
}
// niceStep(yTop): choose a ‚Äúpleasant‚Äù grid step for ~4‚Äì6 lines
function niceStep(top){
  top = Math.max(0, top);
  if(top === 0) return 1;
  const raw = top / 5;
  const p = Math.pow(10, Math.floor(Math.log10(raw)));
  const n = raw / p;
  let step;
  if(n < 1.5) step = 1 * p;
  else if(n < 3) step = 2 * p;
  else if(n < 7) step = 5 * p;
  else step = 10 * p;
  return step;
}

// niceXStep(xMax): choose a pleasant x-grid step (days) for ~5‚Äì7 vertical lines.
function niceXStep(xMax){
  xMax = Math.max(1e-9, xMax);
  const targetLines = 6;
  const raw = xMax / targetLines;
  const p = Math.pow(10, Math.floor(Math.log10(raw)));
  const n = raw / p;
  let step;
  if(n < 1.5) step = 1 * p;
  else if(n < 3) step = 2 * p;
  else if(n < 7) step = 5 * p;
  else step = 10 * p;
  // Avoid ‚Äú0‚Äù step and keep labels sensible for short runs
  if(step <= 0) step = xMax;
  // If the run is very short, allow half-day ticks
  if(xMax <= 5 && step > 1) step = 1;
  if(xMax <= 2 && step > 0.5) step = 0.5;
  return step;
}

function drawPlot(canvas, tArr, seriesDict, opts={}){
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const m = {l:56*devicePixelRatio, r:56*devicePixelRatio, t:30*devicePixelRatio, b:34*devicePixelRatio};
  const pw = w - m.l - m.r;
  const ph = h - m.t - m.b;

  const xMax = tArr[tArr.length-1] || 1;

  const seriesList = opts.series || RATE_SERIES;
  const visibleMap = opts.visible || visibleRate;

  // y max from visible series + optional bands
  let yMax = 0;
  for(const s of seriesList){
    if(!visibleMap[s.key]) continue;
    const arr = seriesDict[s.key];
    if(arr) for(const v of arr) if(v>yMax) yMax=v;
  }
  if(opts.bands){
    for(const key of Object.keys(opts.bands)){
      if(visibleMap[key] === false) continue;
      const b = opts.bands[key];
      if(b && b.hi){
        for(let i=0;i<b.hi.length;i++){
          const v = b.hi[i];
          if(v>yMax) yMax=v;
        }
      }
    }
  }
  yMax = Math.max(0.0001, yMax);
  const yTop = opts.fitYMax ? yMax : niceTop(yMax);
  const yStep = niceStep(yTop);
  const fmtAxis = (val)=>{
    const abs = Math.abs(val);
    if(abs >= 100) return val.toFixed(0);
    if(abs >= 10) return val.toFixed(1);
    if(abs >= 1) return val.toFixed(2);
    if(abs >= 0.1) return val.toFixed(3);
    if(abs >= 0.01) return val.toFixed(4);
    if(abs >= 0.001) return val.toFixed(5);
    return val.toFixed(6);
  };

  // frame
  ctx.strokeStyle = 'rgba(231,236,255,0.18)';
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.strokeRect(m.l, m.t, pw, ph);

  // grid
  ctx.strokeStyle = 'rgba(231,236,255,0.06)';
  ctx.lineWidth = 1*devicePixelRatio;
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
  }
  const xStep = niceXStep(xMax);
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.beginPath();
    ctx.moveTo(px, m.t);
    ctx.lineTo(px, m.t+ph);
    ctx.stroke();
  }

  // axis labels
  ctx.fillStyle = 'rgba(231,236,255,0.75)';
  ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    ctx.fillText(fmtAxis(y), m.l-8, py);
  }
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.fillStyle = 'rgba(231,236,255,0.70)';
    const xLbl = (xStep < 1) ? x.toFixed(1) : String(Math.round(x));

        ctx.fillText(xLbl, px, m.t+ph+10);
  }

  // title
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillStyle = 'rgba(231,236,255,0.9)';
  ctx.font = `13px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
  ctx.fillText(opts.title || '', m.l, 10);

  // helper: band fill
  const drawBand = (lo, hi, alpha, color)=>{
    if(!lo || !hi) return;
    const drawPath = ()=>{
      ctx.beginPath();
      for(let i=0;i<tArr.length;i++){
        const x = m.l + (tArr[i]/xMax)*pw;
        const y = m.t + ph - (hi[i]/yTop)*ph;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      for(let i=tArr.length-1;i>=0;i--){
        const x = m.l + (tArr[i]/xMax)*pw;
        const y = m.t + ph - (lo[i]/yTop)*ph;
        ctx.lineTo(x,y);
      }
      ctx.closePath();
    };
    const bandAlpha = alpha ?? 0.16;
    ctx.save();
    ctx.globalAlpha = bandAlpha;
    ctx.fillStyle = color;
    drawPath();
    ctx.fill();
    if(opts.bandPattern){
      const size = Math.max(6, Math.round(10 * devicePixelRatio));
      const pat = document.createElement('canvas');
      pat.width = size;
      pat.height = size;
      const pctx = pat.getContext('2d');
      pctx.strokeStyle = color;
      pctx.globalAlpha = 0.35;
      pctx.lineWidth = Math.max(1, Math.round(1 * devicePixelRatio));
      pctx.beginPath();
      pctx.moveTo(0, size);
      pctx.lineTo(size, 0);
      pctx.stroke();
      pctx.beginPath();
      pctx.moveTo(-size * 0.25, size);
      pctx.lineTo(size, -size * 0.25);
      pctx.stroke();
      ctx.globalAlpha = Math.min(0.4, bandAlpha + 0.08);
      ctx.fillStyle = ctx.createPattern(pat, 'repeat');
      drawPath();
      ctx.fill();
    }
    ctx.restore();
  };

  // draw bands first (so lines sit on top)
  if(opts.bands){
    for(const [key,b] of Object.entries(opts.bands)){
      if(visibleMap[key] === false) continue;
      let color = 'rgba(255,140,171,1)'; // demand-ish
      if(key === 'supply') color = 'rgba(97,230,180,1)';
      if(key === 'total')  color = 'rgba(255,140,171,1)';
      if(opts.bandColors && opts.bandColors[key]) color = opts.bandColors[key];
      drawBand(b.lo, b.hi, b.alpha ?? 0.14, color);
    }
  }

  // series (base lines)
  for(const s of seriesList){
    if(!visibleMap[s.key]) continue;
    const arr = seriesDict[s.key];
    if(!arr) continue;

    // If we have uncertainty bands for this series, draw base line more subtly to avoid clutter
    const hasBand = opts.bands && opts.bands[s.key] && opts.bands[s.key].mid;
    if(hasBand){
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.setLineDash([3*devicePixelRatio, 3*devicePixelRatio]);
    }else{
      ctx.setLineDash([]);
    }

    ctx.lineWidth = (s.bold ? 2.6 : 1) * devicePixelRatio;
    ctx.strokeStyle = s.color;
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (arr[i]/yTop)*ph;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // median lines from bands (draw on top)
  if(opts.bands){
    for(const [key,b] of Object.entries(opts.bands)){
      if(visibleMap[key] === false) continue;
      if(!b.mid) continue;
      let color = 'rgba(255,140,171,1)';
      if(key === 'supply') color = 'rgba(97,230,180,1)';
      if(key === 'total')  color = 'rgba(255,140,171,1)';
      if(opts.bandColors && opts.bandColors[key]) color = opts.bandColors[key];
      ctx.save();
      ctx.lineWidth = 2.2 * devicePixelRatio;
      ctx.strokeStyle = color;
      ctx.setLineDash([]);
      ctx.beginPath();
      for(let i=0;i<tArr.length;i++){
        const x = m.l + (tArr[i]/xMax)*pw;
        const y = m.t + ph - (b.mid[i]/yTop)*ph;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  return {m, pw, ph, xMax, yTop, tArr, seriesDict, opts};
}

function drawDOPlot(canvas, sim, overlay=null){
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const m = {l:56*devicePixelRatio, r:56*devicePixelRatio, t:30*devicePixelRatio, b:34*devicePixelRatio};
  const pw = w - m.l - m.r;
  const ph = h - m.t - m.b;

  const tArr = sim.t;
  const xMax = tArr[tArr.length-1] || 1;

  let yMax = sim.meta.oxy.Cstar * 1.1;
  for(const v of sim.DO_mgL) if(v>yMax) yMax=v;
  if(overlay && overlay.DO && overlay.DO.hi){
    for(let i=0;i<overlay.DO.hi.length;i++) if(overlay.DO.hi[i] > yMax) yMax = overlay.DO.hi[i];
  }
  if(overlay && overlay.Cstar && Number.isFinite(overlay.Cstar.hi)){
    yMax = Math.max(yMax, overlay.Cstar.hi * 1.1);
  }
  yMax = Math.max(0.1, yMax);
  const yTop = niceTop(yMax);
  const yStep = niceStep(yTop);

  // frame
  ctx.strokeStyle = 'rgba(231,236,255,0.18)';
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.strokeRect(m.l, m.t, pw, ph);

  // grid
  ctx.strokeStyle = 'rgba(231,236,255,0.06)';
  ctx.lineWidth = 1*devicePixelRatio;
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
  }
  const xStep = niceXStep(xMax);
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.beginPath();
    ctx.moveTo(px, m.t);
    ctx.lineTo(px, m.t+ph);
    ctx.stroke();
  }

  const CstarRef = (overlay && overlay.Cstar && Number.isFinite(overlay.Cstar.mid)) ? overlay.Cstar.mid : sim.meta.oxy.Cstar;

  // y labels (mg/L)
  ctx.fillStyle = 'rgba(231,236,255,0.75)';
  ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    ctx.fillText(y.toFixed(1), m.l-8, py);
  }
  // right axis (% saturation)
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    const pct = (CstarRef > 1e-9) ? (100 * y / CstarRef) : 0;
    ctx.fillText(`${Math.round(pct)}%`, m.l+pw+8, py);
  }
  // x labels
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.fillStyle = 'rgba(231,236,255,0.70)';
    const xLbl = (xStep < 1) ? x.toFixed(1) : String(Math.round(x));

        ctx.fillText(xLbl, px, m.t+ph+10);
  }

  // title
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillStyle = 'rgba(231,236,255,0.9)';
  ctx.font = `13px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
  ctx.fillText('Dissolved Oxygen (mg/L)', m.l, 10);
  ctx.textAlign = 'right';
  ctx.fillText('% saturation', m.l + pw, 10);

  // C* band + line
  const drawHBand = (yLo, yHi, alpha)=>{
    const py1 = m.t + ph - (yHi/yTop)*ph;
    const py2 = m.t + ph - (yLo/yTop)*ph;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = 'rgba(231,236,255,1)';
    ctx.fillRect(m.l, py1, pw, py2-py1);
    ctx.restore();
  };

  if(overlay && overlay.Cstar && Number.isFinite(overlay.Cstar.lo)){
    drawHBand(overlay.Cstar.lo, overlay.Cstar.hi, 0.07);
    const yMed = overlay.Cstar.mid;
    const py = m.t + ph - (yMed/yTop)*ph;
    ctx.save();
    ctx.setLineDash([6*devicePixelRatio, 6*devicePixelRatio]);
    ctx.strokeStyle = 'rgba(231,236,255,0.75)';
    ctx.lineWidth = 2*devicePixelRatio;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
    ctx.restore();
  }else{
    const y = sim.meta.oxy.Cstar;
    const py = m.t + ph - (y/yTop)*ph;
    ctx.save();
    ctx.setLineDash([6*devicePixelRatio, 6*devicePixelRatio]);
    ctx.strokeStyle = 'rgba(231,236,255,0.65)';
    ctx.lineWidth = 2*devicePixelRatio;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
    ctx.restore();
  }

  // DO band
  if(overlay && overlay.DO && overlay.DO.lo && overlay.DO.hi){
    const drawPath = ()=>{
      ctx.beginPath();
      for(let i=0;i<tArr.length;i++){
        const x = m.l + (tArr[i]/xMax)*pw;
        const y = m.t + ph - (overlay.DO.hi[i]/yTop)*ph;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      for(let i=tArr.length-1;i>=0;i--){
        const x = m.l + (tArr[i]/xMax)*pw;
        const y = m.t + ph - (overlay.DO.lo[i]/yTop)*ph;
        ctx.lineTo(x,y);
      }
      ctx.closePath();
    };
    const bandAlpha = overlay.DO.alpha ?? 0.16;
    ctx.save();
    ctx.globalAlpha = bandAlpha;
    ctx.fillStyle = 'rgba(118,178,255,1)';
    drawPath();
    ctx.fill();
    const size = Math.max(6, Math.round(10 * devicePixelRatio));
    const pat = document.createElement('canvas');
    pat.width = size;
    pat.height = size;
    const pctx = pat.getContext('2d');
    pctx.strokeStyle = 'rgba(118,178,255,1)';
    pctx.globalAlpha = 0.35;
    pctx.lineWidth = Math.max(1, Math.round(1 * devicePixelRatio));
    pctx.beginPath();
    pctx.moveTo(0, size);
    pctx.lineTo(size, 0);
    pctx.stroke();
    pctx.beginPath();
    pctx.moveTo(-size * 0.25, size);
    pctx.lineTo(size, -size * 0.25);
    pctx.stroke();
    ctx.globalAlpha = Math.min(0.4, bandAlpha + 0.08);
    ctx.fillStyle = ctx.createPattern(pat, 'repeat');
    drawPath();
    ctx.fill();
    ctx.restore();
  }

  // base DO (subtle if band exists)
  ctx.save();
  ctx.lineWidth = 2.4*devicePixelRatio;
  ctx.strokeStyle = 'rgba(118,178,255,1)';
  if(overlay && overlay.DO && overlay.DO.mid){
    ctx.globalAlpha = 0.30;
    ctx.setLineDash([3*devicePixelRatio, 3*devicePixelRatio]);
  }else{
    ctx.setLineDash([]);
  }
  ctx.beginPath();
  for(let i=0;i<tArr.length;i++){
    const x = m.l + (tArr[i]/xMax)*pw;
    const y = m.t + ph - (sim.DO_mgL[i]/yTop)*ph;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();

  // median DO line
  if(overlay && overlay.DO && overlay.DO.mid){
    ctx.save();
    ctx.lineWidth = 2.8*devicePixelRatio;
    ctx.strokeStyle = 'rgba(118,178,255,1)';
    ctx.setLineDash([]);
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (overlay.DO.mid[i]/yTop)*ph;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  return {m, pw, ph, xMax, yTop, tArr, sim, overlay};
}

function drawBiomassPlot(canvas, sim, overlay=null){
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const m = {l:56*devicePixelRatio, r:56*devicePixelRatio, t:30*devicePixelRatio, b:34*devicePixelRatio};
  const pw = w - m.l - m.r;
  const ph = h - m.t - m.b;

  const tArr = sim.t;
  const xMax = tArr[tArr.length-1] || 1;

  let yMaxG = Math.max(...sim.biomass.hetero_g, ...sim.biomass.phyto_g, 0.1);
  if(overlay && overlay.bioBands){
    yMaxG = Math.max(yMaxG, Math.max(...overlay.bioBands.hetero_g.hi, ...overlay.bioBands.phyto_g.hi));
  }
  const yTopG = niceTop(yMaxG);
  const yStepG = niceStep(yTopG);

  const pctVals = sim.biomass.hetero_pct.concat(sim.biomass.phyto_pct);
  let pctMin = Math.min(...pctVals, 0);
  let pctMax = Math.max(...pctVals, 0);
  if(overlay && overlay.bioPctBands){
    pctMin = Math.min(pctMin, Math.min(...overlay.bioPctBands.hetero_pct.lo, ...overlay.bioPctBands.phyto_pct.lo));
    pctMax = Math.max(pctMax, Math.max(...overlay.bioPctBands.hetero_pct.hi, ...overlay.bioPctBands.phyto_pct.hi));
  }
  const pctSpan = Math.max(1, Math.max(Math.abs(pctMin), Math.abs(pctMax)));
  const pctTop = niceTop(pctSpan);

  const yFromG = (val)=> m.t + ph - (val / yTopG) * ph;
  const yFromPct = (val)=> m.t + ph - ((val + pctTop) / (pctTop * 2)) * ph;

  // frame
  ctx.strokeStyle = 'rgba(231,236,255,0.18)';
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.strokeRect(m.l, m.t, pw, ph);

  // grid (grams scale)
  ctx.strokeStyle = 'rgba(231,236,255,0.06)';
  ctx.lineWidth = 1*devicePixelRatio;
  for(let y=0;y<=yTopG+1e-12;y+=yStepG){
    const py = yFromG(y);
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
  }
  const xStep = niceXStep(xMax);
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.beginPath();
    ctx.moveTo(px, m.t);
    ctx.lineTo(px, m.t+ph);
    ctx.stroke();
  }

  // axis labels
  ctx.fillStyle = 'rgba(231,236,255,0.75)';
  ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for(let y=0;y<=yTopG+1e-12;y+=yStepG){
    const py = yFromG(y);
    ctx.fillText(y.toFixed(1), m.l-8, py);
  }
  ctx.textAlign = 'left';
  for(let y=-pctTop;y<=pctTop+1e-12;y+=pctTop/4){
    const py = yFromPct(y);
    ctx.fillText(`${Math.round(y)}%`, m.l+pw+8, py);
  }

  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.fillStyle = 'rgba(231,236,255,0.70)';
    const xLbl = (xStep < 1) ? x.toFixed(1) : String(Math.round(x));
    ctx.fillText(xLbl, px, m.t+ph+10);
  }

  // title
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillStyle = 'rgba(231,236,255,0.9)';
  ctx.font = `13px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
  ctx.fillText('Expected biomass fluctuations', m.l, 10);
  ctx.textAlign = 'right';
  ctx.fillText('% change', m.l + pw, 10);

  const drawBand = (lo, hi, color, alpha=0.12)=>{
    const size = Math.max(6, Math.round(10 * devicePixelRatio));
    const pat = document.createElement('canvas');
    pat.width = size;
    pat.height = size;
    const pctx = pat.getContext('2d');
    pctx.strokeStyle = color;
    pctx.globalAlpha = 0.25;
    pctx.lineWidth = Math.max(1, Math.round(1 * devicePixelRatio));
    pctx.beginPath();
    pctx.moveTo(0, size);
    pctx.lineTo(size, 0);
    pctx.stroke();
    const pattern = ctx.createPattern(pat, 'repeat');
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = pattern || color;
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = yFromG(hi[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    for(let i=tArr.length-1;i>=0;i--){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = yFromG(lo[i]);
      ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  };

  if(overlay && overlay.bioBands){
    drawBand(overlay.bioBands.hetero_g.lo, overlay.bioBands.hetero_g.hi, '#ff9f43', 0.10);
    drawBand(overlay.bioBands.phyto_g.lo, overlay.bioBands.phyto_g.hi, '#1dd1a1', 0.10);
  }

  // grams lines
  const drawLine = (arr, color, bold=false)=>{
    ctx.save();
    ctx.lineWidth = (bold ? 2.4 : 1.4) * devicePixelRatio;
    ctx.strokeStyle = color;
    ctx.setLineDash([]);
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = yFromG(arr[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  };
  drawLine(sim.biomass.hetero_g, '#ff9f43', true);
  drawLine(sim.biomass.phyto_g, '#1dd1a1', true);

  // percent lines
  const drawPct = (arr, color)=>{
    ctx.save();
    ctx.lineWidth = 1.2 * devicePixelRatio;
    ctx.strokeStyle = color;
    ctx.setLineDash([4*devicePixelRatio, 3*devicePixelRatio]);
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = yFromPct(arr[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  };
  drawPct(sim.biomass.hetero_pct, '#ffd166');
  drawPct(sim.biomass.phyto_pct, '#a8e6cf');

  return {m, pw, ph, xMax, yTopG, pctTop, tArr, sim, overlay};
}

/* =========================================================
   Legend + events
========================================================= */
function buildLegendRate(){
  const root = el('legendRate');
  if(!root) return;
  root.innerHTML = '';
  for(const s of RATE_SERIES){
    const d = document.createElement('div');
    d.className = 'leg' + (visibleRate[s.key] ? '' : ' off');
    d.innerHTML = `<span class="dot" style="background:${s.color}"></span><span>${s.name}</span>`;
    d.addEventListener('click', ()=>{
      visibleRate[s.key] = !visibleRate[s.key];
      buildLegendRate();
      recompute();
    });
    root.appendChild(d);
  }
}

function buildLegendChem(){
  const root = el('legendChem');
  if(!root) return;
  root.innerHTML = '';
  for(const s of CHEM_SERIES){
    const d = document.createElement('div');
    d.className = 'leg' + (visibleChem[s.key] ? '' : ' off');
    d.innerHTML = `<span class="dot" style="background:${s.color}"></span><span>${s.name}</span>`;
    d.addEventListener('click', ()=>{
      visibleChem[s.key] = !visibleChem[s.key];
      buildLegendChem();
      recompute();
    });
    root.appendChild(d);
  }
}

function buildLegendBio(){
  const root = el('legendBio');
  if(!root) return;
  root.innerHTML = '';
  for(const s of BIOMASS_SERIES){
    const d = document.createElement('div');
    d.className = 'leg';
    const dash = s.dash ? 'border-bottom:2px dashed ' + s.color : `background:${s.color}`;
    d.innerHTML = `<span class="dot" style="${dash}"></span><span>${s.name}</span>`;
    root.appendChild(d);
  }
}

let EVENTS = [];

function maxPelletCountFromInputs(){
  const pelletEach_g = pelletMassEach(Number(el('pelLen')?.value || 1.0), Number(el('pelDia')?.value || 0.2), Number(el('pelRho')?.value || 0.55));
  const totalMass = Number(el('pelMassN')?.value || 0);
  return pelletEach_g > 0 ? totalMass / pelletEach_g : 0;
}

function normalizeEvents(){
  const daysMax = Number(el('daysN')?.value);
  const maxPel = maxPelletCountFromInputs();
  let remaining = maxPel;
  let truncated = false;
  const cleaned = [];

  EVENTS.sort((a,b)=>a.day-b.day);
  for(const raw of EVENTS){
    const day = clamp(Number(raw.day || 0), 0, Number.isFinite(daysMax) ? daysMax : raw.day);
    let pel = Math.max(0, Math.round(Number(raw.pellets || 0)));
    if(pel > remaining){
      pel = Math.max(0, Math.floor(remaining));
      truncated = true;
    }
    if(pel > 0){
      cleaned.push({day, pellets: pel});
      remaining -= pel;
    }
  }
  if(truncated){
    addWarning('Pop events truncated to avoid exceeding available pellets.');
  }
  EVENTS = cleaned;
}

function renderEvents(){
  const table = el('eventsTable');
  if(!table){
    addWarning('Events table missing (#eventsTable). Skipping event rendering.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'eventsTable', context:'renderEvents'});
    return;
  }
  const tb = table.querySelector('tbody');
  if(!tb){
    addWarning('Events table missing tbody. Skipping event rendering.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'eventsTable.tbody', context:'renderEvents'});
    return;
  }
  normalizeEvents();
  tb.innerHTML = '';
  EVENTS.forEach((e, idx)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.1" min="0" value="${Number(e.day).toFixed(1)}" data-idx="${idx}" data-k="day"></td>
      <td><input type="number" step="1" min="0" value="${Math.round(Number(e.pellets))}" data-idx="${idx}" data-k="pellets"></td>
      <td><button class="btn danger" data-del="${idx}">Remove</button></td>
    `;
    tb.appendChild(tr);
  });

  tb.querySelectorAll('input').forEach(inp=>{
    inp.addEventListener('input', (ev)=>{
      const i = Number(ev.target.dataset.idx);
      const k = ev.target.dataset.k;
      EVENTS[i][k] = Number(ev.target.value);
      saveState();
      renderEvents();
      recompute();
    });
  });

  tb.querySelectorAll('button[data-del]').forEach(btn=>{
    btn.addEventListener('click',(ev)=>{
      const i = Number(ev.target.dataset.del);
      EVENTS.splice(i,1);
      saveState();
      renderEvents();
      recompute();
    });
  });
}

/* =========================================================
   State persistence
========================================================= */
const STATE_VERSION = 7;

function saveState(){
  const s = {
    version: STATE_VERSION,
    // main sliders
    pelMass: Number(el('pelMassN').value),
    powMass: Number(el('powMassN').value),
    feedIntervalDays: Number(el('feedInterval').value),
    blanket: Number(el('blanketN').value),
    days: Number(el('daysN').value),

    // environment
    volL: Number(el('volL').value),
    airFlow: Number(el('airFlow').value),
    Tnow: Number(el('Tnow').value),
    pH: Number(el('pH').value),
    altM: Number(el('altM').value),
    tds: Number(el('tds').value),

    // geometry + exchange
    ripplePct: Number(el('ripplePct').value),
    lenCm: Number(el('lenCm').value),
    widCm: Number(el('widCm').value),
    tankHCm: Number(el('tankHCm').value),
    waterSurfCm: Number(el('waterSurfCm').value),
    blanketGapCm: Number(el('blanketGapCm').value),
    diffDepthCm: Number(el('diffDepthCm').value),
    heaters: Number(el('heaters').value),

    // presets + numbers
    diffType: el('diffType').value,
    sotePerM: Number(el('sotePerM').value),

    surfacePreset: el('surfacePreset') ? el('surfacePreset').value : 'typical',
    kCalm: Number(el('kCalm').value),
    kRipple: Number(el('kRipple').value),

    tightPreset: el('tightPreset') ? el('tightPreset').value : 'loose_high',
    tight: Number(el('tight').value),

    otrPreset: el('otrPreset') ? el('otrPreset').value : 'typical',
    otrCal: Number(el('otrCal').value),

    initDOPreset: el('initDOPreset') ? el('initDOPreset').value : '95',
    doInitPct: Number(el('doInitPct').value),

    // kinetics options
    o2Limit: el('o2Limit').value,
    kDoNit: Number(el('kDoNit').value),
    kDoHet: Number(el('kDoHet').value),
    slowFrac: Number(el('slowFrac').value),
    biofilmMm: Number(el('biofilmMm').value),
    kDenit: Number(el('kDenit').value),
    denitCap: Number(el('denitCap').value),
    heteroMass: Number(el('heteroMass').value),
    photoMass: Number(el('photoMass').value),
    tempAmp: Number(el('tempAmp').value),
    tempTauHours: 8,
    lightHour: Number(el('lightHour').value),
    kNH4Nit: Number(el('kNH4Nit').value),
    kNO2Nit: Number(el('kNO2Nit').value),
    nitCap: Number(el('nitCap').value),
    nitQ10: Number(el('nitQ10').value),
    nUnits: el('nUnits').value,
    chemNerd: !!el('chemNerd').checked,
    chemDisplay: el('chemDisplay') ? el('chemDisplay').value : 'bio',

    // pellet geometry
    pelLen: 1.00, // hardcoded
    pelDia: 0.20, // hardcoded
    pelRho: Number(el('pelRho').value),

    // uncertainty mode
    runMode: el('runMode') ? el('runMode').value : 'uncertainty',
    uncLevel: el('uncLevel') ? el('uncLevel').value : 'typical',
    mcRuns: el('mcRuns') ? Number(el('mcRuns').value) : 200,
    bandPreset: el('bandPreset') ? el('bandPreset').value : '10-90',
    seed: el('seed') ? Number(el('seed').value) : 12345,
    liveRecompute: el('liveRecompute') ? el('liveRecompute').value : 'on',
    uAir: el('uAir') ? !!el('uAir').checked : true,
    uDiff: el('uDiff') ? !!el('uDiff').checked : true,
    uSurf: el('uSurf') ? !!el('uSurf').checked : true,
    uTight: el('uTight') ? !!el('uTight').checked : true,
    uBio: el('uBio') ? !!el('uBio').checked : true,
    uTemp: el('uTemp') ? !!el('uTemp').checked : true,
    uInitDO: el('uInitDO') ? !!el('uInitDO').checked : true,

    events: EVENTS
  };
  localStorage.setItem('o2planner_state_v3', JSON.stringify(s));
}

function loadState(){
  try{
    let raw = localStorage.getItem('o2planner_state_v3');
    if(!raw) raw = localStorage.getItem('o2planner_state_v2'); // backwards compatibility
    if(!raw) return;

    const s = JSON.parse(raw);
    const set = (id, v)=>{ if(el(id) && v !== undefined && v !== null) el(id).value = v; };
    const setCheck = (id, v)=>{ if(el(id) && v !== undefined && v !== null) el(id).checked = !!v; };

    // sliders (range+number pairs)
    if(s.pelMass !== undefined){ el('pelMass').value = s.pelMass; el('pelMassN').value = s.pelMass; }
    if(s.powMass !== undefined){ el('powMass').value = s.powMass; el('powMassN').value = s.powMass; }
    if(s.feedIntervalDays !== undefined && el('feedInterval')) el('feedInterval').value = s.feedIntervalDays;
    if(s.blanket !== undefined){ el('blanket').value = s.blanket; el('blanketN').value = s.blanket; }
    if(s.days !== undefined){ el('days').value = s.days; el('daysN').value = s.days; }

    // environment + geometry
    ['volL','airFlow','Tnow','pH','altM','tds','ripplePct','lenCm','widCm','tankHCm','waterSurfCm','blanketGapCm','diffDepthCm',
     'heaters','sotePerM','kCalm','kRipple','tight','otrCal','doInitPct','kDoNit','kNH4Nit','kNO2Nit','nitCap','nitQ10',
     'kDoHet','slowFrac','biofilmMm','kDenit','denitCap','heteroMass','photoMass','tempAmp','lightHour',
     'pelLen','pelDia','pelRho'
    ].forEach(k=>set(k, s[k]));

    if(!s.version || s.version < STATE_VERSION){
      if(s.heteroMass === undefined) set('heteroMass', s.fishMass ?? 0);
      if(s.photoMass === undefined) set('photoMass', 0);
    }

    if(s.diffType !== undefined) el('diffType').value = s.diffType;
    if(s.surfacePreset !== undefined && el('surfacePreset')) el('surfacePreset').value = s.surfacePreset;
    if(s.tightPreset !== undefined && el('tightPreset')) el('tightPreset').value = s.tightPreset;
    if(s.otrPreset !== undefined && el('otrPreset')) el('otrPreset').value = s.otrPreset;
    if(s.initDOPreset !== undefined && el('initDOPreset')) el('initDOPreset').value = s.initDOPreset;

    if(s.o2Limit !== undefined) el('o2Limit').value = s.o2Limit;
    if(s.nUnits !== undefined && el('nUnits')) el('nUnits').value = s.nUnits;
    setCheck('chemNerd', s.chemNerd);
    if(s.chemDisplay !== undefined && el('chemDisplay')) el('chemDisplay').value = s.chemDisplay;

    // uncertainty mode
    if(el('runMode') && s.runMode !== undefined) el('runMode').value = s.runMode;
    if(el('uncLevel') && s.uncLevel !== undefined) el('uncLevel').value = s.uncLevel;
    if(el('mcRuns') && s.mcRuns !== undefined){ el('mcRuns').value = s.mcRuns; if(el('mcRunsRange')) el('mcRunsRange').value = s.mcRuns; }
    if(el('bandPreset') && s.bandPreset !== undefined) el('bandPreset').value = s.bandPreset;
    if(el('seed') && s.seed !== undefined) el('seed').value = s.seed;
    if(el('liveRecompute') && s.liveRecompute !== undefined) el('liveRecompute').value = s.liveRecompute;

    setCheck('uAir', s.uAir);
    setCheck('uDiff', s.uDiff);
    setCheck('uSurf', s.uSurf);
    setCheck('uTight', s.uTight);
    setCheck('uBio', s.uBio);
    setCheck('uTemp', s.uTemp);
    setCheck('uInitDO', s.uInitDO);

    EVENTS = Array.isArray(s.events) ? s.events : [];
    EVENTS = EVENTS.map(ev=>{
      if(ev && ev.pop !== undefined && ev.pellets === undefined){
        return {day: ev.day, pellets: ev.pop};
      }
      return ev;
    });
    // re-sync preset numeric fields after load
    try{ applyAllPresets(); }catch(_){}
  }catch(_){}
}

/* =========================================================
   Tooltips + click-to-add-event (bind once)
========================================================= */
let lastSim = null;
let lastMC = null;
let rateGeom = null;
let doGeom = null;
let chemGeom = null;
let bioGeom = null;
let interactionsBound = false;

function initCanvasInteractions(){
  const tip = ensureTooltip();

  const hide = ()=>{ if(!tip) return; tip.style.display='none'; };
  const show = (ev, html)=>{
    if(!tip) return;
    tip.innerHTML = html;
    tip.style.display = 'block';
    const pad = 14;
    const x = ev.clientX + pad;
    const y = ev.clientY + pad;
    tip.style.left = x + 'px';
    tip.style.top = y + 'px';
  };

  function idxFromEvent(ev, geom){
    const rect = ev.target.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * devicePixelRatio;
    const y = (ev.clientY - rect.top) * devicePixelRatio;
    if(x < geom.m.l || x > geom.m.l + geom.pw || y < geom.m.t || y > geom.m.t + geom.ph) return null;
    const frac = clamp((x - geom.m.l)/geom.pw, 0, 1);
    const day = frac * geom.xMax;
    const idx = clamp(Math.round(day / lastSim.meta.dt), 0, lastSim.t.length-1);
    return idx;
  }

  function bandLine(label, mid, lo, hi, color){
    return `<div style="margin-top:4px; color:${color}; opacity:.95">${label}: <span class="mono">${mid.toFixed(3)}</span> <span class="small" style="opacity:.9">[${lo.toFixed(3)}‚Äì${hi.toFixed(3)}]</span></div>`;
  }
  function bandLine2(label, mid, lo, hi, color){
    return `<div style="margin-top:4px; color:${color}; opacity:.95">${label}: <span class="mono">${mid.toFixed(2)}</span> <span class="small" style="opacity:.9">[${lo.toFixed(2)}‚Äì${hi.toFixed(2)}]</span></div>`;
  }

  const bind = (canvas, getGeom, kind)=>{
    if(canvas.dataset.bound === '1') return;
    canvas.dataset.bound = '1';

    canvas.addEventListener('mousemove', (ev)=>{
      if(!lastSim) return;
      const geom = getGeom();
      if(!geom) return;
      const idx = idxFromEvent(ev, geom);
      if(idx === null){ hide(); return; }

      const day = lastSim.t[idx];

      if(kind === 'rate'){
        const lines = [];
        lines.push(`<div><b>Day ${day.toFixed(2)}</b></div>`);
        for(const s of RATE_SERIES){
          if(!visibleRate[s.key]) continue;
          const v = lastSim.rate[s.key]?.[idx];
          if(v === undefined) continue;
          lines.push(`<div style="margin-top:4px"><span style="color:${s.color}">‚óè</span> ${s.name}: <b class="mono">${v.toFixed(3)}</b></div>`);
        }

        const DO = lastSim.DO_mgL[idx], DOpc = lastSim.DO_pct[idx];
        lines.push(`<div style="margin-top:6px; color:rgba(231,236,255,0.8)">DO (base): <span class="mono">${DO.toFixed(2)} mg/L</span> (${DOpc.toFixed(0)}%)</div>`);

        if(lastMC){
          const tmid = lastMC.q.rateTotal.mid[idx], tlo = lastMC.q.rateTotal.lo[idx], thi = lastMC.q.rateTotal.hi[idx];
          const smid = lastMC.q.rateSupply.mid[idx], slo = lastMC.q.rateSupply.lo[idx], shi = lastMC.q.rateSupply.hi[idx];
          lines.push(`<div class="hr" style="margin:8px 0"></div>`);
          lines.push(`<div class="small" style="opacity:.85">Uncertainty band:</div>`);
          lines.push(bandLine('Total demand', tmid, tlo, thi, 'rgba(255,140,171,1)'));
          lines.push(bandLine('O‚ÇÇ supply', smid, slo, shi, 'rgba(97,230,180,1)'));
          const dmid = lastMC.q.DO.mid[idx], dlo = lastMC.q.DO.lo[idx], dhi = lastMC.q.DO.hi[idx];
          lines.push(bandLine2('DO', dmid, dlo, dhi, 'rgba(118,178,255,1)'));
        }

        show(ev, lines.join(''));
      }

      if(kind === 'chem'){
        const lines = [];
        lines.push(`<div><b>Day ${day.toFixed(2)}</b></div>`);
        const mode = getChemDisplayMode();
        const chemSeries = resolveChemSeries(lastSim, mode).series;
        for(const s of CHEM_SERIES){
          if(!visibleChem[s.key]) continue;
          const v = chemSeries?.[s.key]?.[idx];
          if(v === undefined) continue;
          lines.push(`<div style="margin-top:4px"><span style="color:${s.color}">‚óè</span> ${s.name}: <b class="mono">${v.toFixed(3)}</b></div>`);
        }

        if(lastMC){
          const band = mode === 'prod' ? lastMC.q.chemProdBands : (mode === 'cum' ? lastMC.q.chemCumBands : lastMC.q.chemBands);
          if(band){
            lines.push(`<div class="hr" style="margin:8px 0"></div>`);
            lines.push(`<div class="small" style="opacity:.85">Uncertainty band:</div>`);
            for(const s of CHEM_SERIES){
              if(!visibleChem[s.key]) continue;
              const b = band[s.key];
              if(!b) continue;
              lines.push(bandLine2(s.name, b.mid[idx], b.lo[idx], b.hi[idx], s.color));
            }
          }
        }

        show(ev, lines.join(''));
      }

      if(kind === 'bio'){
        const lines = [];
        lines.push(`<div><b>Day ${day.toFixed(2)}</b></div>`);
        const hG = lastSim.biomass.hetero_g[idx];
        const pG = lastSim.biomass.phyto_g[idx];
        const hP = lastSim.biomass.hetero_pct[idx];
        const pP = lastSim.biomass.phyto_pct[idx];
        lines.push(`<div style="margin-top:4px"><span style="color:#ff9f43">‚óè</span> Heterotroph: <b class="mono">${hG.toFixed(2)} g</b> (${hP.toFixed(1)}%)</div>`);
        lines.push(`<div style="margin-top:4px"><span style="color:#1dd1a1">‚óè</span> Phyto: <b class="mono">${pG.toFixed(2)} g</b> (${pP.toFixed(1)}%)</div>`);
        if(lastMC){
          const band = lastMC.q.bioBands;
          const bandPct = lastMC.q.bioPctBands;
          lines.push(`<div class="hr" style="margin:8px 0"></div>`);
          lines.push(`<div class="small" style="opacity:.85">Uncertainty band:</div>`);
          lines.push(bandLine2('Hetero (g)', band.hetero_g.mid[idx], band.hetero_g.lo[idx], band.hetero_g.hi[idx], '#ff9f43'));
          lines.push(bandLine2('Phyto (g)', band.phyto_g.mid[idx], band.phyto_g.lo[idx], band.phyto_g.hi[idx], '#1dd1a1'));
          lines.push(bandLine2('Hetero (%)', bandPct.hetero_pct.mid[idx], bandPct.hetero_pct.lo[idx], bandPct.hetero_pct.hi[idx], '#ffd166'));
          lines.push(bandLine2('Phyto (%)', bandPct.phyto_pct.mid[idx], bandPct.phyto_pct.lo[idx], bandPct.phyto_pct.hi[idx], '#a8e6cf'));
        }
        show(ev, lines.join(''));
      }

      if(kind === 'do'){
        const lines = [];
        lines.push(`<div><b>Day ${day.toFixed(2)}</b></div>`);
        const DO = lastSim.DO_mgL[idx], DOpc = lastSim.DO_pct[idx];
        lines.push(`<div style="margin-top:4px"><span style="color:rgba(118,178,255,1)">‚óè</span> DO (base): <b class="mono">${DO.toFixed(2)} mg/L</b> (${DOpc.toFixed(0)}%)</div>`);
        const c = lastSim.meta.oxy.Cstar;
        lines.push(`<div style="margin-top:4px; opacity:.8">C* (base): <span class="mono">${c.toFixed(2)} mg/L</span></div>`);

        if(lastMC){
          const dmid = lastMC.q.DO.mid[idx], dlo = lastMC.q.DO.lo[idx], dhi = lastMC.q.DO.hi[idx];
          lines.push(`<div class="hr" style="margin:8px 0"></div>`);
          lines.push(`<div class="small" style="opacity:.85">Uncertainty band:</div>`);
          lines.push(bandLine2('DO', dmid, dlo, dhi, 'rgba(118,178,255,1)'));
          lines.push(`<div style="margin-top:4px; opacity:.8">C*: <span class="mono">${lastMC.scalars.Cstar.mid.toFixed(2)} mg/L</span> <span class="small">[${lastMC.scalars.Cstar.lo.toFixed(2)}‚Äì${lastMC.scalars.Cstar.hi.toFixed(2)}]</span></div>`);
        }

        show(ev, lines.join(''));
      }
    });

    canvas.addEventListener('mouseleave', hide);
  };

  const rateCanvas = el('rateCanvas');
  bind(rateCanvas, ()=>rateGeom, 'rate');
  bind(el('chemCanvas'), ()=>chemGeom, 'chem');
  bind(el('doCanvas'), ()=>doGeom, 'do');
  bind(el('bioCanvas'), ()=>bioGeom, 'bio');

  if(rateCanvas && rateGeom && rateCanvas.dataset.clickBound !== '1'){
    rateCanvas.dataset.clickBound = '1';
    rateCanvas.addEventListener('click', (ev)=>{
      if(!lastSim || !rateGeom) return;
      const idx = idxFromEvent(ev, rateGeom);
      if(idx === null) return;
      el('evDay').value = lastSim.t[idx].toFixed(2);
    });
  }
}

/* =========================================================
   Flags + summary
========================================================= */
function fmtVal(value, unit='', decimals=null){
  if(!Number.isFinite(value)) return unit ? `‚Äî ${unit}` : '‚Äî';
  const abs = Math.abs(value);
  const d = (decimals != null) ? decimals : (abs >= 10 ? 1 : (abs >= 1 ? 2 : 3));
  return `${value.toFixed(d)}${unit ? ` ${unit}` : ''}`;
}

function fmtBandLine(mode, good, warn, unit=''){
  if(mode === 'min'){
    return `Safe ‚â• ${fmtVal(good, unit)} ‚Ä¢ Watch ${fmtVal(warn, unit)}‚Äì${fmtVal(good, unit)} ‚Ä¢ Risk < ${fmtVal(warn, unit)}`;
  }
  return `Safe ‚â§ ${fmtVal(good, unit)} ‚Ä¢ Watch ${fmtVal(good, unit)}‚Äì${fmtVal(warn, unit)} ‚Ä¢ Risk > ${fmtVal(warn, unit)}`;
}

function drawTagSparkline(canvas, series, mode, good, warn){
  if(!canvas || !series || !series.length) return;
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0, 0, w, h);
  const pad = 3 * devicePixelRatio;
  const ph = h - pad * 2;
  const pw = w - pad * 2;
  const maxVal = Math.max(...series, good ?? 0, warn ?? 0, 0.0001);
  const minVal = 0;
  const yFromVal = (v)=> pad + ph - ((v - minVal) / (maxVal - minVal)) * ph;
  const step = Math.max(1, Math.floor(series.length / 60));

  const mid = (Number.isFinite(good) && Number.isFinite(warn)) ? ((good + warn) / 2) : null;
  // threshold lines
  ctx.save();
  ctx.setLineDash([2*devicePixelRatio, 2*devicePixelRatio]);
  ctx.lineWidth = 1 * devicePixelRatio;
  if(Number.isFinite(good)){
    ctx.strokeStyle = 'rgba(99,230,190,0.6)';
    const y = yFromVal(good);
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(pad + pw, y);
    ctx.stroke();
  }
  if(Number.isFinite(mid)){
    ctx.strokeStyle = 'rgba(255,207,90,0.55)';
    const y = yFromVal(mid);
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(pad + pw, y);
    ctx.stroke();
  }
  if(Number.isFinite(warn)){
    ctx.strokeStyle = 'rgba(255,107,107,0.6)';
    const y = yFromVal(warn);
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(pad + pw, y);
    ctx.stroke();
  }
  ctx.restore();

  // series line
  ctx.save();
  ctx.lineWidth = 1.4 * devicePixelRatio;
  ctx.strokeStyle = mode === 'min' ? 'rgba(99,230,190,0.9)' : 'rgba(122,162,255,0.9)';
  ctx.beginPath();
  let iPlot = 0;
  for(let i=0;i<series.length;i+=step){
    const x = pad + (iPlot / Math.max(1, Math.ceil(series.length/step)-1)) * pw;
    const y = yFromVal(series[i]);
    if(iPlot === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    iPlot++;
  }
  ctx.stroke();
  ctx.restore();
}

function setFlags(sim, params, mc){
  let flags = el('flags');
  if(!flags){
    addWarning('Flags container missing (#flags). Creating fallback container.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'flags', context:'setFlags'});
    const cards = document.querySelectorAll('.wrap .card');
    const host = cards.length ? cards[cards.length-1] : document.body;
    flags = document.createElement('div');
    flags.id = 'flags';
    flags.className = 'flags';
    flags.style.marginTop = '10px';
    host.appendChild(flags);
  }
  flags.innerHTML = '';
  let tags = el('chemTags');
  if(!tags){
    addWarning('Chemistry tag container missing (#chemTags). Creating fallback container.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'chemTags', context:'setFlags'});
    tags = document.createElement('div');
    tags.id = 'chemTags';
    tags.className = 'tag-stack';
    tags.style.marginTop = '10px';
    flags.parentNode?.insertBefore(tags, flags);
  }
  tags.innerHTML = '';
  let flagCount = 0;
  const tagSummary = [];

  const kindAliases = {ok:'ok', warn:'warn', danger:'danger', note:'note', good:'ok'};
  const good = kindAliases.good;
  const normalizeKind = (kind)=>{
    if(typeof kind !== 'string') return 'note';
    const norm = kindAliases[kind] || 'note';
    if(norm !== kind){
      addWarning(`Unknown flag kind "${kind}" normalized to "${norm}".`);
    }
    return norm;
  };

  const add = (kind, title, msg)=>{
    const div = document.createElement('div');
    const safeKind = normalizeKind(kind);
    div.className = 'flag-card';
    div.innerHTML = `
      <div class="flag-tag ${safeKind}">${title}<span>${safeKind.toUpperCase()}</span></div>
      <div class="flag-body"><div class="small">${msg}</div></div>
    `;
    flags.appendChild(div);
    flagCount++;
  };

  const estPellets = pelletMassEach(params.pelLen, params.pelDia, params.pelRho);
  const feedPlan = params.feedSchedule || [];
  const pelCount = feedPlan.reduce((acc, f)=>acc + (Number(f.pellets) || 0), 0);
  const eventTotal = (params.events || []).reduce((acc, e)=>acc + (Number(e.pellets) || 0), 0);
  if(eventTotal > pelCount + 1){
    add('warn', 'Pop events exceed pellets', `Total pops (${eventTotal.toFixed(0)}) exceed estimated pellet count (${pelCount.toFixed(0)}). The model caps pops automatically, but the schedule is probably too aggressive.`);
  }
  if(sim.meta?.chemCumInfo?.invalidCount){
    add('warn', 'Chemistry cumulative data gap', `Detected ${sim.meta.chemCumInfo.invalidCount} non-finite chemistry samples. Cumulative plot replaces them with 0 so the chart remains readable.`);
  }

  const rate = sim.rate.total;
  const supply = sim.rate.supply;

  // Peak demand and peak deficit vs supply (base run)
  let peak = {v:0, day:0, idx:0};
  let peakDef = {v:0, day:0, idx:0};
  for(let i=0;i<rate.length;i++){
    if(rate[i] > peak.v) peak = {v:rate[i], day:sim.t[i], idx:i};
    const def = rate[i] - supply[i];
    if(def > peakDef.v) peakDef = {v:def, day:sim.t[i], idx:i};
  }

  // Base deficit area
  let baseArea = 0;
  for(let i=0;i<rate.length;i++) baseArea += Math.max(0, rate[i]-supply[i]) * sim.meta.dt;

  // Base DO min
  let doMinStats = {v:Infinity, day:0, idx:0};
  let tUnder2 = 0, tUnder1 = 0;
  for(let i=0;i<sim.DO_mgL.length;i++){
    const v = sim.DO_mgL[i];
    if(v < doMinStats.v) doMinStats = {v, day:sim.t[i], idx:i};
    if(v < 2.0) tUnder2 += sim.meta.dt;
    if(v < 1.0) tUnder1 += sim.meta.dt;
  }

  let nh4PeakValue = 0, no2PeakValue = 0, no3PeakValue = 0, nh3PeakValue = 0;
  for(let i=0;i<sim.NH4_mgL.length;i++) if(sim.NH4_mgL[i] > nh4PeakValue) nh4PeakValue = sim.NH4_mgL[i];
  for(let i=0;i<sim.NO2_mgL.length;i++) if(sim.NO2_mgL[i] > no2PeakValue) no2PeakValue = sim.NO2_mgL[i];
  for(let i=0;i<sim.NO3_mgL.length;i++) if(sim.NO3_mgL[i] > no3PeakValue) no3PeakValue = sim.NO3_mgL[i];
  for(let i=0;i<sim.NH3_mgL.length;i++) if(sim.NH3_mgL[i] > nh3PeakValue) nh3PeakValue = sim.NH3_mgL[i];
  const denitN_mgL = (sim.audit.no3_to_n2 * 1000) / params.volL;

  // --------------------------
  // Uncertainty mode flags
  // --------------------------
  if(mc){
    const p2 = mc.probs.anyUnder2;
    const p1 = mc.probs.anyUnder1;

    // Severity by probability of dipping below thresholds (based on min DO across the run)
    if(p1 > 0.25){
      add('danger', 'Very high hypoxia risk', `In ${fmtPct(p1)} of runs, DO dips below <b>1 mg/L</b> at least once. That's ‚Äúfish emergency‚Äù territory.`);
    }else if(p1 > 0.10){
      add('warn', 'High hypoxia risk', `In ${fmtPct(p1)} of runs, DO dips below <b>1 mg/L</b>. Consider reducing input, increasing aeration, or increasing open surface exchange.`);
    }
  };
  const classify = (mode, value, good, warn)=>{
    if(!Number.isFinite(value)){
      addWarning('Chem tag value missing; check simulation outputs.');
      return {tone:'warn', label:'unknown'};
    }
    if(mode === 'min'){
      if(value >= good) return {tone:'ok', label:'good'};
      if(value >= warn) return {tone:'warn', label:'watch'};
      return {tone:'danger', label:'risk'};
    }
    if(value <= good) return {tone:'ok', label:'good'};
    if(value <= warn) return {tone:'warn', label:'watch'};
    return {tone:'danger', label:'risk'};
  };
  let sparkCount = 0;
  const addTag = ({label, tone, status, summary, details, spark})=>{
    const det = document.createElement('details');
    det.className = `tag-line tone-${tone}`;
    const sparkEl = spark ? '<canvas class="tag-spark" aria-hidden="true"></canvas>' : '';
    det.innerHTML = `
      <summary>
        <span class="tag-title">${label}</span>
        <span class="tag-meta">${summary}</span>
        ${sparkEl}
        <span class="tag-chip ${tone}">${status}</span>
      </summary>
      <div class="tag-details">${details.map(line=>`<div>${line}</div>`).join('')}</div>
    `;
    tags.appendChild(det);
    tagSummary.push({label, tone, status, summary});
    if(spark){
      const canvas = det.querySelector('.tag-spark');
      if(canvas){
        drawTagSparkline(canvas, spark.series, spark.mode, spark.good, spark.warn);
        sparkCount++;
      }
    }
  };

  const isMC = !!mc;
  const nFactorNH4 = params.nUnits === 'asIon' ? CHEM.NH4_ion_per_N : 1;
  const nFactorNO2 = params.nUnits === 'asIon' ? CHEM.NO2_ion_per_N : 1;
  const nFactorNO3 = params.nUnits === 'asIon' ? CHEM.NO3_ion_per_N : 1;
  const seriesNH4 = sim.NH4_mgL.map(v=>v * nFactorNH4);
  const seriesNO2 = sim.NO2_mgL.map(v=>v * nFactorNO2);
  const seriesNO3 = sim.NO3_mgL.map(v=>v * nFactorNO3);
  const seriesNH3 = sim.NH3_mgL;
  const seriesCO2 = sim.CO2_mgL;
  const seriesMicro = sim.micro_mgL;
  const seriesStore = sim.store_mgL;
  const seriesCopper = seriesMicro.map(v=>v * FEED_PROFILE.modeling.copperFractionOfMicro);

  const doMin = isMC ? mc.scalars.minDO.mid : Math.min(...sim.DO_mgL);
  const nh3Peak = isMC ? mc.scalars.nh3pk.mid : Math.max(...sim.NH3_mgL);
  const nh4Peak = isMC ? (mc.scalars.nh4pk.mid * nFactorNH4) : Math.max(...seriesNH4);
  const no2Peak = isMC ? (mc.scalars.no2pk.mid * nFactorNO2) : Math.max(...seriesNO2);
  const no3Peak = isMC ? (mc.scalars.no3pk.mid * nFactorNO3) : Math.max(...seriesNO3);
  const co2Peak = isMC ? mc.scalars.co2pk.mid : Math.max(...seriesCO2);
  const microPeak = isMC ? mc.scalars.microPk.mid : Math.max(...seriesMicro);
  const storeMin = isMC ? mc.scalars.storeMin.mid : Math.min(...seriesStore);
  const copperPeak = microPeak * FEED_PROFILE.modeling.copperFractionOfMicro;

  const doClass = classify('min', doMin, 5, 2);
  addTag({
    label:'Dissolved oxygen (DO)',
    tone: doClass.tone,
    status: doClass.label,
    summary:`min ${fmtVal(doMin, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median minimum' : 'minimum'}: ${fmtVal(doMin, 'mg/L')}.`,
      fmtBandLine('min', 5, 2, 'mg/L'),
      `Context: pH ${params.pH}, temperature ${params.Tnow}¬∞C, volume ${params.volL} L.`
    ],
    spark:{series: sim.DO_mgL, mode:'min', good:5, warn:2}
  });

  const nh3Class = classify('max', nh3Peak, 0.02, 0.05);
  addTag({
    label:'NH‚ÇÉ (unionized)',
    tone: nh3Class.tone,
    status: nh3Class.label,
    summary:`peak ${fmtVal(nh3Peak, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(nh3Peak, 'mg/L')}.`,
      fmtBandLine('max', 0.02, 0.05, 'mg/L'),
      `Unionized fraction depends on pH ${params.pH} and temperature ${params.Tnow}¬∞C.`
    ],
    spark:{series: seriesNH3, mode:'max', good:0.02, warn:0.05}
  });

  // --------------------------
  // Single-run flags
  // --------------------------
  if(doMinStats.v < 1.0){
    add('danger', 'DO crash', `Min DO is <b>${doMinStats.v.toFixed(2)} mg/L</b> at day ${doMinStats.day.toFixed(2)}. That‚Äôs a crash risk.`);
  }else if(doMinStats.v < 2.0){
    add('warn', 'Low DO window', `Min DO is <b>${doMinStats.v.toFixed(2)} mg/L</b> at day ${doMinStats.day.toFixed(2)}. Many animals get stressed below ~2 mg/L.`);
  }else if(doMinStats.v < 4.0){
    add('note', 'Moderate DO dip', `Min DO is ${doMinStats.v.toFixed(2)} mg/L at day ${doMinStats.day.toFixed(2)}. Probably fine for hardier stock, but still worth watching.`);
  }else{
    add('note', 'DO looks comfortable', `Min DO is ${doMinStats.v.toFixed(2)} mg/L at day ${doMinStats.day.toFixed(2)}.`);
  }

  if(peakDef.v > 0.1){
    add('warn', 'Demand exceeds supply', `Peak deficit is <b>${peakDef.v.toFixed(2)} g/day</b> at day ${peakDef.day.toFixed(2)}. Expect DO to trend downward around that window.`);
  }else{
    add('note', 'Supply generally keeps up', `Peak deficit is ${peakDef.v.toFixed(2)} g/day.`);
  }

  const co2Class = classify('max', co2Peak, 15, 30);
  addTag({
    label:'CO‚ÇÇ free',
    tone: co2Class.tone,
    status: co2Class.label,
    summary:`peak ${fmtVal(co2Peak, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(co2Peak, 'mg/L')}.`,
      fmtBandLine('max', 15, 30, 'mg/L'),
      `Free CO‚ÇÇ tracks buffering and photosynthetic drawdown.`
    ],
    spark:{series: seriesCO2, mode:'max', good:15, warn:30}
  });

  const storeClass = classify('min', storeMin, 1.0, 0.4);
  addTag({
    label:'Nutrient stores',
    tone: storeClass.tone,
    status: storeClass.label,
    summary:`min ${fmtVal(storeMin, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median minimum' : 'minimum'}: ${fmtVal(storeMin, 'mg/L')}.`,
      fmtBandLine('min', 1.0, 0.4, 'mg/L'),
      `Stores buffer growth against nutrient droughts; low minima imply luxury uptake is exhausted.`
    ],
    spark:{series: seriesStore, mode:'min', good:1.0, warn:0.4}
  });

  const no2Class = classify('max', no2Peak, 0.15, 0.30);
  addTag({
    label:'Nitrite (NO‚ÇÇ)',
    tone: no2Class.tone,
    status: no2Class.label,
    summary:`peak ${fmtVal(no2Peak, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(no2Peak, 'mg/L')}.`,
      fmtBandLine('max', 0.15, 0.30, 'mg/L'),
      `Nitrite is an acute toxicity risk; maintain strong biofiltration.`
    ],
    spark:{series: seriesNO2, mode:'max', good:0.15, warn:0.30}
  });

  const no3Class = classify('max', no3Peak, 20, 40);
  addTag({
    label:'Nitrate (NO‚ÇÉ)',
    tone: no3Class.tone,
    status: no3Class.label,
    summary:`peak ${fmtVal(no3Peak, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(no3Peak, 'mg/L')}.`,
      fmtBandLine('max', 20, 40, 'mg/L'),
      `Nitrate accumulates over time; dilution or denitrification reduces it.`
    ],
    spark:{series: seriesNO3, mode:'max', good:20, warn:40}
  });

  const copperClass = classify('max', copperPeak, 0.02, 0.05);
  addTag({
    label:'Copper (proxy)',
    tone: copperClass.tone,
    status: copperClass.label,
    summary:`peak ${fmtVal(copperPeak, 'mg/L')}`,
    details:[
      `Proxy from micronutrients: ${fmtVal(copperPeak, 'mg/L')}.`,
      fmtBandLine('max', 0.02, 0.05, 'mg/L'),
      `Copper is invertebrate-sensitive; consider targeted test kits for confirmation.`
    ],
    spark:{series: seriesCopper, mode:'max', good:0.02, warn:0.05}
  });

  if(isMC){
    DEBUG_STATE.lastFlagsCount = flagCount;
    DEBUG_STATE.lastFlagsMode = 'uncertainty';
    DEBUG_STATE.lastTagSummary = {mode:'uncertainty', tags: tagSummary};
    DEBUG_STATE.lastTagSparkCount = sparkCount;
    return;
  }

  if(nh3PeakValue > 0.10){
    add('danger', 'NH‚ÇÉ toxicity risk', `Unionized NH‚ÇÉ peaks near ${nh3PeakValue.toFixed(3)} mg/L. Consider lower pH, reduced load, or more nitrification capacity.`);
  }else if(nh3PeakValue > 0.05){
    add('warn', 'NH‚ÇÉ watch zone', `Unionized NH‚ÇÉ peaks near ${nh3PeakValue.toFixed(3)} mg/L. Keep an eye on sensitive stock.`);
  }else{
    add('note', 'NH‚ÇÉ stays low', `Unionized NH‚ÇÉ peaks near ${nh3PeakValue.toFixed(3)} mg/L.`);
  }

  add('note', 'Nitrogen peaks (single run)', `NH‚ÇÑ: ${nh4PeakValue.toFixed(3)} mg/L ‚Ä¢ NO‚ÇÇ: ${no2PeakValue.toFixed(3)} mg/L ‚Ä¢ NO‚ÇÉ: ${no3PeakValue.toFixed(3)} mg/L.`);
  if(denitN_mgL > 0.2){
    add('note', 'Denitrification activity', `Estimated NO‚ÇÉ ‚Üí N‚ÇÇ conversion: ${denitN_mgL.toFixed(2)} mg/L as N. Low-DO windows are driving denitrification.`);
  }
  DEBUG_STATE.lastFlagsCount = flagCount;
  DEBUG_STATE.lastFlagsMode = 'single';
  DEBUG_STATE.lastTagSummary = {mode:'single', tags: tagSummary};
  DEBUG_STATE.lastTagSparkCount = sparkCount;
}

/* =========================================================
   Main recompute + render
========================================================= */
function getParams(){
  // Keep ‚Äúpreset selectors‚Äù synced to their numeric fields before reading
  try{ applyAllPresets(); }catch(_){}

  // Hardcoded pellet geometry (project standard)
  try{
    if(el('pelLen')) el('pelLen').value = '1.00';
    if(el('pelDia')) el('pelDia').value = '0.20';
  }catch(_){}

  const p = {
    feedPellets: Number(el('pelMassN').value),
    feedPowder_g: Number(el('powMassN').value),
    feedIntervalDays: Number(el('feedInterval').value),
    feedWindowHours: 4,
    blanketPct: Number(el('blanketN').value),
    days: Number(el('daysN').value),

    volL: Number(el('volL').value),
    airFlow: Number(el('airFlow').value),
    Tnow: Number(el('Tnow').value),
    pH: Number(el('pH').value),
    altM: Number(el('altM').value),
    tds: Number(el('tds').value),

    ripplePct: Number(el('ripplePct').value),

    lenCm: Number(el('lenCm').value),
    widCm: Number(el('widCm').value),
    tankHCm: Number(el('tankHCm').value),
    waterSurfCm: Number(el('waterSurfCm').value),
    blanketGapCm: Number(el('blanketGapCm').value),
    diffDepthCm: Number(el('diffDepthCm').value),
    heaters: Number(el('heaters').value),

    diffType: el('diffType').value,
    sotePerM: Number(el('sotePerM').value),
    surfacePreset: el('surfacePreset') ? el('surfacePreset').value : 'typical',
    kCalm: Number(el('kCalm').value),
    kRipple: Number(el('kRipple').value),

    tightPreset: el('tightPreset') ? el('tightPreset').value : 'loose_high',
    tight: Number(el('tight').value),

    otrPreset: el('otrPreset') ? el('otrPreset').value : 'typical',
    otrCal: Number(el('otrCal').value),

    initDOPreset: el('initDOPreset') ? el('initDOPreset').value : '95',
    doInitPct: Number(el('doInitPct').value),

    o2Limit: el('o2Limit').value,
    kDoNit: Number(el('kDoNit').value),
    kDoHet: Number(el('kDoHet').value),
    slowFrac: Number(el('slowFrac').value),
    biofilmMm: Number(el('biofilmMm').value),
    kDenit: Number(el('kDenit').value),
    denitCap: Number(el('denitCap').value),
    heteroMass: Number(el('heteroMass').value),
    photoMass: Number(el('photoMass').value),
    tempAmp: Number(el('tempAmp').value),
    lightHour: Number(el('lightHour').value),
    kNH4Nit: Number(el('kNH4Nit').value),
    kNO2Nit: Number(el('kNO2Nit').value),
    nitCap: Number(el('nitCap').value),
    nitQ10: Number(el('nitQ10').value),
    nUnits: el('nUnits').value,
    chemNerd: !!el('chemNerd').checked,

    pelLen: Number(el('pelLen').value),
    pelDia: Number(el('pelDia').value),
    pelRho: Number(el('pelRho').value),

    // Uncertainty mode controls
    runMode: el('runMode') ? el('runMode').value : 'uncertainty',
    uncLevel: el('uncLevel') ? el('uncLevel').value : 'typical',
    mcRuns: el('mcRuns') ? Number(el('mcRuns').value) : 200,
    bandPreset: el('bandPreset') ? el('bandPreset').value : '10-90',
    seed: el('seed') ? Number(el('seed').value) : 12345,
    liveRecompute: el('liveRecompute') ? el('liveRecompute').value : 'on',
    u: {
      air: el('uAir') ? el('uAir').checked : true,
      diff: el('uDiff') ? el('uDiff').checked : true,
      surf: el('uSurf') ? el('uSurf').checked : true,
      tight: el('uTight') ? el('uTight').checked : true,
      bio: el('uBio') ? el('uBio').checked : true,
      temp: el('uTemp') ? el('uTemp').checked : true,
      initDO: el('uInitDO') ? el('uInitDO').checked : true,
    },

    events: EVENTS
  };

  // light sanitization
  p.mcRuns = clamp(Math.round(p.mcRuns || 0), 10, 5000);
  p.feedIntervalDays = clamp(Number.isFinite(p.feedIntervalDays) ? p.feedIntervalDays : 1, 0.25, 365);
  p.pH = clamp(Number.isFinite(p.pH) ? p.pH : 7.0, 5.0, 9.5);
  p.tempTauHours = clamp(Number.isFinite(p.tempTauHours) ? p.tempTauHours : 8, 1, 24);
  p.nitCap = clamp(Number.isFinite(p.nitCap) ? p.nitCap : 1.0, 0, 1);
  p.denitCap = clamp(Number.isFinite(p.denitCap) ? p.denitCap : 1.0, 0, 1);
  p.lightHour = clamp(Number.isFinite(p.lightHour) ? p.lightHour : 8, 0, 23);
  p.photoMass = clamp(Number.isFinite(p.photoMass) ? p.photoMass : 0, 0, 100000);
  const phytoTotal = p.photoMass;
  const heteroTotal = Number.isFinite(p.heteroMass) ? p.heteroMass : 0;
  p.phytoAlgae_g = Math.max(0, phytoTotal * PHYTO_SPLIT.algae);
  p.phytoPlankton_g = Math.max(0, phytoTotal * PHYTO_SPLIT.plankton);
  p.phytoPlants_g = Math.max(0, phytoTotal * PHYTO_SPLIT.plants);
  p.biofilm_g = Math.max(0, heteroTotal * HET_SPLIT.biofilm);
  p.predator_g = Math.max(0, heteroTotal * HET_SPLIT.predator);
  return p;
}

function fmtBand(stats, unit, decimals=2){
  const lo = stats.lo, mid = stats.mid, hi = stats.hi;
  if(!Number.isFinite(lo) || !Number.isFinite(mid) || !Number.isFinite(hi)) return '‚Äî';
  return `${mid.toFixed(decimals)} ${unit}  [${lo.toFixed(decimals)}‚Äì${hi.toFixed(decimals)}]`;
}

function convertStats(stats, factor){
  if(!stats) return stats;
  return {lo: stats.lo*factor, mid: stats.mid*factor, hi: stats.hi*factor};
}

function fmtPct(p){
  if(!Number.isFinite(p)) return '‚Äî';
  return `${(100*p).toFixed(1)}%`;
}

function getChemDisplayMode(){
  const mode = el('chemDisplay') ? el('chemDisplay').value : 'bio';
  if(['bio','prod','cum'].includes(mode)) return mode;
  return 'bio';
}

function resolveChemSeries(sim, mode){
  if(mode === 'prod') return {series: sim.chemProd, titleSuffix:'(production only)'};
  if(mode === 'cum') return {series: sim.chemProdCum, titleSuffix:'(cumulative production)'};
  return {series: sim.chem, titleSuffix:'(net)'}; // bio
}

function setRecomputeBubbleState(isActive){
  const bubble = el('recomputeToast');
  if(!bubble) return;
  bubble.classList.toggle('is-active', !!isActive);
  bubble.setAttribute('aria-hidden', isActive ? 'false' : 'true');
}

function recompute(){
  clearError();
  if(debounceTimerId !== null){
    clearTimeout(debounceTimerId);
    debounceTimerId = null;
  }
  DEBUG_STATE.debounceQueued = 0;
  setRecomputeBubbleState(true);
  setStage('recompute', 'start');
  DEBUG_STATE.warnings = [];
  const recomputeStart = performance.now();

  try{
    setStage('UI', 'apply presets');
    applyAllPresets();

    setStage('UI', 'read params');
    const params = getParams();
    DEBUG_STATE.lastParams = params;
    DEBUG_STATE.lastMode = params.runMode;
    DEBUG_STATE.lastUpdateISO = new Date().toISOString();
    const chemMode = getChemDisplayMode();

    updateChemSeriesLabels(params.nUnits);
    buildLegendChem();
    buildLegendBio();

    assertFinite('days', params.days);
    assertFinite('volL', params.volL);

    saveState();

    // Pellet derived quantities + feeding schedule
    setStage('Pellets', 'derive pellet count');
    const pelletEach_g = pelletMassEach(params.pelLen, params.pelDia, params.pelRho);
    const perFeedPellets = Math.max(0, Math.round(Number(params.feedPellets || 0)));
    const perFeedMass_g = perFeedPellets * pelletEach_g;
    setText('pelCount', `${perFeedPellets.toFixed(0)} pellets`);
    setText('pelEach', `${pelletEach_g.toFixed(4)} g`);
    const feedPlan = buildFeedSchedule(params, pelletEach_g);
    params.feedSchedule = feedPlan;
    DEBUG_STATE.lastFeedScheduleCount = feedPlan.length;
    renderFeedingCalendar(params, feedPlan, EVENTS);
    measurePanelOverflow();

    // Base sim (used for breakdown lines + UI even in uncertainty mode)
    setStage('Simulation', 'run base sim');
    const baseSim = runSimulation(params);
    lastSim = baseSim;
    lastMC = null;

    const oxy = baseSim.meta.oxy;
    DEBUG_STATE.lastOxy = oxy;
    DEBUG_STATE.lastSimMeta = baseSim.meta;
    DEBUG_STATE.lastChemCumInfo = baseSim.meta.chemCumInfo || null;
    DEBUG_STATE.lastPhotoModel = baseSim.meta.photoModel || null;
    DEBUG_STATE.lastFeedProfileId = baseSim.meta.feedProfileId || FEED_PROFILE.id;
    DEBUG_STATE.lastOxygenClampCount = baseSim.meta.oxygenClampCount ?? null;
    DEBUG_STATE.lastPlantLimitedSteps = baseSim.meta.oxygenDegasSteps ?? null;
    DEBUG_STATE.lastBiomassSummary = {
      heteroStart: baseSim.biomass?.hetero_g?.[0] ?? null,
      heteroEnd: baseSim.biomass?.hetero_g?.[baseSim.biomass?.hetero_g?.length - 1] ?? null,
      phytoStart: baseSim.biomass?.phyto_g?.[0] ?? null,
      phytoEnd: baseSim.biomass?.phyto_g?.[baseSim.biomass?.phyto_g?.length - 1] ?? null,
      heteroGrowthTotal: baseSim.meta.heteroGrowthTotal ?? null,
      heteroConsumedTotal: baseSim.meta.heteroConsumedTotal ?? null,
      phytoGrowthTotal: baseSim.meta.phytoGrowthTotal ?? null,
      phytoAlgaeGrowthTotal: baseSim.meta.phytoAlgaeGrowthTotal ?? null,
      phytoPlanktonGrowthTotal: baseSim.meta.phytoPlanktonGrowthTotal ?? null,
      phytoPlantsGrowthTotal: baseSim.meta.phytoPlantsGrowthTotal ?? null,
      phytoConsumedTotal: baseSim.meta.phytoConsumedTotal ?? null,
      phytoDecayTotal: baseSim.meta.phytoDecayTotal ?? null,
      tempSmoothRange: baseSim.meta.tempSmoothRange ?? null,
      co2ZeroHits: baseSim.meta.co2ZeroHits ?? null,
      phytoGrazedTotal: baseSim.meta.phytoGrazedTotal ?? null,
      biofilmGrazedTotal: baseSim.meta.biofilmGrazedTotal ?? null,
      predatorGrazedTotal: baseSim.meta.predatorGrazedTotal ?? null,
      oxygenDegassed_g: baseSim.meta.oxygenDegassed_g ?? null
    };
    if(params.photoMass > 0 && (baseSim.meta.phytoConsumedTotal ?? 0) <= 1e-6){
      addWarning('Phyto consumed ~0 g over the run. Check light, nutrients, and CO‚ÇÇ availability.');
    }
    if(params.heteroMass > 0 && (baseSim.meta.heteroConsumedTotal ?? 0) <= 1e-6){
      addWarning('Heterotroph consumed ~0 g over the run. Check feed inputs and kinetics.');
    }
    if((baseSim.meta.co2ZeroHits ?? 0) > 0){
      addWarning(`Free CO‚ÇÇ depleted to 0 mg/L for ${baseSim.meta.co2ZeroHits} steps; phyto growth stalls until CO‚ÇÇ recovers.`);
    }
    if((baseSim.meta.co2DegasSteps ?? 0) > 0){
      addWarning(`Free CO‚ÇÇ exceeded saturation for ${baseSim.meta.co2DegasSteps} steps; excess degassed to air.`);
    }
    if((baseSim.meta.grazingLimitedSteps ?? 0) > (baseSim.t.length * 0.25)){
      addWarning('Grazing limited for >25% of steps; phyto scarcity or grazing rate caps may be throttling heterotroph growth.');
    }
    if((baseSim.meta.co2AirOut_g ?? 0) > (baseSim.meta.co2AirIn_g ?? 0) * 1.2){
      addWarning('CO‚ÇÇ degassing outpaced atmospheric re-supply; CO‚ÇÇ limitation may still constrain growth.');
    }
    if((baseSim.meta.phytoReserveUsed ?? 0) <= 1e-6 && params.photoMass > 0){
      addWarning('Phyto reserve never used; night growth may be stalled by nutrients or CO‚ÇÇ.');
    }
    if((baseSim.meta.grazingShieldMin ?? 1) < 0.2 && params.heteroMass > 0){
      addWarning('Grazing shield dropped below 0.2; refugia protection is minimal and grazing pressure is high.');
    }
    if(baseSim.meta.chemCumInfo?.invalidCount){
      addWarning(`Chemistry cumulative series had ${baseSim.meta.chemCumInfo.invalidCount} non-finite samples; treated as 0 in the cumulative plot.`);
    }

    // If uncertainty mode: run MC overlay
    if(params.runMode === 'uncertainty'){
      setStage('Uncertainty', 'Monte Carlo');
      const mc = runMonteCarlo(params);
      lastMC = mc;
      DEBUG_STATE.lastScalars = mc.scalars;
      const bandDiagnostics = {
        rateInvalid: 0,
        rateInverted: 0,
        chemInvalid: 0,
        chemInverted: 0,
        bioInvalid: 0,
        bioInverted: 0,
        doInvalid: 0,
        doInverted: 0
      };

      // Oxygenation meta (bands)
      setText('cStarOut', fmtBand(mc.scalars.Cstar, 'mg/L', 2));
      setText('otrOut', fmtBand(mc.scalars.otrMax, 'g/day', 2));
      setText('klaOut', fmtBand(mc.scalars.kLa, '1/day', 3));

      // DO min + risk
      setText('doMinOut', `${fmtBand(mc.scalars.minDO, 'mg/L', 2)}  @ day ${fmtBand(mc.scalars.minDO_day, '', 2).replace('  [','[')}`);
      setText('pUnder2Out', fmtPct(mc.probs.anyUnder2));
      setText('pUnder1Out', fmtPct(mc.probs.anyUnder1));

      const nh4Stats = params.nUnits === 'asIon' ? convertStats(mc.scalars.nh4pk, CHEM.NH4_ion_per_N) : mc.scalars.nh4pk;
      const no2Stats = params.nUnits === 'asIon' ? convertStats(mc.scalars.no2pk, CHEM.NO2_ion_per_N) : mc.scalars.no2pk;
      const no3Stats = params.nUnits === 'asIon' ? convertStats(mc.scalars.no3pk, CHEM.NO3_ion_per_N) : mc.scalars.no3pk;

      setText('nh4Out', fmtBand(nh4Stats, 'mg/L', 3));
      setText('no2Out', fmtBand(no2Stats, 'mg/L', 3));
      setText('no3Out', fmtBand(no3Stats, 'mg/L', 3));
      setText('nh3Out', fmtBand(mc.scalars.nh3pk, 'mg/L', 3));
      setText('co2Out', fmtBand(mc.scalars.co2pk, 'mg/L', 2));
      const macroStats = mc.scalars.macroPk;
      const microStats = mc.scalars.microPk;
      setText('nutrOut', `${fmtBand(macroStats, 'mg/L', 2)} ‚Ä¢ ${fmtBand(microStats, 'mg/L', 2)}`);

      // Plots with bands
      setStage('Plots', 'rate');
      const rateBands = Object.fromEntries(RATE_SERIES.map(s=>{
        const sanitized = sanitizeBand(mc.q.rateBands[s.key], baseSim.rate[s.key], `rate:${s.key}`);
        bandDiagnostics.rateInvalid += sanitized.invalid;
        bandDiagnostics.rateInverted += sanitized.inverted;
        return [
          s.key,
          {lo:sanitized.band.lo, hi:sanitized.band.hi, mid:sanitized.band.mid, alpha:(s.key === 'total' ? 0.18 : (s.key === 'supply' ? 0.14 : 0.08))}
        ];
      }));
      DEBUG_STATE.lastRateBandKeys = Object.keys(rateBands);
      const missingRateBands = RATE_SERIES.filter(s=>!rateBands[s.key] || !rateBands[s.key].hi).map(s=>s.key);
      if(missingRateBands.length){
        addWarning(`Missing rate uncertainty bands for: ${missingRateBands.join(', ')}`);
      }
      rateGeom = drawPlot(el('rateCanvas'), baseSim.t, baseSim.rate, {
        title:"Oxygen RATE (g O‚ÇÇ/day)",
        bands: rateBands,
        bandColors: Object.fromEntries(RATE_SERIES.map(s=>[s.key, s.color])),
        fitYMax: true,
        bandPattern: true
      });

      setStage('Plots', 'dissolved oxygen');
      const doBand = sanitizeBand(mc.q.DO, baseSim.DO_mgL, 'DO');
      bandDiagnostics.doInvalid += doBand.invalid;
      bandDiagnostics.doInverted += doBand.inverted;
      if(!mc.scalars?.Cstar || !Number.isFinite(mc.scalars.Cstar.mid)){
        addWarning('Monte Carlo C* band invalid; using base C* for DO plot.');
      }
      doGeom = drawDOPlot(el('doCanvas'), baseSim, {
        DO:{lo:doBand.band.lo, hi:doBand.band.hi, mid:doBand.band.mid, alpha:0.18},
        Cstar: mc.scalars.Cstar
      });

      setStage('Plots', 'chemistry');
      const chemBands = chemMode === 'prod' ? mc.q.chemProdBands : (chemMode === 'cum' ? mc.q.chemCumBands : mc.q.chemBands);
      DEBUG_STATE.lastChemBandKeys = Object.keys(chemBands);
      const missingChemBands = CHEM_SERIES.filter(s=>!chemBands[s.key] || !chemBands[s.key].hi).map(s=>s.key);
      if(missingChemBands.length){
        addWarning(`Missing chemistry uncertainty bands for: ${missingChemBands.join(', ')}`);
      }
      const chemSeries = resolveChemSeries(baseSim, chemMode);
      chemGeom = drawPlot(el('chemCanvas'), baseSim.t, chemSeries.series, {
        title:`Chemistry / Compounds (mg/L) ${chemSeries.titleSuffix}`,
        series: CHEM_SERIES,
        visible: visibleChem,
        bands: Object.fromEntries(CHEM_SERIES.map(s=>{
          const sanitized = sanitizeBand(chemBands[s.key], chemSeries.series[s.key], `chem:${s.key}`);
          bandDiagnostics.chemInvalid += sanitized.invalid;
          bandDiagnostics.chemInverted += sanitized.inverted;
          return [s.key, {lo:sanitized.band.lo, hi:sanitized.band.hi, mid:sanitized.band.mid, alpha:0.12}];
        })),
        bandColors: Object.fromEntries(CHEM_SERIES.map(s=>[s.key, s.color])),
        bandPattern: true
      });
      setStage('Plots', 'biomass');
      const missingBioBands = [];
      ['hetero_g', 'phyto_g'].forEach(key=>{
        if(!mc.q.bioBands?.[key]?.hi){
          missingBioBands.push(`bioBands.${key}`);
        }
      });
      ['hetero_pct', 'phyto_pct'].forEach(key=>{
        if(!mc.q.bioPctBands?.[key]?.hi){
          missingBioBands.push(`bioPctBands.${key}`);
        }
      });
      DEBUG_STATE.lastMissingBioBands = missingBioBands;
      if(missingBioBands.length){
        addWarning(`Missing biomass uncertainty bands for: ${missingBioBands.join(', ')}`);
      }
      const bioBandRanges = {
        hetero_g: sanitizeBand(mc.q.bioBands?.hetero_g, baseSim.biomass.hetero_g, 'bio:hetero_g'),
        phyto_g: sanitizeBand(mc.q.bioBands?.phyto_g, baseSim.biomass.phyto_g, 'bio:phyto_g')
      };
      const bioPctBandRanges = {
        hetero_pct: sanitizeBand(mc.q.bioPctBands?.hetero_pct, baseSim.biomass.hetero_pct, 'bio:hetero_pct'),
        phyto_pct: sanitizeBand(mc.q.bioPctBands?.phyto_pct, baseSim.biomass.phyto_pct, 'bio:phyto_pct')
      };
      bandDiagnostics.bioInvalid += bioBandRanges.hetero_g.invalid + bioBandRanges.phyto_g.invalid + bioPctBandRanges.hetero_pct.invalid + bioPctBandRanges.phyto_pct.invalid;
      bandDiagnostics.bioInverted += bioBandRanges.hetero_g.inverted + bioBandRanges.phyto_g.inverted + bioPctBandRanges.hetero_pct.inverted + bioPctBandRanges.phyto_pct.inverted;
      bioGeom = drawBiomassPlot(el('bioCanvas'), baseSim, {
        bioBands: {
          hetero_g: bioBandRanges.hetero_g.band,
          phyto_g: bioBandRanges.phyto_g.band
        },
        bioPctBands: {
          hetero_pct: bioPctBandRanges.hetero_pct.band,
          phyto_pct: bioPctBandRanges.phyto_pct.band
        }
      });
      DEBUG_STATE.lastBandDiagnostics = bandDiagnostics;

      setStage('Flags', 'evaluate');
      setFlags(baseSim, params, mc);

      // Debug (human-readable summary + machine snapshot)
      const dbg = [];
      dbg.push(`Mode: Uncertainty (Monte Carlo)`);
      dbg.push(`Runs: ${mc.scalars.runs}, band: ${params.bandPreset}, level: ${params.uncLevel}`);
      dbg.push(`What varies: air=${params.u.air}, diffuser=${params.u.diff}, surface=${params.u.surf}, cover=${params.u.tight}, bio=${params.u.bio}, temp=${params.u.temp}, initDO=${params.u.initDO}`);
      dbg.push(`Pressure @ altitude: ${pressureFromAltitude_kPa(params.altM).toFixed(2)} kPa`);
      dbg.push(`Base O2 in pumped air (rated flow): ${oxy.O2_in_air_g_day.toFixed(2)} g/day`);
      dbg.push(`Base bubble eff fraction: ${(100*oxy.eff_bubble).toFixed(2)}%  (depth ${params.diffDepthCm.toFixed(1)} cm, SOTE/m ${params.sotePerM.toFixed(2)}%)`);
      dbg.push(`Surface areas: total ${oxy.areas.A_total.toFixed(4)} m¬≤; open ${oxy.areas.A_open.toFixed(4)}; covered ${oxy.areas.A_cov.toFixed(4)}`);
      dbg.push(`Cover leak factor (base): ${oxy.leak.toFixed(3)} (tight=${params.tight.toFixed(2)}, headspace ${oxy.head.V_head_L.toFixed(1)} L)`);
      dbg.push(`Base OTR surface max: ${oxy.OTR_surface_max.toFixed(3)} g/day  (kCalm ${params.kCalm}, kRipple ${params.kRipple}, ripple ${params.ripplePct}%)`);
      dbg.push(`Base OTR bubble max: ${oxy.OTR_bubble_max.toFixed(3)} g/day`);
      dbg.push(`Base OTR max: ${oxy.OTR_max.toFixed(3)} g/day`);
      dbg.push(`Base kLa inferred: ${oxy.kLa.toFixed(4)} 1/day`);
      dbg.push(`Sim dt: ${baseSim.meta.dt.toFixed(4)} days (~${(baseSim.meta.dt*24).toFixed(2)} h)`);
      dbg.push(`Feed mass: start ${baseSim.meta.feedStart.toFixed(3)} g ‚Üí end ${baseSim.meta.feedEnd.toFixed(3)} g`);
      if(baseSim.meta.feedPulse){
        dbg.push(`Feed pulse: ${baseSim.meta.feedPulse.windowHours}h window ‚Ä¢ ${baseSim.meta.feedPulse.windowSteps} steps ‚Ä¢ ${baseSim.meta.feedPulse.totalPellets} pellets, ${baseSim.meta.feedPulse.totalPowder_g.toFixed(2)} g powder`);
      }
      dbg.push(`Rate peaks: demand ${baseSim.meta.maxDemand.toFixed(3)} g/day ‚Ä¢ supply ${baseSim.meta.maxSupply.toFixed(3)} g/day`);
      dbg.push('Metabolism mode: grazing-linked heterotrophs + photosynthesis (modernized kinetics)');
      dbg.push(`Biofilm: ${params.biofilmMm} mm ‚Ä¢ mass ${baseSim.meta.biofilmMass_g.toFixed(2)} g ‚Ä¢ mult ${baseSim.meta.biofilmMult.toFixed(2)} ‚Ä¢ slowFrac ${params.slowFrac}`);
      if(baseSim.meta.tempSmoothRange){
        dbg.push(`Temp smoothing: œÑ=${baseSim.meta.tempTauHours}h, smooth ${baseSim.meta.tempSmoothRange.min.toFixed(2)}‚Äì${baseSim.meta.tempSmoothRange.max.toFixed(2)}¬∞C (target ${baseSim.meta.tempSmoothRange.targetMin.toFixed(2)}‚Äì${baseSim.meta.tempSmoothRange.targetMax.toFixed(2)}¬∞C)`);
      }
      if(baseSim.meta.heteroGrowthTotal != null || baseSim.meta.phytoGrowthTotal != null){
        dbg.push(`Biomass totals: hetero +${(baseSim.meta.heteroGrowthTotal ?? 0).toFixed(2)} g (consumed ${(baseSim.meta.heteroConsumedTotal ?? 0).toFixed(2)} g), phyto +${(baseSim.meta.phytoGrowthTotal ?? 0).toFixed(2)} g (consumed ${(baseSim.meta.phytoConsumedTotal ?? 0).toFixed(2)} g)`);
      }
      if(baseSim.meta.phytoAlgae_g != null || baseSim.meta.biofilm_g != null){
        const phytoTotal = (baseSim.meta.phytoAlgae_g ?? 0) + (baseSim.meta.phytoPlankton_g ?? 0) + (baseSim.meta.phytoPlants_g ?? 0);
        const heteroTotal = (baseSim.meta.biofilm_g ?? 0) + (baseSim.meta.predator_g ?? 0);
        const phytoDenom = phytoTotal > 1e-9 ? phytoTotal : 1;
        const heteroDenom = heteroTotal > 1e-9 ? heteroTotal : 1;
        dbg.push(`Phyto split: algae ${(baseSim.meta.phytoAlgae_g ?? 0).toFixed(2)} g (${(100*(baseSim.meta.phytoAlgae_g ?? 0)/phytoDenom).toFixed(1)}%), plankton ${(baseSim.meta.phytoPlankton_g ?? 0).toFixed(2)} g (${(100*(baseSim.meta.phytoPlankton_g ?? 0)/phytoDenom).toFixed(1)}%), plants ${(baseSim.meta.phytoPlants_g ?? 0).toFixed(2)} g (${(100*(baseSim.meta.phytoPlants_g ?? 0)/phytoDenom).toFixed(1)}%)`);
        dbg.push(`Hetero split: biofilm ${(baseSim.meta.biofilm_g ?? 0).toFixed(2)} g (${(100*(baseSim.meta.biofilm_g ?? 0)/heteroDenom).toFixed(1)}%), predator ${(baseSim.meta.predator_g ?? 0).toFixed(2)} g (${(100*(baseSim.meta.predator_g ?? 0)/heteroDenom).toFixed(1)}%)`);
      }
      if(baseSim.meta.biomassExtinction){
        dbg.push(`Biomass extinctions: hetero ${baseSim.meta.biomassExtinction.heteroHits} steps, phyto ${baseSim.meta.biomassExtinction.phytoHits} steps ‚Ä¢ algae ${baseSim.meta.biomassExtinction.phytoAlgaeHits} ‚Ä¢ plankton ${baseSim.meta.biomassExtinction.phytoPlanktonHits} ‚Ä¢ plants ${baseSim.meta.biomassExtinction.phytoPlantsHits} ‚Ä¢ biofilm ${baseSim.meta.biomassExtinction.biofilmHits} ‚Ä¢ predator ${baseSim.meta.biomassExtinction.predatorHits}`);
      }
      dbg.push(`Grazing limits: biofilm ${baseSim.meta.grazingLimitedSteps ?? 0} steps ‚Ä¢ max ${(baseSim.meta.biofilmGrazingMax_g_g_day ?? 0).toFixed(2)} g/g/day; predator ${baseSim.meta.predatorGrazingLimitedSteps ?? 0} steps ‚Ä¢ max ${(baseSim.meta.predatorGrazingMax_g_g_day ?? 0).toFixed(2)} g/g/day`);
      dbg.push(`Phyto reserve: built ${baseSim.meta.phytoReserveBuilt.toFixed(2)} g ‚Ä¢ used ${baseSim.meta.phytoReserveUsed.toFixed(2)} g ‚Ä¢ night growth ${baseSim.meta.phytoNightGrowthTotal.toFixed(2)} g`);
      dbg.push(`Phyto recruitment: ${(baseSim.meta.phytoRecruitTotal ?? 0).toFixed(2)} g ‚Ä¢ refugia ${baseSim.meta.phytoRefugiaFrac.toFixed(2)} ‚Ä¢ grazing shield min ${(baseSim.meta.grazingShieldMin ?? 0).toFixed(2)} ‚Ä¢ predator shield min ${(baseSim.meta.predatorShieldMin ?? 0).toFixed(2)}`);
      dbg.push('Biomass dynamics:');
      dbg.push(`  CO2 free ${(baseSim.meta.co2FreeLast_mgL ?? 0).toFixed(2)} mg/L ‚Ä¢ buffer capacity ${(baseSim.meta.bufferCapacityLast ?? 0).toFixed(2)} ‚Ä¢ phyto store fill ${((baseSim.meta.phytoStoreFillPct ?? 0) * 100).toFixed(1)}%`);
      dbg.push(`  refuge fraction ${(baseSim.meta.refugeFractionLast ?? 0).toFixed(2)} ‚Ä¢ biofilm activity ${(baseSim.meta.biofilmActivityLast ?? 0).toFixed(2)} ‚Ä¢ predator activity ${(baseSim.meta.predatorActivityLast ?? 0).toFixed(2)}`);
      dbg.push(`  lagged grazing: biofilm ${(baseSim.meta.laggedBiofilmConsumptionTotal ?? 0).toFixed(2)} g ‚Ä¢ predator ${(baseSim.meta.laggedPredatorConsumptionTotal ?? 0).toFixed(2)} g`);
      dbg.push(`O2 degassed: ${(baseSim.meta.oxygenDegassed_g ?? 0).toFixed(3)} g (steps ${baseSim.meta.oxygenDegasSteps ?? 0})`);
      dbg.push(`CO2 init: ${(baseSim.meta.co2Init_mgL ?? 0).toFixed(2)} mg/L ‚Ä¢ sat ${(baseSim.meta.co2Sat_mgL ?? 0).toFixed(2)} mg/L ‚Ä¢ zero hits ${baseSim.meta.co2ZeroHits ?? 0} ‚Ä¢ degas ${baseSim.meta.co2DegasSteps ?? 0} ‚Ä¢ air in ${(baseSim.meta.co2AirIn_g ?? 0).toFixed(2)} g ‚Ä¢ air out ${(baseSim.meta.co2AirOut_g ?? 0).toFixed(2)} g`);
      dbg.push(`Denit: k=${params.kDenit} 1/day ‚Ä¢ cap=${params.denitCap}`);
      dbg.push(`Heterotroph mass: ${params.heteroMass} g (base ${FISH_MODEL.o2_mg_g_day_base} mg/g/day @ ${FISH_MODEL.refTempC}¬∞C)`);
      dbg.push(`Photosynthetic mass: ${params.photoMass} g (peak ${PHOTO_MODEL.o2_mg_g_day_peak} mg/g/day)`);
      dbg.push(`Diurnal: tempAmp ${params.tempAmp}¬∞C ‚Ä¢ lights @ ${params.lightHour}:00`);
      dbg.push(`Feed profile: ${FEED_PROFILE.name}`);
      dbg.push(`Chem display: ${chemMode}`);
      dbg.push(`N units: ${params.nUnits} ‚Ä¢ pH=${params.pH} ‚Ä¢ NH3 frac=${nh3Fraction(params.pH ?? 7.0, params.Tnow).toFixed(3)}`);
      if(DEBUG_STATE.lastBandDiagnostics){
        dbg.push(`Band sanitation: rate invalid ${DEBUG_STATE.lastBandDiagnostics.rateInvalid} (inverted ${DEBUG_STATE.lastBandDiagnostics.rateInverted}), chem invalid ${DEBUG_STATE.lastBandDiagnostics.chemInvalid} (inverted ${DEBUG_STATE.lastBandDiagnostics.chemInverted}), bio invalid ${DEBUG_STATE.lastBandDiagnostics.bioInvalid} (inverted ${DEBUG_STATE.lastBandDiagnostics.bioInverted}), DO invalid ${DEBUG_STATE.lastBandDiagnostics.doInvalid} (inverted ${DEBUG_STATE.lastBandDiagnostics.doInverted})`);
      }
      dbg.push('');
      dbg.push('--- Snapshot ---');
      dbg.push(...buildDebugSnapshot([]));
      setDebugText(dbg);

    }else{
      setStage('Mode', 'deterministic single run');

      // Deterministic (single)
      setText('cStarOut', `${oxy.Cstar.toFixed(2)} mg/L`);
      setText('otrOut', `${oxy.OTR_max.toFixed(2)} g/day`);
      setText('klaOut', `${oxy.kLa.toFixed(3)} 1/day`);

      // Min DO display
      let doMinValue = Infinity;
      let doMinDay = 0;
      for(let i=0;i<baseSim.DO_mgL.length;i++){
        if(baseSim.DO_mgL[i] < doMinValue){ doMinValue = baseSim.DO_mgL[i]; doMinDay = baseSim.t[i]; }
      }
      el('doMinOut').textContent = `${doMinValue.toFixed(2)} mg/L @ day ${doMinDay.toFixed(2)}`;
      el('pUnder2Out').textContent = '‚Äî';
      el('pUnder1Out').textContent = '‚Äî';

      const nFactorNH4 = params.nUnits === 'asIon' ? CHEM.NH4_ion_per_N : 1;
      const nFactorNO2 = params.nUnits === 'asIon' ? CHEM.NO2_ion_per_N : 1;
      const nFactorNO3 = params.nUnits === 'asIon' ? CHEM.NO3_ion_per_N : 1;
      const nh4Peak = Math.max(...baseSim.NH4_mgL) * nFactorNH4;
      const no2Peak = Math.max(...baseSim.NO2_mgL) * nFactorNO2;
      const no3Peak = Math.max(...baseSim.NO3_mgL) * nFactorNO3;
      const nh3Peak = Math.max(...baseSim.NH3_mgL);
      const co2Peak = Math.max(...baseSim.CO2_mgL);
      const macroPeak = Math.max(...baseSim.macro_mgL);
      const microPeak = Math.max(...baseSim.micro_mgL);
      setText('nh4Out', `${nh4Peak.toFixed(3)} mg/L`);
      setText('no2Out', `${no2Peak.toFixed(3)} mg/L`);
      setText('no3Out', `${no3Peak.toFixed(3)} mg/L`);
      setText('nh3Out', `${nh3Peak.toFixed(3)} mg/L`);
      setText('co2Out', `${co2Peak.toFixed(2)} mg/L`);
      setText('nutrOut', `${macroPeak.toFixed(2)} mg/L ‚Ä¢ ${microPeak.toFixed(2)} mg/L`);

      // Draw plots
      setStage('Plots', 'rate');
      rateGeom = drawPlot(el('rateCanvas'), baseSim.t, baseSim.rate, {
        title:"Oxygen RATE (g O‚ÇÇ/day)",
        fitYMax: true,
        bandPattern: false
      });
      setStage('Plots', 'dissolved oxygen');
      doGeom   = drawDOPlot(el('doCanvas'), baseSim);
      setStage('Plots', 'chemistry');
      const chemSeries = resolveChemSeries(baseSim, chemMode);
      chemGeom  = drawPlot(el('chemCanvas'),  baseSim.t, chemSeries.series,  {
        title:`Chemistry / Compounds (mg/L) ${chemSeries.titleSuffix}`,
        series: CHEM_SERIES,
        visible: visibleChem
      });

      setStage('Plots', 'biomass');
      bioGeom = drawBiomassPlot(el('bioCanvas'), baseSim);

      // Flags
      setStage('Flags', 'evaluate');
      setFlags(baseSim, params, null);

      // Debug text
      const dbg = [];
      dbg.push(`Mode: Single run (deterministic)`);
      dbg.push(`Pressure @ altitude: ${pressureFromAltitude_kPa(params.altM).toFixed(2)} kPa`);
      dbg.push(`O2 in pumped air: ${oxy.O2_in_air_g_day.toFixed(2)} g O2/day`);
      dbg.push(`Bubble eff fraction: ${(100*oxy.eff_bubble).toFixed(2)}%  (depth ${params.diffDepthCm.toFixed(1)} cm, SOTE/m ${params.sotePerM.toFixed(2)}%)`);
      dbg.push(`Surface areas: total ${oxy.areas.A_total.toFixed(4)} m¬≤; open ${oxy.areas.A_open.toFixed(4)}; covered ${oxy.areas.A_cov.toFixed(4)}`);
      dbg.push(`Cover leak factor: ${oxy.leak.toFixed(3)}  (tight ${params.tight.toFixed(2)}, headspace ${oxy.head.V_head_L.toFixed(1)} L)`);
      dbg.push(`OTR surface max: ${oxy.OTR_surface_max.toFixed(3)} g/day  (kCalm ${params.kCalm}, kRipple ${params.kRipple}, ripple ${params.ripplePct}%)`);
      dbg.push(`OTR bubble max: ${oxy.OTR_bubble_max.toFixed(3)} g/day`);
      dbg.push(`OTR max: ${oxy.OTR_max.toFixed(3)} g/day`);
      dbg.push(`kLa inferred: ${oxy.kLa.toFixed(4)} 1/day`);
      dbg.push(`Sim dt: ${baseSim.meta.dt.toFixed(4)} days (~${(baseSim.meta.dt*24).toFixed(2)} h)`);
      dbg.push(`Feed mass: start ${baseSim.meta.feedStart.toFixed(3)} g ‚Üí end ${baseSim.meta.feedEnd.toFixed(3)} g`);
      if(baseSim.meta.feedPulse){
        dbg.push(`Feed pulse: ${baseSim.meta.feedPulse.windowHours}h window ‚Ä¢ ${baseSim.meta.feedPulse.windowSteps} steps ‚Ä¢ ${baseSim.meta.feedPulse.totalPellets} pellets, ${baseSim.meta.feedPulse.totalPowder_g.toFixed(2)} g powder`);
      }
      dbg.push(`Rate peaks: demand ${baseSim.meta.maxDemand.toFixed(3)} g/day ‚Ä¢ supply ${baseSim.meta.maxSupply.toFixed(3)} g/day`);
      dbg.push('Metabolism mode: grazing-linked heterotrophs + photosynthesis (modernized kinetics)');
      dbg.push(`Biofilm: ${params.biofilmMm} mm ‚Ä¢ mass ${baseSim.meta.biofilmMass_g.toFixed(2)} g ‚Ä¢ mult ${baseSim.meta.biofilmMult.toFixed(2)} ‚Ä¢ slowFrac ${params.slowFrac}`);
      if(baseSim.meta.tempSmoothRange){
        dbg.push(`Temp smoothing: œÑ=${baseSim.meta.tempTauHours}h, smooth ${baseSim.meta.tempSmoothRange.min.toFixed(2)}‚Äì${baseSim.meta.tempSmoothRange.max.toFixed(2)}¬∞C (target ${baseSim.meta.tempSmoothRange.targetMin.toFixed(2)}‚Äì${baseSim.meta.tempSmoothRange.targetMax.toFixed(2)}¬∞C)`);
      }
      if(baseSim.meta.heteroGrowthTotal != null || baseSim.meta.phytoGrowthTotal != null){
        dbg.push(`Biomass totals: hetero +${(baseSim.meta.heteroGrowthTotal ?? 0).toFixed(2)} g (consumed ${(baseSim.meta.heteroConsumedTotal ?? 0).toFixed(2)} g), phyto +${(baseSim.meta.phytoGrowthTotal ?? 0).toFixed(2)} g (consumed ${(baseSim.meta.phytoConsumedTotal ?? 0).toFixed(2)} g)`);
      }
      if(baseSim.meta.phytoAlgae_g != null || baseSim.meta.biofilm_g != null){
        const phytoTotal = (baseSim.meta.phytoAlgae_g ?? 0) + (baseSim.meta.phytoPlankton_g ?? 0) + (baseSim.meta.phytoPlants_g ?? 0);
        const heteroTotal = (baseSim.meta.biofilm_g ?? 0) + (baseSim.meta.predator_g ?? 0);
        const phytoDenom = phytoTotal > 1e-9 ? phytoTotal : 1;
        const heteroDenom = heteroTotal > 1e-9 ? heteroTotal : 1;
        dbg.push(`Phyto split: algae ${(baseSim.meta.phytoAlgae_g ?? 0).toFixed(2)} g (${(100*(baseSim.meta.phytoAlgae_g ?? 0)/phytoDenom).toFixed(1)}%), plankton ${(baseSim.meta.phytoPlankton_g ?? 0).toFixed(2)} g (${(100*(baseSim.meta.phytoPlankton_g ?? 0)/phytoDenom).toFixed(1)}%), plants ${(baseSim.meta.phytoPlants_g ?? 0).toFixed(2)} g (${(100*(baseSim.meta.phytoPlants_g ?? 0)/phytoDenom).toFixed(1)}%)`);
        dbg.push(`Hetero split: biofilm ${(baseSim.meta.biofilm_g ?? 0).toFixed(2)} g (${(100*(baseSim.meta.biofilm_g ?? 0)/heteroDenom).toFixed(1)}%), predator ${(baseSim.meta.predator_g ?? 0).toFixed(2)} g (${(100*(baseSim.meta.predator_g ?? 0)/heteroDenom).toFixed(1)}%)`);
      }
      if(baseSim.meta.biomassExtinction){
        dbg.push(`Biomass extinctions: hetero ${baseSim.meta.biomassExtinction.heteroHits} steps, phyto ${baseSim.meta.biomassExtinction.phytoHits} steps ‚Ä¢ algae ${baseSim.meta.biomassExtinction.phytoAlgaeHits} ‚Ä¢ plankton ${baseSim.meta.biomassExtinction.phytoPlanktonHits} ‚Ä¢ plants ${baseSim.meta.biomassExtinction.phytoPlantsHits} ‚Ä¢ biofilm ${baseSim.meta.biomassExtinction.biofilmHits} ‚Ä¢ predator ${baseSim.meta.biomassExtinction.predatorHits}`);
      }
      dbg.push(`Grazing limits: biofilm ${baseSim.meta.grazingLimitedSteps ?? 0} steps ‚Ä¢ max ${(baseSim.meta.biofilmGrazingMax_g_g_day ?? 0).toFixed(2)} g/g/day; predator ${baseSim.meta.predatorGrazingLimitedSteps ?? 0} steps ‚Ä¢ max ${(baseSim.meta.predatorGrazingMax_g_g_day ?? 0).toFixed(2)} g/g/day`);
      dbg.push(`Phyto reserve: built ${baseSim.meta.phytoReserveBuilt.toFixed(2)} g ‚Ä¢ used ${baseSim.meta.phytoReserveUsed.toFixed(2)} g ‚Ä¢ night growth ${baseSim.meta.phytoNightGrowthTotal.toFixed(2)} g`);
      dbg.push(`Phyto recruitment: ${(baseSim.meta.phytoRecruitTotal ?? 0).toFixed(2)} g ‚Ä¢ refugia ${baseSim.meta.phytoRefugiaFrac.toFixed(2)} ‚Ä¢ grazing shield min ${(baseSim.meta.grazingShieldMin ?? 0).toFixed(2)} ‚Ä¢ predator shield min ${(baseSim.meta.predatorShieldMin ?? 0).toFixed(2)}`);
      dbg.push('Biomass dynamics:');
      dbg.push(`  CO2 free ${(baseSim.meta.co2FreeLast_mgL ?? 0).toFixed(2)} mg/L ‚Ä¢ buffer capacity ${(baseSim.meta.bufferCapacityLast ?? 0).toFixed(2)} ‚Ä¢ phyto store fill ${((baseSim.meta.phytoStoreFillPct ?? 0) * 100).toFixed(1)}%`);
      dbg.push(`  refuge fraction ${(baseSim.meta.refugeFractionLast ?? 0).toFixed(2)} ‚Ä¢ biofilm activity ${(baseSim.meta.biofilmActivityLast ?? 0).toFixed(2)} ‚Ä¢ predator activity ${(baseSim.meta.predatorActivityLast ?? 0).toFixed(2)}`);
      dbg.push(`  lagged grazing: biofilm ${(baseSim.meta.laggedBiofilmConsumptionTotal ?? 0).toFixed(2)} g ‚Ä¢ predator ${(baseSim.meta.laggedPredatorConsumptionTotal ?? 0).toFixed(2)} g`);
      dbg.push(`O2 degassed: ${(baseSim.meta.oxygenDegassed_g ?? 0).toFixed(3)} g (steps ${baseSim.meta.oxygenDegasSteps ?? 0})`);
      dbg.push(`CO2 init: ${(baseSim.meta.co2Init_mgL ?? 0).toFixed(2)} mg/L ‚Ä¢ sat ${(baseSim.meta.co2Sat_mgL ?? 0).toFixed(2)} mg/L ‚Ä¢ zero hits ${baseSim.meta.co2ZeroHits ?? 0} ‚Ä¢ degas ${baseSim.meta.co2DegasSteps ?? 0} ‚Ä¢ air in ${(baseSim.meta.co2AirIn_g ?? 0).toFixed(2)} g ‚Ä¢ air out ${(baseSim.meta.co2AirOut_g ?? 0).toFixed(2)} g`);
      dbg.push(`Denit: k=${params.kDenit} 1/day ‚Ä¢ cap=${params.denitCap}`);
      dbg.push(`Heterotroph mass: ${params.heteroMass} g (base ${FISH_MODEL.o2_mg_g_day_base} mg/g/day @ ${FISH_MODEL.refTempC}¬∞C)`);
      dbg.push(`Photosynthetic mass: ${params.photoMass} g (peak ${PHOTO_MODEL.o2_mg_g_day_peak} mg/g/day)`);
      dbg.push(`Diurnal: tempAmp ${params.tempAmp}¬∞C ‚Ä¢ lights @ ${params.lightHour}:00`);
      dbg.push(`Feed profile: ${FEED_PROFILE.name}`);
      dbg.push(`Chem display: ${chemMode}`);
      dbg.push(`N units: ${params.nUnits} ‚Ä¢ pH=${params.pH} ‚Ä¢ NH3 frac=${nh3Fraction(params.pH ?? 7.0, params.Tnow).toFixed(3)}`);
      dbg.push('');
      dbg.push('--- Snapshot ---');
      dbg.push(...buildDebugSnapshot([]));
      setDebugText(dbg);
    }

    const auditEl = el('chemAudit');
    const auditDetails = el('chemAuditDetails');
    if(auditEl && auditDetails){
      const showAudit = !!params.chemNerd;
      auditDetails.style.display = showAudit ? 'block' : 'none';
      auditDetails.open = showAudit;
      if(showAudit){
        const a = baseSim.audit;
        const lines = [
          `NH‚ÇÑ from protein oxidation: ${(a.nh4_from_pro*1000/params.volL).toFixed(3)} mg/L as N`,
          `NH‚ÇÑ from biomass turnover: ${(a.nh4_from_endog*1000/params.volL).toFixed(3)} mg/L as N`,
          `NH‚ÇÑ ‚Üí NO‚ÇÇ consumed: ${(a.nh4_to_no2*1000/params.volL).toFixed(3)} mg/L as N`,
          `NO‚ÇÇ ‚Üí NO‚ÇÉ consumed: ${(a.no2_to_no3*1000/params.volL).toFixed(3)} mg/L as N`,
          `NO‚ÇÉ ‚Üí N‚ÇÇ (denit): ${(a.no3_to_n2*1000/params.volL).toFixed(3)} mg/L as N`,
          `CO‚ÇÇ from oxidation: ${(a.co2_from_ox*1000/params.volL).toFixed(2)} mg/L`,
          `CO‚ÇÇ from endogenous: ${(a.co2_from_endog*1000/params.volL).toFixed(2)} mg/L`,
          `CO‚ÇÇ from denit: ${(a.co2_from_denit*1000/params.volL).toFixed(2)} mg/L`,
          `Macros released: ${(a.macro_release*1000/params.volL).toFixed(2)} mg/L`,
          `Macros uptake: ${(a.macro_uptake*1000/params.volL).toFixed(2)} mg/L`,
          `Micros released: ${(a.micro_release*1000/params.volL).toFixed(2)} mg/L`,
          `Micros uptake: ${(a.micro_uptake*1000/params.volL).toFixed(2)} mg/L`,
          `N balance: ${(a.n_balance_end*1000/params.volL).toFixed(3)} mg/L as N (initial ${(a.n_balance_init*1000/params.volL).toFixed(3)})`,
          `C balance: ${(a.c_balance_end*1000/params.volL).toFixed(2)} mg/L (initial ${(a.c_balance_init*1000/params.volL).toFixed(2)})`
        ];
        auditEl.textContent = lines.join('\n');
      }
    }

    setStage('Interactions', 'init canvases');
    initCanvasInteractions();

    setRecomputeBubbleState(false);
    setStage('recompute', 'done');
    DEBUG_STATE.lastRecomputeMs = performance.now() - recomputeStart;
    if(DEBUG_STATE.lastRecomputeMs > 800){
      addWarning(`Recompute took ${DEBUG_STATE.lastRecomputeMs.toFixed(0)} ms. Consider reducing Monte Carlo runs or disabling live recompute.`);
    }

  }catch(err){
    setStage('recompute', 'error');
    setRecomputeBubbleState(false);
    addWarning(`Recompute failed: ${err?.message || err}`);
    console.warn('Recompute failed:', err);
    showError(err);
  }
}

function applyDiffuserPreset(){
  const t = el('diffType').value;
  const s = el('sotePerM');
  let v = null;

  // ‚ÄúReasonable starting points‚Äù. Real SOTE depends a lot on bubble size, contact time, and circulation.
  if(t === 'airstone_med')      v = 2.5;
  else if(t === 'airstone_fine')v = 3.5;
  else if(t === 'microbubble') v = 5.5;
  else if(t === 'wood')        v = 4.5;

  if(v !== null){
    s.value = v;
    s.disabled = true;
    s.title = 'Preset value. Choose Custom to edit.';
  }else{
    s.disabled = false;
    s.title = '';
  }
}

function applySurfacePreset(){
  const t = el('surfacePreset').value;
  const kc = el('kCalm');
  const kr = el('kRipple');
  let v = null;

  if(t === 'still')        v = {kCalm:0.15, kRipple:0.45};
  else if(t === 'typical') v = {kCalm:0.30, kRipple:1.00};
  else if(t === 'rippling')v = {kCalm:0.45, kRipple:1.60};
  else if(t === 'splashy') v = {kCalm:0.70, kRipple:2.50};

  if(v){
    kc.value = v.kCalm;
    kr.value = v.kRipple;
    kc.disabled = true; kr.disabled = true;
    kc.title = 'Preset value. Choose Custom to edit.';
    kr.title = 'Preset value. Choose Custom to edit.';
  }else{
    kc.disabled = false; kr.disabled = false;
    kc.title = ''; kr.title = '';
  }
}

function applyTightPreset(){
  const t = el('tightPreset').value;
  const ti = el('tight');
  let v = null;

  if(t === 'open')        v = 0.00;
  else if(t === 'loose_high') v = 0.15;
  else if(t === 'typical')    v = 0.35;
  else if(t === 'near_sealed')v = 0.80;

  if(v !== null){
    ti.value = v;
    ti.disabled = true;
    ti.title = 'Preset value. Choose Custom to edit.';
  }else{
    ti.disabled = false;
    ti.title = '';
  }
}

function applyOtrPreset(){
  const t = el('otrPreset').value;
  const o = el('otrCal');
  let v = null;
  if(t === 'typical') v = 1.00;
  else if(t === 'under') v = 0.75;
  else if(t === 'over') v = 1.25;

  if(v !== null){
    o.value = v;
    o.disabled = true;
    o.title = 'Preset value. Choose Custom to edit.';
  }else{
    o.disabled = false;
    o.title = '';
  }
}

function applyInitDOPreset(){
  const t = el('initDOPreset').value;
  const d = el('doInitPct');
  if(t !== 'custom'){
    d.value = Number(t);
    d.disabled = true;
    d.title = 'Preset value. Choose Custom to edit.';
  }else{
    d.disabled = false;
    d.title = '';
  }
}

function applyAllPresets(){
  // These keep the ‚Äúhuman presets‚Äù and the numeric fields in sync.
  if(el('diffType')) applyDiffuserPreset();
  if(el('surfacePreset')) applySurfacePreset();
  if(el('tightPreset')) applyTightPreset();
  if(el('otrPreset')) applyOtrPreset();
  if(el('initDOPreset')) applyInitDOPreset();
}


/* =========================================================
   Init
========================================================= */
let debounceTimerId = null;
function scheduleRecompute(){
  const mode = el('liveRecompute') ? el('liveRecompute').value : 'on';
  if(mode === 'off'){
    if(el('recomputeBtn')) el('recomputeBtn').style.display = 'inline-block';
    DEBUG_STATE.debounceQueued = 0;
    DEBUG_STATE.debounceMs = null;
    return;
  }
  if(el('recomputeBtn')) el('recomputeBtn').style.display = 'none';
  const debounceDelayMs = 1000;
  DEBUG_STATE.debounceMs = debounceDelayMs;
  if(debounceTimerId !== null){
    DEBUG_STATE.debounceQueued = (DEBUG_STATE.debounceQueued || 0) + 1;
  }else{
    DEBUG_STATE.debounceQueued = 1;
  }
  clearTimeout(debounceTimerId);
  debounceTimerId = setTimeout(()=>{
    DEBUG_STATE.debounceQueued = 0;
    recompute();
  }, debounceDelayMs);
}

function updateModeUI(){
  if(!el('runMode')) return;
  const mode = el('runMode').value;
  if(el('uncSection')) el('uncSection').style.display = (mode === 'uncertainty') ? 'block' : 'none';
  if(el('singleNote')) el('singleNote').style.display = (mode === 'single') ? 'block' : 'none';
}

function init(){
  installGlobalErrorHandlers();
  ensureFeedProfileMemory();
  loadState();
  try{ applyAllPresets(); }catch(_){}

  updateModeUI();
  setDebugText(buildDebugSnapshot(['Init: handlers ready, awaiting recompute.']));
  wireActiveControlGlow();
  enableDebugCopyRoutine();
  measurePanelOverflow();
  if(!window.__panelOverflowBound){
    window.__panelOverflowBound = true;
    window.addEventListener('resize', ()=>measurePanelOverflow());
  }

  // Link sliders
  linkRangeAndNumber(el('pelMass'), el('pelMassN'), ()=>{ scheduleRecompute(); });
  linkRangeAndNumber(el('powMass'), el('powMassN'), ()=>{ scheduleRecompute(); });
  linkRangeAndNumber(el('blanket'), el('blanketN'), ()=>{ scheduleRecompute(); });
  linkRangeAndNumber(el('days'), el('daysN'), ()=>{ scheduleRecompute(); });

  if(el('mcRunsRange') && el('mcRuns')){
    linkRangeAndNumber(el('mcRunsRange'), el('mcRuns'), ()=>{ scheduleRecompute(); });
  }

  // Inputs that trigger recompute
  [
    'volL','airFlow','Tnow','pH','altM','tds','ripplePct','feedInterval',
    'lenCm','widCm','tankHCm','waterSurfCm','blanketGapCm','diffDepthCm','heaters',
    'sotePerM','kCalm','kRipple','tight','otrCal',
    'doInitPct','kDoNit','kNH4Nit','kNO2Nit','nitCap','nitQ10','nUnits',
    'kDoHet','slowFrac','biofilmMm','kDenit','denitCap','heteroMass','photoMass','tempAmp','lightHour',
    'chemNerd','chemDisplay',
    'pelLen','pelDia','pelRho',
    'diffType','surfacePreset','tightPreset','otrPreset','initDOPreset',
    'runMode','uncLevel','bandPreset','seed','liveRecompute',
    'uAir','uDiff','uSurf','uTight','uBio','uTemp','uInitDO',
    'o2Limit'
  ].forEach(id=>{
    const e = el(id);
    if(!e) return;
    const ev = (e.type === 'checkbox' || e.tagName === 'SELECT') ? 'change' : 'input';
    e.addEventListener(ev, ()=>{
      if(id === 'runMode') updateModeUI();
      // presets need to refresh numeric fields before sim
      if(['diffType','surfacePreset','tightPreset','otrPreset','initDOPreset'].includes(id)){
        try{ applyAllPresets(); }catch(_){}
      }
      scheduleRecompute();
    });
  });

  // Events UI
  const addBtn = el('addEventBtn');
  if(!addBtn){
    addWarning('Missing add-event button (#addEventBtn).');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'addEventBtn', context:'init'});
  }else{
    addBtn.addEventListener('click', ()=>{
    const day = Number(el('evDay').value);
    const pellets = Number(el('evPellets').value);
    const daysMax = Number(el('daysN').value);
    if(!Number.isFinite(day) || !Number.isFinite(pellets)) return;
    const safeDay = clamp(day, 0, Number.isFinite(daysMax) ? daysMax : day);
    const safePel = Math.max(0, Math.round(pellets));
    if(safePel <= 0) return;
    EVENTS.push({day: safeDay, pellets: safePel});
    normalizeEvents();
    saveState();
    renderEvents();
    scheduleRecompute();
    });
  }

  const clearBtn = el('clearEventsBtn');
  if(!clearBtn){
    addWarning('Missing clear-events button (#clearEventsBtn).');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'clearEventsBtn', context:'init'});
  }else{
    clearBtn.addEventListener('click', ()=>{
    EVENTS = [];
    saveState();
    renderEvents();
    scheduleRecompute();
    });
  }

  const recomputeBtn = el('recomputeBtn');
  if(recomputeBtn){
    recomputeBtn.addEventListener('click', ()=>{
      recompute();
      if(el('liveRecompute') && el('liveRecompute').value !== 'off'){
        recomputeBtn.style.display = 'none';
      }
    });
  }

  buildLegendRate();
  buildLegendChem();
  buildLegendBio();
  renderEvents();
  recompute();
}

function boot(){
  DEBUG_STATE.initReadyState = document.readyState;
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, {once:true});
  }else{
    init();
  }
}

boot();

</script>
</body>
</html>
