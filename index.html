<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Aquarium O‚ÇÇ Demand Planner (DO + oxygenation model)</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop stop-color='%237aa2ff'/%3E%3Cstop offset='1' stop-color='%2363e6be'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='14' fill='%230b1020'/%3E%3Cpath d='M32 10c9.5 0 17.2 7.7 17.2 17.2S41.5 50 32 50 14.8 42.3 14.8 32 22.5 10 32 10Z' fill='url(%23g)' fill-opacity='.35'/%3E%3Cpath d='M32 17c7.2 0 13 5.8 13 13s-5.8 13-13 13-13-5.8-13-13 5.8-13 13-13Z' fill='url(%23g)'/%3E%3Cpath d='M31.7 23.5c2.7 4 5.3 7.2 5.3 10.2 0 3-2.4 5.4-5.3 5.4s-5.3-2.4-5.3-5.4c0-3 2.6-6.2 5.3-10.2Z' fill='%230b1020' fill-opacity='.85'/%3E%3C/svg%3E" />
  <style>
    :root{
      --bg:#0b1020; --panel:#111a33; --panel2:#0f1730; --text:#e7ecff; --muted:#a9b3d6;
      --line:#2a3766; --accent:#7aa2ff; --warn:#ffcf5a; --danger:#ff6b6b; --ok:#63e6be;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 15% -10%, rgba(122,162,255,.18), transparent 60%),
        radial-gradient(900px 400px at 90% 0%, rgba(99,230,190,.12), transparent 55%),
        linear-gradient(180deg,#070a14,#0b1020 25%,#0b1020);
      color:var(--text);
      font-family:var(--sans);
      min-height:100vh;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background-image: linear-gradient(rgba(255,255,255,.04) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,.03) 1px, transparent 1px);
      background-size: 42px 42px, 42px 42px;
      opacity:.25;
      z-index:0;
    }
    header{
      padding:18px 20px 14px;
      border-bottom:1px solid rgba(122,162,255,.18);
      position:sticky;
      top:0;
      background:linear-gradient(180deg, rgba(10,15,30,.98), rgba(10,15,30,.92));
      backdrop-filter: blur(12px);
      z-index:10;
    }
    .app-title{
      display:flex;
      align-items:center;
      gap:12px;
    }
    .app-mark{
      width:44px;
      height:44px;
      border-radius:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      background:linear-gradient(140deg, rgba(122,162,255,.28), rgba(99,230,190,.16));
      border:1px solid rgba(122,162,255,.35);
      box-shadow:0 10px 18px rgba(0,0,0,.3);
      font-size:20px;
    }
    header h1{margin:0;font-size:18px;font-weight:700;letter-spacing:.4px}
    .app-subtitle{
      margin:4px 0 0;
      color:rgba(231,236,255,.78);
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
    }
    header p{margin:10px 0 0;color:var(--muted);font-size:12px;max-width:960px;line-height:1.45}
    .wrap{max-width:1280px;margin:0 auto;padding:20px;display:grid;gap:16px;grid-template-columns: 480px 1fr;position:relative;z-index:1;}
    @media (max-width: 1100px){ .wrap{grid-template-columns:1fr;} header{position:static;} }
    .card{
      background:linear-gradient(180deg,rgba(17,26,51,.98),rgba(13,20,44,.96));
      border:1px solid rgba(122,162,255,.16);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:16px;
      backdrop-filter: blur(6px);
    }
    .card h2{margin:0 0 12px;font-size:14px;color:#dfe6ff;text-transform:uppercase;letter-spacing:.12em}
    .left-panel{
      position:relative;
      background:linear-gradient(180deg,rgba(15,22,44,.98),rgba(12,18,38,.97));
    }
    .panel-section{
      position:relative;
      padding:10px 12px 10px 14px;
      border-radius:16px;
      background:linear-gradient(180deg,rgba(12,19,39,.92),rgba(9,14,30,.92));
      border:1px solid rgba(122,162,255,.14);
      box-shadow:0 12px 24px rgba(0,0,0,.28);
      display:grid;
      gap:8px;
      overflow:hidden;
    }
    .panel-section::before{
      content:"";
      position:absolute;
      left:0;
      top:0;
      bottom:0;
      width:4px;
      background:linear-gradient(180deg, rgba(122,162,255,.75), rgba(99,230,190,.35));
      opacity:.7;
    }
    .panel-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding-left:8px;
    }
    .panel-title{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:#dfe6ff;
      font-weight:700;
    }
    .panel-title .icon{
      width:28px;
      height:28px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius:10px;
      background:rgba(122,162,255,.18);
      border:1px solid rgba(122,162,255,.25);
      font-size:13px;
    }
    .panel-sub{
      color:var(--muted);
      font-size:11px;
      line-height:1.45;
      padding-left:8px;
    }
    .panel-badges{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 8px;
      border-radius:999px;
      font-size:10px;
      text-transform:uppercase;
      letter-spacing:.12em;
      border:1px solid transparent;
      background:rgba(122,162,255,.12);
      color:#dfe6ff;
    }
    .badge.warn{background:rgba(255,207,90,.18); border-color:rgba(255,207,90,.35); color:#fff3d1;}
    .badge.ok{background:rgba(99,230,190,.16); border-color:rgba(99,230,190,.35); color:#d5fff1;}
    .badge.note{background:rgba(122,162,255,.2); border-color:rgba(122,162,255,.35);}
    .badge.alert{background:rgba(255,107,107,.18); border-color:rgba(255,107,107,.35); color:#ffd1d1;}
    .panel-divider{height:1px;background:rgba(255,255,255,.08);margin:4px 0}
    .panel-quick{
      display:grid;
      gap:8px;
      padding:8px 10px;
      border-radius:16px;
      background:linear-gradient(140deg, rgba(122,162,255,.16), rgba(99,230,190,.08));
      border:1px solid rgba(122,162,255,.2);
    }
    .panel-quick .row{margin:0}
    .panel-drawer{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:6px 8px;
      background:rgba(0,0,0,.18);
    }
    .panel-drawer summary{font-size:12px;color:#dfe6ff;font-weight:600}
    .panel-drawer .drawer-text{color:var(--muted);font-size:11px;line-height:1.45;margin-top:6px}
    .left-panel .row label{font-size:11px;letter-spacing:.03em}
    .left-panel input[type="number"],
    .left-panel input[type="text"],
    .left-panel select{padding:8px 10px;font-size:12px;border-radius:10px}
    .control-active{
      box-shadow:0 0 0 3px rgba(122,162,255,.18), 0 0 18px rgba(122,162,255,.22);
      border-color:rgba(122,162,255,.6);
    }
    .left-panel .row input[type="range"]{min-width:180px}
    .left-panel .grid2{gap:6px}
    .left-panel .grid3{gap:6px}
    .left-panel .small{font-size:11px}
    .left-panel .note{font-size:11px}
    .panel-section.compact{
      padding:8px 10px 8px 12px;
      gap:6px;
    }
    .panel-section.compact .panel-title{font-size:11px}
    .panel-section.compact .panel-title .icon{width:24px;height:24px;font-size:12px}
    .panel-section.compact .panel-sub{font-size:10px}
    .grid2{display:grid;gap:10px;grid-template-columns:1fr 1fr;}

    .grid3{display:grid;gap:10px;grid-template-columns:1fr 1fr 1fr;}
    .grid4{display:grid;gap:10px;grid-template-columns:1fr 1fr 1fr 1fr;}
    @media (max-width: 900px){
      .grid3{grid-template-columns:1fr 1fr;}
      .grid4{grid-template-columns:1fr 1fr;}
    }
    @media (max-width: 560px){
      .grid3{grid-template-columns:1fr;}
      .grid4{grid-template-columns:1fr;}
    }
    .row{display:flex;gap:12px;align-items:center}
    .row label{flex:1;color:var(--muted);font-size:12px;letter-spacing:.02em}
    input[type="range"]{width:100%}
    input[type="number"], input[type="text"], select{
      background:#0a1024;border:1px solid rgba(122,162,255,.26);color:var(--text);
      border-radius:12px;padding:9px 12px;font-size:13px;outline:none;
      transition:border-color .2s ease, box-shadow .2s ease, transform .2s ease;
    }
    input[type="number"]:focus, input[type="text"]:focus, select:focus{
      border-color:rgba(122,162,255,.55);
      box-shadow:0 0 0 3px rgba(122,162,255,.18);
      transform:translateY(-1px);
    }
    input[type="range"]{accent-color:var(--accent)}
    input[type="number"]{width:120px}
    select{width:100%}
    .small{font-size:12px;color:var(--muted);line-height:1.35}
    .mono{font-family:var(--mono)}
    .pill{
      display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.16); background:rgba(255,255,255,.05); font-size:12px;
    }
    .pill.ok{border-color:rgba(99,230,190,.35);} .pill.warn{border-color:rgba(255,207,90,.45);} .pill.danger{border-color:rgba(255,107,107,.45);}
    .flags{display:grid;gap:12px}
    .flag-card{
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04);
      overflow:hidden;
      box-shadow:var(--shadow);
    }
    .flag-tag{
      padding:6px 12px;
      font-weight:700;
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .flag-tag.ok{background:rgba(99,230,190,.18); color:#d5fff1;}
    .flag-tag.warn{background:rgba(255,207,90,.22); color:#fff3d1;}
    .flag-tag.danger{background:rgba(255,107,107,.22); color:#ffd1d1;}
    .flag-tag.note{background:rgba(122,162,255,.18); color:#dfe6ff;}
    .flag-body{padding:10px 12px;color:var(--text)}
    .tag-stack{display:grid;gap:8px}
    .tag-line{
      border:1px solid rgba(255,255,255,.14);
      border-radius:12px;
      padding:8px 12px;
      background:rgba(0,0,0,.18);
    }
    .tag-line summary{
      display:flex;
      align-items:center;
      gap:10px;
      list-style:none;
      cursor:pointer;
      color:#dfe6ff;
      font-weight:600;
      font-size:13px;
    }
    .tag-line summary::-webkit-details-marker{display:none}
    .tag-line .tag-title{flex:1;min-width:0}
    .tag-line .tag-meta{color:var(--muted);font-weight:500;font-size:12px;white-space:nowrap}
    .tag-line .tag-chip{
      padding:2px 8px;
      border-radius:999px;
      font-size:10px;
      letter-spacing:.08em;
      text-transform:uppercase;
      border:1px solid transparent;
    }
    .tag-line.tone-ok{border-color:rgba(99,230,190,.32)}
    .tag-line.tone-warn{border-color:rgba(255,207,90,.32)}
    .tag-line.tone-danger{border-color:rgba(255,107,107,.32)}
    .tag-line .tag-chip.ok{background:rgba(99,230,190,.18); color:#d5fff1; border-color:rgba(99,230,190,.45)}
    .tag-line .tag-chip.warn{background:rgba(255,207,90,.18); color:#fff3d1; border-color:rgba(255,207,90,.45)}
    .tag-line .tag-chip.danger{background:rgba(255,107,107,.18); color:#ffd1d1; border-color:rgba(255,107,107,.45)}
    .tag-details{margin-top:8px;color:var(--muted);font-size:12px;line-height:1.45}
    .btn{
      background:rgba(122,162,255,.18);
      border:1px solid rgba(122,162,255,.35);
      color:var(--text);
      border-radius:12px;
      padding:9px 12px;
      font-size:13px;
      cursor:pointer;
      user-select:none;
      transition:transform .2s ease, box-shadow .2s ease, background .2s ease;
    }
    .btn:hover{background:rgba(122,162,255,.26);transform:translateY(-1px);box-shadow:0 8px 18px rgba(0,0,0,.25)}
    .btn.danger{border-color:rgba(255,107,107,.55); background:rgba(255,107,107,.12)}
    .btn.danger:hover{background:rgba(255,107,107,.18)}
    .btn.ghost{background:transparent;border-color:rgba(255,255,255,.18)}
    .btn.ghost:hover{background:rgba(255,255,255,.06)}
    details{border:1px solid rgba(255,255,255,.14);border-radius:12px;padding:12px;background:rgba(0,0,0,.16)}
    details summary{cursor:pointer;color:#dfe6ff;font-weight:600;font-size:13px}
    details.panel-drawer{border:1px solid rgba(255,255,255,.12);padding:8px 10px;background:rgba(0,0,0,.18)}
    details.panel-drawer summary{font-size:12px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px 6px;border-bottom:1px solid rgba(255,255,255,.08);font-size:12px;color:var(--muted)}
    tr:nth-child(even) td{background:rgba(255,255,255,.02)}
    th{color:#dfe6ff;text-align:left;font-weight:600}
    td input[type="number"]{width:90px}
    canvas{width:100%;height:300px;border-radius:14px;background:linear-gradient(180deg,#070b18,#070f1d);border:1px solid rgba(255,255,255,.08)}
    .charts{display:grid;gap:12px;grid-template-columns:1fr}
    .legend{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
    .leg{
      display:flex;gap:8px;align-items:center;font-size:12px;color:var(--muted);
      padding:6px 10px;border:1px solid rgba(255,255,255,.12);border-radius:12px;background:rgba(255,255,255,.05);
      cursor:pointer; user-select:none;
    }
    .dot{width:10px;height:10px;border-radius:50%}
    .leg.off{opacity:.35}
    .tooltip{
      position:fixed; pointer-events:none; z-index:99;
      background:rgba(17,26,51,.95); border:1px solid rgba(255,255,255,.14);
      border-radius:12px; padding:10px 12px; box-shadow:var(--shadow);
      font-size:12px; color:var(--text); max-width:360px; display:none;
    }
    .kbd{font-family:var(--mono);font-size:11px;padding:2px 6px;border:1px solid rgba(255,255,255,.16);border-radius:8px;background:rgba(255,255,255,.06);color:#dfe6ff}
    .note{color:var(--muted);font-size:12px;line-height:1.45}
    .footer{margin-top:8px;color:var(--muted);font-size:11px}
    .hr{height:1px;background:rgba(255,255,255,.10);margin:10px 0}
    .errbox{border:1px solid rgba(255,107,107,.35);background:rgba(255,107,107,.08);padding:10px;border-radius:12px;color:#ffd1d1;font-size:12px;display:none}
    .errbox pre{margin:8px 0 0;white-space:pre-wrap;word-break:break-word;color:#ffd1d1}
    .copy-toast{
      font-size:11px;
      color:var(--ok);
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(99,230,190,.35);
      background:rgba(99,230,190,.12);
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .copy-toast.warn{
      color:#fff3d1;
      border-color:rgba(255,207,90,.45);
      background:rgba(255,207,90,.16);
    }
    .calendar-month.expanded .cal-cell{
      min-height:52px;
      font-size:11px;
      padding:6px;
    }
  </style>
</head>
<body>
<header class="app-header">
  <div class="app-title">
    <div class="app-mark">ü´ß</div>
    <div>
      <h1>Aquarium Oxygen Planner</h1>
      <div class="app-subtitle">Demand modeling ¬∑ Oxygenation inference ¬∑ Feeding cadence</div>
    </div>
  </div>
  <p>
    Estimate oxygen demand from feed decomposition and nitrification, then simulate dissolved oxygen with bubble + surface transfer.
    Calibrate with real-world measurements to tighten uncertainty bands over time.
  </p>
</header>

<div class="wrap">
  <div class="card left-panel">
    <div class="panel-quick">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">‚ö°</span>Quick Controls</div>
        <div class="panel-badges">
          <span class="badge note">Most adjusted</span>
        </div>
      </div>

    <div class="row">
      <label>Pellet mass added (as-fed, g)</label>
      <input id="pelMass" type="range" min="0" max="5" step="0.01" value="1.00"/>
      <input id="pelMassN" type="number" min="0" max="50" step="0.01" value="1.00"/>
    </div>

    <div class="row">
      <label>Powder mass added (as-fed, g)</label>
      <input id="powMass" type="range" min="0" max="5" step="0.01" value="0.00"/>
      <input id="powMassN" type="number" min="0" max="50" step="0.01" value="0.00"/>
    </div>

      <div class="row">
        <label>Feeding interval (days)</label>
        <input id="feedInterval" type="number" min="0.25" step="0.25" value="1"/>
      </div>

      <div class="row">
        <label>Blanket cover (%) ‚Äî uncovered = chimney</label>
        <input id="blanket" type="range" min="0" max="100" step="1" value="80"/>
        <input id="blanketN" type="number" min="0" max="100" step="1" value="80"/>
      </div>

      <div class="row">
        <label>Simulation time (days)</label>
        <input id="days" type="range" min="7" max="180" step="1" value="30"/>
        <input id="daysN" type="number" min="1" max="365" step="1" value="30"/>
      </div>
    </div>

    <div class="panel-section" id="uncModeDetails" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üß≠</span>Uncertainty Mode</div>
        <div class="panel-badges">
          <span class="badge warn">Uncertainty Mode</span>
        </div>
      </div>
      <div class="panel-sub">
        Runs multiple plausible realities and shows a confidence band instead of a single line.
      </div>
      <details class="panel-drawer">
        <summary>What this means</summary>
        <div class="drawer-text">
          Default mode: the sim runs many plausible ‚Äúnearby realities‚Äù and shows a band (not a single pretend-precise line).
          Without a real DO measurement, this is the honest way to use the model.
        </div>
      </details>

      <div class="grid2">
        <div class="row">
          <label>Run mode</label>
          <select id="runMode">
            <option value="uncertainty" selected>Uncertainty (recommended)</option>
            <option value="single">Single run (deterministic)</option>
          </select>
        </div>
        <div class="row">
          <label>Uncertainty level</label>
          <select id="uncLevel">
            <option value="tight">Tight (you measured most things)</option>
            <option value="typical" selected>Typical (some guesses)</option>
            <option value="wide">Wide (many guesses)</option>
          </select>
        </div>

        <div class="row">
          <label>Monte Carlo runs</label>
          <input id="mcRunsRange" type="range" min="50" max="800" step="10" value="200"/>
          <input id="mcRuns" type="number" min="10" max="2000" step="10" value="200"/>
        </div>

        <div class="row">
          <label>Band shown</label>
          <select id="bandPreset">
            <option value="10-90" selected>10‚Äì90% (wide)</option>
            <option value="25-75">25‚Äì75% (mid)</option>
            <option value="5-95">5‚Äì95% (very wide)</option>
          </select>
        </div>

        <div class="row">
          <label>Random seed</label>
          <input id="seed" type="number" step="1" value="12345"/>
        </div>
        <div class="row">
          <label>Live recompute</label>
          <select id="liveRecompute">
            <option value="on" selected>On (debounced)</option>
            <option value="off">Off (click Recompute)</option>
          </select>
        </div>
      </div>

      <div>
        <button class="btn" id="recomputeBtn" style="display:none">Recompute</button>
      </div>

      <div class="panel-divider"></div>

      <div class="small"><b>What varies across runs:</b></div>
      <div class="grid2">
        <div class="row"><label><input id="uAir" type="checkbox" checked> Pump delivered airflow</label></div>
        <div class="row"><label><input id="uDiff" type="checkbox" checked> Bubble transfer efficiency</label></div>
        <div class="row"><label><input id="uSurf" type="checkbox" checked> Surface exchange (k values)</label></div>
        <div class="row"><label><input id="uTight" type="checkbox" checked> Blanket ‚Äútightness‚Äù / leakiness</label></div>
        <div class="row"><label><input id="uBio" type="checkbox" checked> Biology speed (microbes, kinetics)</label></div>
        <div class="row"><label><input id="uTemp" type="checkbox" checked> Water temperature</label></div>
        <div class="row"><label><input id="uInitDO" type="checkbox" checked> Initial DO</label></div>
      </div>

      <div class="small" style="margin-top:8px">
        The band is a <b>distribution</b>, not a promise. If you calibrate with real DO data later, the band shrinks and gets less ‚Äúvibes, more physics‚Äù.
      </div>
    </details>



    <div class="hr"></div>

    <h2>Pop events (convert pellets ‚Üí powder)</h2>
    <div class="note">
      Click the <span class="kbd">RATE</span> graph to add an event at that day, or use the table below.
      Each event converts whole pellets into powder at that moment (mass is conserved).
    </div>
    <div class="grid3" style="margin-top:10px">
      <div class="row">
        <label>Event day</label>
        <input id="evDay" type="number" min="0" step="0.1" value="3.0"/>
      </div>
      <div class="row">
        <label>Pellets to pop</label>
        <input id="evPellets" type="number" min="0" step="1" value="10"/>
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn" id="addEventBtn">Add event</button>
      </div>
    </div>
    <div style="margin-top:8px">
      <button class="btn ghost" id="clearEventsBtn">Clear events</button>
    </div>

    <div style="margin-top:10px; max-height:220px; overflow:auto;">
      <table id="eventsTable">
        <thead>
          <tr><th>Day</th><th>Pellets to pop</th><th></th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="panel-section" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üìÖ</span>Feeding Calendar</div>
        <div class="panel-badges">
          <span class="badge ok">Feeding Calendar</span>
        </div>
      </div>
      <details class="panel-drawer">
        <summary>What this means</summary>
        <div class="drawer-text">
          Feeding events add pellets + powder at your chosen interval. Green = feed day, yellow = pellet pop day.
        </div>
      </details>
      <div class="calendar tiles" id="feedCalendar"></div>
    </div>

    <details style="margin-top:12px" open>
      <summary>Advanced assumptions (oxygenation + environment)</summary>

      <div class="grid2" style="margin-top:10px">
        <div class="row">
          <label>Tank water volume (L)</label>
          <input id="volL" type="number" step="0.1" value="65.0"/>
        </div>
        <div class="row">
          <label>Water temp (¬∞C) at current blanket setting</label>
          <input id="Tnow" type="number" step="0.1" value="22.0"/>
        </div>
        <div class="row">
          <label>Water pH</label>
          <input id="pH" type="number" step="0.05" min="5" max="9.5" value="7.2"/>
        </div>
        <div class="row">
          <label>Altitude (m)</label>
          <input id="altM" type="number" step="1" min="0" value="0"/>
        </div>

        <div class="row">
          <label>TDS (mg/L)</label>
          <input id="tds" type="number" step="10" value="660"/>
        </div>

        <div class="row">
          <label>Tank length (cm)</label>
          <input id="lenCm" type="number" step="0.1" value="78.0"/>
        </div>
        <div class="row">
          <label>Tank width (cm)</label>
          <input id="widCm" type="number" step="0.1" value="31.0"/>
        </div>

        <div class="row">
          <label>Tank height (cm)</label>
          <input id="tankHCm" type="number" step="0.1" value="48.0"/>
        </div>
        <div class="row">
          <label>Water surface from bottom (cm)</label>
          <input id="waterSurfCm" type="number" step="0.1" value="22.0"/>
        </div>

        <div class="row">
          <label>Blanket gap above rim (cm)</label>
          <input id="blanketGapCm" type="number" step="0.1" value="0.0"/>
        </div>
        <div class="row">
          <label>Diffuser depth below surface (cm)</label>
          <input id="diffDepthCm" type="number" step="0.1" value="17.0"/>
        </div>
        <div class="row">
          <label>Water column heaters (0‚Äì2)</label>
          <input id="heaters" type="number" step="1" min="0" max="2" value="0"/>
        </div>

        
      </details>
    </div>

    <div class="panel-section" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üå¨Ô∏è</span>Aeration & Surface Exchange</div>
        <div class="panel-badges">
          <span class="badge note">Advanced</span>
        </div>
      </div>
      <details class="panel-drawer" open>
        <summary>Controls</summary>
        <div class="grid2" style="margin-top:10px">
          <div class="row">
            <label>Air pump delivered flow (L/min)</label>
            <input id="airFlow" type="number" step="0.1" value="4.0"/>
          </div>
          <div class="row">
            <label>Surface ripples (% of surface)</label>
            <input id="ripplePct" type="number" step="1" value="50"/>
          </div>

          <div class="row">
            <label>Bubble transfer preset</label>
            <select id="diffType">
              <option value="airstone_med" selected>Typical airstones (medium bubbles)</option>
              <option value="airstone_fine">Fine airstone (smaller bubbles)</option>
              <option value="microbubble">Microbubble diffuser (very fine)</option>
              <option value="wood">Wooden airstone (very fine, higher backpressure)</option>
              <option value="custom">Custom</option>
            </select>
          </div>

          <div class="row">
            <label>Custom bubble efficiency: SOTE per meter (%)</label>
            <input id="sotePerM" type="number" step="0.1" value="2.5"/>
          </div>
          <div class="small" style="margin-top:-6px; opacity:.85">
            SOTE per meter is a <b>rough transfer efficiency</b> (how much O‚ÇÇ in the air actually dissolves per meter of bubble travel).
            If you‚Äôre unsure, use the preset ‚Äî the uncertainty mode already widens results around it.
          </div>

          <div class="row" style="margin-top:10px">
            <label>Surface exchange preset</label>
            <select id="surfacePreset">
              <option value="still">Still water (low exchange)</option>
              <option value="typical" selected>Typical aquarium (some ripples)</option>
              <option value="rippling">Strong ripples (good exchange)</option>
              <option value="splashy">Splashy / fan / very agitated (very high)</option>
              <option value="custom">Custom</option>
            </select>
          </div>

          <div class="row">
            <label>Surface k (calm) (m/day)</label>
            <input id="kCalm" type="number" step="0.05" value="0.30"/>
          </div>
          <div class="row">
            <label>Surface k (rippling) (m/day)</label>
            <input id="kRipple" type="number" step="0.05" value="1.00"/>
          </div>

          <div class="row" style="margin-top:10px">
            <label>Cover leakiness preset</label>
            <select id="tightPreset">
              <option value="open">No cover (open tank)</option>
              <option value="loose_high" selected>Loose blanket (high above water)</option>
              <option value="typical">Typical blanket (some restriction)</option>
              <option value="near_sealed">Near-sealed lid (strong restriction)</option>
              <option value="custom">Custom</option>
            </select>
          </div>
          <div class="row">
            <label>Leakiness number (0 drafty ‚Üí 1 sealed)</label>
            <input id="tight" type="number" step="0.05" min="0" max="1" value="0.25"/>
          </div>

          <div class="row" style="margin-top:10px">
            <label>Aeration performance preset</label>
            <select id="otrPreset">
              <option value="typical" selected>Typical (as expected)</option>
              <option value="under">Underperforming (backpressure / leaks)</option>
              <option value="over">Overperforming (very efficient)</option>
              <option value="custom">Custom</option>
            </select>
          </div>
          <div class="row">
            <label>Aeration performance factor</label>
            <input id="otrCal" type="number" step="0.05" value="1.00"/>
          </div>
        </div>
      </details>
      <details class="panel-drawer">
        <summary>What this means</summary>
        <div class="drawer-text">
          <b>Bubble side</b>: compute O‚ÇÇ mass entering per day from the airflow (altitude affects pressure), then multiply by an efficiency fraction that scales with depth and diffuser type.
          <br/><b>Surface side</b>: use a gas-film ‚Äúspeed‚Äù k (m/day) times surface area. Ripples get a higher k. Covered area gets k multiplied by a leak factor based on tightness + headspace ventilation.
          <br/><b>OTRmax</b> combines both sides (g/day at DO‚âà0) and becomes an inferred <b>kLa</b> so supply increases as DO drops: supply = kLa¬∑(C*‚àíDO)¬∑V.
        </div>
      </details>
    </div>

    <div class="panel-section" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üß¨</span>Biology & Chemistry</div>
        <div class="panel-badges">
          <span class="badge note">Advanced</span>
        </div>
      </div>
      <details class="panel-drawer" open>
        <summary>Controls</summary>
        <div class="grid2" style="margin-top:10px">
          <div class="row">
            <label>Initial DO assumption</label>
            <select id="initDOPreset">
              <option value="100">Near saturation (100%)</option>
              <option value="95" selected>High (95%)</option>
              <option value="85">Moderate (85%)</option>
              <option value="70">Low (70%)</option>
              <option value="custom">Custom</option>
            </select>
          </div>
          <div class="row">
            <label>Initial DO (% of local saturation)</label>
            <input id="doInitPct" type="number" step="1" min="0" max="150" value="95"/>
          </div>

          <div class="row">
            <label>Heterotroph biomass (g) ‚Äî respiration inferred</label>
            <input id="heteroMass" type="number" step="1" min="0" value="0"/>
          </div>
          <div class="row">
            <label>Photosynthetic mass (g wet biomass)</label>
            <input id="photoMass" type="number" step="1" min="0" value="0"/>
          </div>
          <div class="small" style="margin-top:-6px; opacity:.85">
            Photosynthetic mass combines plants, algae, and phytoplankton. Oxygen production + nutrient uptake are inferred from this.
          </div>

          <div class="row">
            <label>Diurnal temp amplitude (¬∞C)</label>
            <input id="tempAmp" type="number" step="0.1" min="0" value="0.6"/>
          </div>
          <div class="row">
            <label>Lights on (hour 0‚Äì23)</label>
            <input id="lightHour" type="number" step="1" min="0" max="23" value="9"/>
          </div>

          <div class="row">
            <label>Enable oxygen limitation for nitrification</label>
            <select id="o2Limit">
              <option value="off">Off (demand not reduced when DO is low)</option>
              <option value="on">On (nitrification slows as DO drops)</option>
            </select>
          </div>
          <div class="row">
            <label>Nitrifier DO half-saturation K (mg/L)</label>
            <input id="kDoNit" type="number" step="0.05" value="0.50"/>
          </div>
          <div class="row">
            <label>NH‚ÇÑ half-saturation K (mg/L as N)</label>
            <input id="kNH4Nit" type="number" step="0.05" value="0.40"/>
          </div>
          <div class="row">
            <label>NO‚ÇÇ half-saturation K (mg/L as N)</label>
            <input id="kNO2Nit" type="number" step="0.05" value="0.25"/>
          </div>
          <div class="row">
            <label>Nitrifier capacity (0‚Äì1)</label>
            <input id="nitCap" type="number" step="0.05" min="0" max="1" value="0.80"/>
          </div>
          <div class="row">
            <label>Nitrifier Q10 (temperature response)</label>
            <input id="nitQ10" type="number" step="0.05" value="2.0"/>
          </div>
          <div class="row">
            <label>Heterotroph DO half-saturation K (mg/L)</label>
            <input id="kDoHet" type="number" step="0.05" value="0.80"/>
          </div>
          <div class="row">
            <label>Refractory fraction (slow COD)</label>
            <input id="slowFrac" type="number" step="0.05" min="0" max="0.9" value="0.25"/>
          </div>
          <div class="row">
            <label>Biofilm thickness proxy (mm)</label>
            <input id="biofilmMm" type="number" step="0.1" min="0" value="0.6"/>
          </div>
          <div class="row">
            <label>Denitrification rate (1/day)</label>
            <input id="kDenit" type="number" step="0.05" value="0.15"/>
          </div>
          <div class="row">
            <label>Denitrifier capacity (0‚Äì1)</label>
            <input id="denitCap" type="number" step="0.05" min="0" max="1" value="0.60"/>
          </div>

          <div class="row">
            <label>Nitrogen display units</label>
            <select id="nUnits">
              <option value="asN" selected>as N (mg/L)</option>
              <option value="asIon">as ion (mg/L)</option>
            </select>
          </div>
          <div class="row">
            <label>Chemistry audit (nerd mode)</label>
            <input id="chemNerd" type="checkbox"/>
          </div>
        </div>
      </details>
    </div>

    <div class="panel-section" style="margin-top:12px">
      <div class="panel-header">
        <div class="panel-title"><span class="icon">üî¨</span>Pellet Geometry</div>
        <div class="panel-badges">
          <span class="badge note">Advanced</span>
        </div>
      </div>
      <details class="panel-drawer" open>
        <summary>Controls</summary>
        <div class="grid2" style="margin-top:10px">
          <div class="row">
            <label>Pellet length (cm)</label>
            <input id="pelLen" type="number" step="0.01" value="1.00" disabled title="Hardcoded: 1.00 cm"/>
          </div>
          <div class="row">
            <label>Pellet diameter (cm)</label>
            <input id="pelDia" type="number" step="0.01" value="0.20" disabled title="Hardcoded: 0.20 cm"/>
          </div>
          <div class="row">
            <label>Pellet density (g/cm¬≥)</label>
            <input id="pelRho" type="number" step="0.01" value="0.55"/>
          </div>
        </div>
      </details>
    </div>

  </div>

  <div class="card">
    <h2>Charts</h2>
    <div class="charts">
      <div>
        <canvas id="rateCanvas" width="1200" height="360"></canvas>
        <div class="small" style="margin-top:6px">Rate chart (g O‚ÇÇ/day). Click to add a ‚Äúpop‚Äù event at that day.</div>
      </div>
      <div>
        <canvas id="doCanvas" width="1200" height="360"></canvas>
        <div class="small" style="margin-top:6px">Dissolved oxygen (mg/L). Dashed line is local saturation C*.</div>
      </div>
      <div>
        <canvas id="chemCanvas" width="1200" height="360"></canvas>
        <div class="small" style="margin-top:6px">Chemistry / compounds (mg/L). Toggle NH‚ÇÑ/NO‚ÇÇ/NO‚ÇÉ units in Advanced.</div>
      </div>
    </div>

    <div class="small" style="margin-top:8px">Rate chart series</div>
    <div class="legend" id="legendRate"></div>
    <div class="small" style="margin-top:12px">Chemistry chart series</div>
    <div class="legend" id="legendChem"></div>

    <div class="hr"></div>

    <h2>Chemistry overview</h2>
    <div class="small">Inconspicuous tag lines that summarize the modeled chemical peaks/mins. Tap a line to expand details and see safe vs caution vs dangerous reference bands.</div>
    <div class="tag-stack" id="chemTags" style="margin-top:10px"></div>

    <details id="chemAuditDetails" style="margin-top:10px; display:none;">
      <summary>Chemistry audit (nerd mode)</summary>
      <div class="small" style="margin-top:8px">Audit trails for nitrogen + CO‚ÇÇ + nutrients.</div>
      <pre id="chemAudit" class="mono" style="white-space:pre-wrap; word-break:break-word; color:rgba(231,236,255,.82)"></pre>
    </details>

    <div class="hr"></div>

    <div class="note">
      <b>Interpretation tip:</b> When DO is high, supply is smaller because (C*‚àíDO) is smaller. As DO falls, the same aeration becomes more ‚Äúhungry‚Äù and transfers more O‚ÇÇ.
      If the DO curve still crashes, the model is saying ‚Äúeven when the water is starving for O‚ÇÇ, your demand beats your supply.‚Äù
    </div>


<details id="dbgDetails" style="margin-top:14px">
  <summary>Dev / debug</summary>
  <div class="small" style="margin-top:10px">
    Errors and warnings also show in the browser console.
  </div>
  <div class="hr"></div>
  <div class="small"><b>Last recompute diagnostics</b></div>
  <div class="row" style="margin-top:8px; align-items:center;">
    <button class="btn ghost" id="copyDebugBtn">Copy Debug Log</button>
    <span class="copy-toast" id="copyDebugStatus" style="display:none"></span>
  </div>
  <pre id="dbg" class="mono" style="white-space:pre-wrap; word-break:break-word; color:rgba(231,236,255,.82)"></pre>
</details>


  </div>
</div>

<div class="tooltip" id="tip"></div>

<script type="module">
(() => {
  const bootToken = 'aquachem-inline-v4';
  const bootKey = '__AQUACHEM_BOOT__';
  const currentScript = document.currentScript;
  if(currentScript){
    currentScript.dataset.aquachemBoot = bootToken;
  }
  const existingBoot = window[bootKey];
  if(existingBoot){
    existingBoot.count = (existingBoot.count || 1) + 1;
    existingBoot.lastSeenISO = new Date().toISOString();
    console.warn('AquaChem inline script already initialized.', existingBoot);
    return;
  }
  window[bootKey] = {
    token: bootToken,
    count: 1,
    firstSeenISO: new Date().toISOString(),
    lastSeenISO: null
  };

/* =========================================================
   Series registry (rate + chemistry charts)
========================================================= */
const RATE_SERIES = [
  {key:"carb",  name:"Carbs ‚Üí CO‚ÇÇ (direct)", color:"#54a0ff"},
  {key:"prot",  name:"Protein ‚Üí CO‚ÇÇ + NH‚ÇÑ (direct)", color:"#ff9f43"},
  {key:"fat",   name:"Fat ‚Üí CO‚ÇÇ (direct)", color:"#2ecc71"},
  {key:"endog", name:"Endogenous respiration", color:"#ff6b6b"},
  {key:"nh4",   name:"NH‚ÇÑ ‚Üí NO‚ÇÇ (nitrification)", color:"#a29bfe"},
  {key:"no2",   name:"NO‚ÇÇ ‚Üí NO‚ÇÉ (nitrification)", color:"#c8d6e5"},
  {key:"fish",  name:"Fish respiration", color:"#ff9ff3"},
  {key:"plant", name:"Plant O‚ÇÇ production", color:"#1dd1a1"},
  {key:"total", name:"TOTAL demand", color:"#ff5fd2", bold:true},
  {key:"supply",name:"O‚ÇÇ transfer into water (dynamic)", color:"#63e6be", dash:true},
];

const CHEM_SERIES = [
  {key:"nh4", name:"NH‚ÇÑ (total ammonia)", color:"#ffd166"},
  {key:"nh3", name:"NH‚ÇÉ (unionized)", color:"#ff8fab"},
  {key:"no2", name:"NO‚ÇÇ", color:"#a29bfe"},
  {key:"no3", name:"NO‚ÇÉ", color:"#63e6be"},
  {key:"co2", name:"CO‚ÇÇ free", color:"#54a0ff"},
  {key:"dic", name:"DIC (buffered)", color:"#48dbfb"},
  {key:"store", name:"Nutrient stores", color:"#feca57"},
  {key:"micro", name:"Micros (proxy)", color:"#b8c0ff"},
];

let visibleRate = Object.fromEntries(RATE_SERIES.map(s=>[s.key, true]));
let visibleChem = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, true]));
let calendarExpandedKey = null;

function updateChemSeriesLabels(nUnits){
  if(nUnits === 'asIon'){
    CHEM_SERIES.find(s=>s.key==='nh4').name = 'NH‚ÇÑ‚Å∫ (ion)';
    CHEM_SERIES.find(s=>s.key==='no2').name = 'NO‚ÇÇ‚Åª (ion)';
    CHEM_SERIES.find(s=>s.key==='no3').name = 'NO‚ÇÉ‚Åª (ion)';
  }else{
    CHEM_SERIES.find(s=>s.key==='nh4').name = 'NH‚ÇÑ-N';
    CHEM_SERIES.find(s=>s.key==='no2').name = 'NO‚ÇÇ-N';
    CHEM_SERIES.find(s=>s.key==='no3').name = 'NO‚ÇÉ-N';
  }
}

function buildCumulativeSeries(seriesDict, dt){
  const series = {};
  const totals = {};
  let invalidCount = 0;
  for(const [key, arr] of Object.entries(seriesDict || {})){
    const cum = new Array(arr.length);
    let sum = 0;
    let bad = 0;
    for(let i=0;i<arr.length;i++){
      const v = arr[i];
      const safe = Number.isFinite(v) ? v : 0;
      if(!Number.isFinite(v)) bad++;
      sum += safe * dt;
      cum[i] = sum;
    }
    series[key] = cum;
    totals[key] = sum;
    invalidCount += bad;
  }
  return {series, info:{invalidCount, totals, dt}};
}

/* =========================================================
   DOM helpers + error plumbing
========================================================= */
const el = id => document.getElementById(id);
const setText = (id, value)=>{
  const node = el(id);
  if(node) node.textContent = value;
};

function ensureTooltip(){
  // Robust: support either #tip or legacy #tooltip. Create if missing.
  let t = el('tip') || el('tooltip');
  if(!t){
    t = document.createElement('div');
    t.className = 'tooltip';
    t.id = 'tip';
    document.body.appendChild(t);
  }
  return t;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

function showError(err){
  let box = el('errBox');
  let txt = el('errText');
  const note = el('modelStatusNote');
  const msg = (err && err.stack) ? err.stack : String(err);

  if(!box || !txt){
    box = document.createElement('div');
    box.id = 'errBox';
    box.className = 'errbox';
    box.style.display = 'block';
    box.innerHTML = `<b>Model error</b><pre id="errText"></pre>`;
    document.body.appendChild(box);
    txt = el('errText');
  }

  // Visible error banner
  if(box) box.style.display = 'block';
  if(txt) txt.textContent = msg;
  if(note) note.style.display = 'none';

  // Record into debug state
  try{
    DEBUG_STATE.errors.push({
      timeISO: new Date().toISOString(),
      name: (err && err.name) ? err.name : 'Error',
      message: (err && err.message) ? err.message : String(err),
      stack: (err && err.stack) ? err.stack : '',
      stage: DEBUG_STATE.stage,
      stageExtra: DEBUG_STATE.stageExtra
    });
  }catch(_){}

  // Populate debug panel with a snapshot + full stack
  try{
    const extra = [
      'Error:',
      msg
    ];
    setDebugText(buildDebugSnapshot(extra));
    const det = el('dbgDetails');
    if(det) det.open = true;
  }catch(_){}

  console.error(err);
}
function clearError(){
  const box = el('errBox');
  const text = el('errText');
  const note = el('modelStatusNote');
  if(box) box.style.display = 'none';
  if(text) text.textContent = '';
  if(note) note.style.display = 'block';
}


// ---------------- Debug state (for ‚Äúwhat just happened?‚Äù) ----------------
const DEBUG_STATE = {
  stage: 'init',
  stageExtra: '',
  lastParams: null,
  lastOxy: null,
  lastMode: null,
  lastSimMeta: null,
  lastScalars: null,
  lastChemCumInfo: null,
  lastRecomputeMs: null,
  lastFlagsCount: null,
  lastUpdateISO: null,
  bootToken: bootToken,
  bootLoadedISO: window[bootKey].firstSeenISO,
  bootDuplicateCount: window[bootKey].count,
  bootScriptTagCount: document.querySelectorAll('script[data-aquachem-boot]').length,
  bootModuleScript: document.currentScript ? document.currentScript.type === 'module' : true,
  dedupeReport: null,
  recomputeBubbleState: null,
  recomputeBubbleMeta: null,
  recomputeBubbleUpdatedISO: null,
  recomputeBubbleMissing: false,
  missingContainers: [],
  missingInputs: [],
  lastMissingInputsCount: null,
  initReadyState: null,
  errors: [],  // newest last
  warnings: []
};

function setStage(stage, extra=null){
  DEBUG_STATE.stage = String(stage || '');
  DEBUG_STATE.stageExtra = extra ? String(extra) : '';
}

function addWarning(message){
  if(!message) return;
  DEBUG_STATE.warnings.push({
    timeISO: new Date().toISOString(),
    message: String(message),
    stage: DEBUG_STATE.stage,
    stageExtra: DEBUG_STATE.stageExtra
  });
}

function logMissingInput(id, context){
  const entry = {
    timeISO: new Date().toISOString(),
    id,
    context: context || 'unknown'
  };
  DEBUG_STATE.missingInputs.push(entry);
  DEBUG_STATE.lastMissingInputsCount = DEBUG_STATE.missingInputs.length;
  addWarning(`Missing input #${id} (${entry.context}).`);
}

if(DEBUG_STATE.bootScriptTagCount > 1){
  addWarning(`Detected ${DEBUG_STATE.bootScriptTagCount} inline AquaChem script tags; this can trigger duplicate-load parse errors.`);
}

function setRecomputeBubbleState(state, meta = null){
  const normalized = (typeof state === 'string' && state.trim()) ? state.trim() : 'idle';
  DEBUG_STATE.recomputeBubbleState = normalized;
  DEBUG_STATE.recomputeBubbleMeta = meta ? meta : null;
  DEBUG_STATE.recomputeBubbleUpdatedISO = new Date().toISOString();

  const bubble = el('recomputeBubble');
  if(!bubble){
    if(!DEBUG_STATE.recomputeBubbleMissing){
      DEBUG_STATE.recomputeBubbleMissing = true;
      addWarning('Missing recompute bubble element (#recomputeBubble).');
    }
    return;
  }
  bubble.dataset.state = normalized;
  bubble.textContent = normalized === 'running' ? 'Recomputing‚Ä¶' : normalized === 'error' ? 'Recompute error' : 'Ready';
}

function dedupeAppNodes(){
  const report = {removedNodes: 0, duplicateWraps: 0, duplicateCards: 0, duplicateIds: []};
  const seenIds = new Set();
  const withIds = Array.from(document.querySelectorAll('[id]'));
  for(const node of withIds){
    if(seenIds.has(node.id)){
      report.duplicateIds.push(node.id);
      node.remove();
      report.removedNodes += 1;
    }else{
      seenIds.add(node.id);
    }
  }

  const wraps = Array.from(document.querySelectorAll('.wrap'));
  if(wraps.length > 1){
    report.duplicateWraps = wraps.length - 1;
    wraps.slice(1).forEach((node)=>{
      node.remove();
      report.removedNodes += 1;
    });
  }

  const cards = Array.from(document.querySelectorAll('.wrap .card'));
  if(cards.length > 2){
    report.duplicateCards = cards.length - 2;
    cards.slice(2).forEach((node)=>{
      node.remove();
      report.removedNodes += 1;
    });
  }

  if(report.removedNodes > 0){
    addWarning(`Removed ${report.removedNodes} duplicate UI node(s) (wraps=${report.duplicateWraps}, cards=${report.duplicateCards}, ids=${report.duplicateIds.length}).`);
  }
  DEBUG_STATE.dedupeReport = report;
}

function setDebugText(lines){
  const pre = el('dbg');
  if(!pre) return;
  pre.textContent = Array.isArray(lines) ? lines.join('\n') : String(lines ?? '');
}

function compactJSON(obj, maxLen=2200){
  try{
    const s = JSON.stringify(obj, (k,v)=>{
      // avoid dumping giant arrays into the debug panel
      if(Array.isArray(v) && v.length > 60){
        return {__array__: true, length: v.length, head: v.slice(0, 10), tail: v.slice(-10)};
      }
      return v;
    }, 2);
    return s.length > maxLen ? (s.slice(0, maxLen) + "\n‚Ä¶(truncated)‚Ä¶") : s;
  }catch(e){
    return `[unserializable: ${e}]`;
  }
}

function buildDebugSnapshot(extraLines=[]){
  const lines = [];
  lines.push(`Time: ${new Date().toISOString()}`);
  lines.push(`Stage: ${DEBUG_STATE.stage}${DEBUG_STATE.stageExtra ? ' ‚Äî ' + DEBUG_STATE.stageExtra : ''}`);
  if(DEBUG_STATE.lastMode) lines.push(`Mode: ${DEBUG_STATE.lastMode}`);
  lines.push(`devicePixelRatio: ${devicePixelRatio}`);
  lines.push(`UserAgent: ${navigator.userAgent}`);
  // DOM sanity
  try{
    const tipEl = el('tip') || el('tooltip');
    lines.push(`TooltipEl: ${tipEl ? ('#'+tipEl.id+' .' + (tipEl.className||'')) : 'missing'}`);
    const dbg = el('dbg');
    lines.push(`DebugEl: ${dbg ? '#dbg OK' : 'missing'}`);
  }catch(_){}
  if(DEBUG_STATE.lastParams){
    lines.push('');
    lines.push('--- Params (last) ---');
    const p = DEBUG_STATE.lastParams;
    // small, human-relevant subset first
    const dtDays = (p.dt != null) ? p.dt : (DEBUG_STATE.lastSimMeta && DEBUG_STATE.lastSimMeta.dt != null ? DEBUG_STATE.lastSimMeta.dt : null);
    const dtHours = (dtDays != null && Number.isFinite(dtDays)) ? (dtDays*24) : NaN;
    lines.push(`volL=${p.volL}, days=${p.days}, dtHours‚âà${Number.isFinite(dtHours) ? dtHours.toFixed(2) : 'n/a'}, airFlow=${p.airFlow} L/min @ alt=${p.altM} m`);
lines.push(`surface=${p.lenCm}√ó${p.widCm} cm, blanket=${p.blanketPct}%, ripple=${p.ripplePct}%`);
    lines.push(`diffuser=${p.diffType || 'n/a'}, depth=${p.diffDepthCm} cm, tight=${p.tight}`);
    lines.push(`pH=${p.pH}, heaters=${p.heaters}, nitCap=${p.nitCap}, nUnits=${p.nUnits}`);
    lines.push('');
    lines.push(compactJSON(p, 1600));
  }
  if(DEBUG_STATE.lastOxy){
    lines.push('');
    lines.push('--- Oxygenation (last) ---');
    const o = DEBUG_STATE.lastOxy;
    try{
      lines.push(`C*‚âà${(o.Cstar!=null?Number(o.Cstar).toFixed(2):(o.Cstar_mgL!=null?Number(o.Cstar_mgL).toFixed(2):'n/a'))} mg/L; OTRmax‚âà${(o.OTR_max!=null?Number(o.OTR_max).toFixed(3):(o.OTR_max_g_day!=null?Number(o.OTR_max_g_day).toFixed(3):'n/a'))} g/day; kLa‚âà${(o.kLa!=null?Number(o.kLa).toFixed(4):'n/a')} 1/day`);
      if(o.OTR_bubble_max!=null && o.OTR_surface_max!=null){
        lines.push(`bubble‚âà${Number(o.OTR_bubble_max).toFixed(3)} g/day; surface‚âà${Number(o.OTR_surface_max).toFixed(3)} g/day`);
      }
    }catch(_){}
    lines.push(compactJSON(o, 1800));
  }
  if(DEBUG_STATE.bootToken){
    lines.push('');
    lines.push('--- Boot ---');
    lines.push(`Token: ${DEBUG_STATE.bootToken}`);
    lines.push(`Loaded: ${DEBUG_STATE.bootLoadedISO}`);
    lines.push(`Duplicate loads: ${DEBUG_STATE.bootDuplicateCount}`);
    lines.push(`Script tags: ${DEBUG_STATE.bootScriptTagCount}`);
    lines.push(`Module script: ${DEBUG_STATE.bootModuleScript}`);
  }
  if(DEBUG_STATE.dedupeReport){
    lines.push('');
    lines.push('--- Dedupe ---');
    lines.push(compactJSON(DEBUG_STATE.dedupeReport, 900));
  }
  if(DEBUG_STATE.recomputeBubbleState){
    lines.push('');
    lines.push('--- Recompute bubble ---');
    lines.push(`State: ${DEBUG_STATE.recomputeBubbleState}`);
    if(DEBUG_STATE.recomputeBubbleUpdatedISO){
      lines.push(`Updated: ${DEBUG_STATE.recomputeBubbleUpdatedISO}`);
    }
    if(DEBUG_STATE.recomputeBubbleMeta){
      lines.push(compactJSON(DEBUG_STATE.recomputeBubbleMeta, 800));
    }
  }
  if(DEBUG_STATE.lastSimMeta){
    lines.push('');
    lines.push('--- Sim meta (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastSimMeta, 900));
  }
  if(DEBUG_STATE.lastTagSummary){
    lines.push('');
    lines.push('--- Chemistry tags (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastTagSummary, 1200));
  }
  if(DEBUG_STATE.lastScalars){
    lines.push('');
    lines.push('--- Uncertainty scalars (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastScalars, 1200));
  }
  if(Number.isFinite(DEBUG_STATE.lastFlagsCount)){
    lines.push('');
    lines.push('--- Flags rendered (last) ---');
    lines.push(`Cards: ${DEBUG_STATE.lastFlagsCount}`);
  }
  if(DEBUG_STATE.missingContainers.length){
    lines.push('');
    lines.push('--- Missing containers (recent) ---');
    const recent = DEBUG_STATE.missingContainers.slice(-3);
    recent.forEach((m, i)=>{
      lines.push(`#${DEBUG_STATE.missingContainers.length - recent.length + i + 1} ${m.timeISO} ‚Äî ${m.id} (${m.context})`);
    });
  }
  if(DEBUG_STATE.missingInputs.length){
    lines.push('');
    lines.push('--- Missing inputs (recent) ---');
    const recent = DEBUG_STATE.missingInputs.slice(-3);
    recent.forEach((m, i)=>{
      lines.push(`#${DEBUG_STATE.missingInputs.length - recent.length + i + 1} ${m.timeISO} ‚Äî ${m.id} (${m.context})`);
    });
  }
  if(Number.isFinite(DEBUG_STATE.lastRecomputeMs)){
    lines.push('');
    lines.push('--- Recompute timing (last) ---');
    lines.push(`Total recompute: ${DEBUG_STATE.lastRecomputeMs.toFixed(1)} ms`);
  }
  if(Number.isFinite(DEBUG_STATE.debounceQueued) || Number.isFinite(DEBUG_STATE.debounceMs)){
    lines.push('');
    lines.push('--- Debounce ---');
    lines.push(`Queued recomputes: ${Number.isFinite(DEBUG_STATE.debounceQueued) ? DEBUG_STATE.debounceQueued : 0}`);
    if(Number.isFinite(DEBUG_STATE.debounceMs)){
      lines.push(`Delay: ${DEBUG_STATE.debounceMs} ms`);
    }
  }
  if(DEBUG_STATE.initReadyState){
    lines.push('');
    lines.push('--- Init ---');
    lines.push(`ReadyState at init: ${DEBUG_STATE.initReadyState}`);
  }
  if(DEBUG_STATE.lastChemCumInfo){
    lines.push('');
    lines.push('--- Chemistry cumulative (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastChemCumInfo, 900));
  }
  if(extraLines && extraLines.length){
    lines.push('');
    lines.push('--- Notes ---');
    for(const l of extraLines) lines.push(String(l));
  }
  // recent errors
  if(DEBUG_STATE.errors.length){
    lines.push('');
    lines.push('--- Recent errors ---');
    const recent = DEBUG_STATE.errors.slice(-3);
    recent.forEach((e, i)=>{
      lines.push(`#${DEBUG_STATE.errors.length - recent.length + i + 1} ${e.timeISO} ‚Äî ${e.name}: ${e.message}`);
      if(e.stage) lines.push(`  stage: ${e.stage}${e.stageExtra ? ' ‚Äî ' + e.stageExtra : ''}`);
      if(e.stack) lines.push('  stack: ' + e.stack.split('\n').slice(0,5).join(' | '));
    });
  }
  if(DEBUG_STATE.warnings.length){
    lines.push('');
    lines.push('--- Recent warnings ---');
    const recent = DEBUG_STATE.warnings.slice(-3);
    recent.forEach((w, i)=>{
      lines.push(`#${DEBUG_STATE.warnings.length - recent.length + i + 1} ${w.timeISO} ‚Äî ${w.message}`);
      if(w.stage) lines.push(`  stage: ${w.stage}${w.stageExtra ? ' ‚Äî ' + w.stageExtra : ''}`);
    });
  }
  return lines;
}
function assertFinite(name, v){
  if(!Number.isFinite(v)) throw new Error(`Non-finite value for ${name}: ${v}`);
  return v;
}

function grabNumField(id, fallback, context){
  const node = el(id);
  if(!node){
    logMissingInput(id, context || 'number');
    return fallback;
  }
  const value = Number(node.value);
  if(!Number.isFinite(value)){
    addWarning(`Non-finite numeric input #${id}: ${node.value}`);
    return fallback;
  }
  return value;
}

function grabSelectField(id, fallback, context){
  const node = el(id);
  if(!node){
    logMissingInput(id, context || 'select');
    return fallback;
  }
  return node.value ?? fallback;
}

function grabCheckField(id, fallback, context){
  const node = el(id);
  if(!node){
    logMissingInput(id, context || 'checkbox');
    return fallback;
  }
  return !!node.checked;
}

function installGlobalErrorHandlers(){
  if(window.__o2planner_err_bound) return;
  window.__o2planner_err_bound = true;
  window.addEventListener('error', (event)=>{
    const err = event?.error || new Error(event?.message || 'Unknown error');
    showError(err);
  });
  window.addEventListener('unhandledrejection', (event)=>{
    const err = event?.reason instanceof Error ? event.reason : new Error(String(event?.reason || 'Unhandled rejection'));
    showError(err);
  });
}

function linkRangeAndNumber(rangeEl, numEl, onChange){
  const sync = (src, dst)=>{ dst.value = src.value; onChange(); };
  rangeEl.addEventListener("input", ()=>sync(rangeEl, numEl));
  numEl.addEventListener("input", ()=>sync(numEl, rangeEl));
}

function wireActiveControlGlow(){
  const inputs = Array.from(document.querySelectorAll('input, select, textarea'));
  if(!inputs.length) return;
  inputs.forEach((input)=>{
    if(input.__glowBound) return;
    input.__glowBound = true;
    input.addEventListener('focus', ()=>{
      if(input.matches('input[type="range"]')) return;
      input.classList.add('control-active');
    });
    input.addEventListener('blur', ()=>{
      input.classList.remove('control-active');
    });
    input.addEventListener('change', ()=>{
      if(input.matches('select')){
        input.classList.add('control-active');
        setTimeout(()=>input.classList.remove('control-active'), 450);
      }
    });
  });
}

function measurePanelOverflow(){
  const panel = document.querySelector('.left-panel');
  if(!panel){
    addWarning('Left panel missing for overflow metrics.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'left-panel', context:'measurePanelOverflow'});
    return;
  }
  const panelHeight = panel.getBoundingClientRect().height;
  const viewportHeight = window.innerHeight || 0;
  const limit = Math.max(140, Math.round(viewportHeight * 0.18));
  const overflow = Math.max(0, panelHeight - (viewportHeight - 24));
  DEBUG_STATE.panelOverflowPx = overflow;
  DEBUG_STATE.panelOverflowLimitPx = limit;
  DEBUG_STATE.lastPanelMeasureISO = new Date().toISOString();
  if(overflow > limit){
    if(!DEBUG_STATE.panelOverflowWarnedISO){
      addWarning(`Left panel exceeds viewport by ${overflow.toFixed(0)}px; consider collapsing drawers.`);
      DEBUG_STATE.panelOverflowWarnedISO = new Date().toISOString();
    }
  }else{
    DEBUG_STATE.panelOverflowWarnedISO = null;
  }
}

function enableDebugCopyRoutine(){
  const btn = el('copyDebugBtn');
  const status = el('copyDebugStatus');
  if(!btn || !status){
    addWarning('Copy debug controls missing (#copyDebugBtn or #copyDebugStatus).');
    return;
  }
  const announce = (message, isWarn=false)=>{
    status.textContent = message;
    status.classList.toggle('warn', isWarn);
    status.style.display = 'inline-flex';
    setTimeout(()=>{ status.style.display = 'none'; }, 2400);
  };
  if(btn.__copyBound) return;
  btn.__copyBound = true;
  btn.addEventListener('click', async ()=>{
    const dbgText = el('dbg') ? el('dbg').textContent : '';
    if(!dbgText || !dbgText.trim()){
      DEBUG_STATE.lastDebugCopyStatus = 'empty';
      DEBUG_STATE.lastDebugCopyError = 'Debug log empty';
      addWarning('Debug log copy requested but debug log is empty.');
      announce('Nothing to copy', true);
      return;
    }
    try{
      if(navigator.clipboard?.writeText){
        await navigator.clipboard.writeText(dbgText);
      }else{
        const helper = document.createElement('textarea');
        helper.value = dbgText;
        helper.setAttribute('readonly', '');
        helper.style.position = 'absolute';
        helper.style.left = '-9999px';
        document.body.appendChild(helper);
        helper.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(helper);
        if(!ok) throw new Error('execCommand copy failed');
      }
      DEBUG_STATE.lastDebugCopyStatus = 'copied';
      DEBUG_STATE.lastDebugCopyError = null;
      announce('Debug log copied');
    }catch(err){
      const message = err?.message || String(err);
      DEBUG_STATE.lastDebugCopyStatus = 'failed';
      DEBUG_STATE.lastDebugCopyError = message;
      addWarning(`Debug log copy failed: ${message}`);
      announce('Copy failed', true);
    }
  });
}

window.addEventListener('error', (e)=>{ try{ showError(e.error || e.message || e); }catch(_){ }});
window.addEventListener('unhandledrejection', (e)=>{ try{ showError(e.reason || e); }catch(_){ }});

/* =========================================================
   Oxygenation / DO model (inference)
========================================================= */
const PHYS = {
  R: 8.314462618,     // J/mol/K
  O2_FRACTION: 0.2095,
  M_O2: 31.998,       // g/mol
  P0_kPa: 101.325
};

function pressureFromAltitude_kPa(alt_m){
  // Standard atmosphere approximation:
  // P = 101.325 * (1 - 2.25577e-5*h)^5.25588
  const h = Math.max(0, alt_m);
  const P = PHYS.P0_kPa * Math.pow(1 - 2.25577e-5*h, 5.25588);
  return clamp(P, 30, 110);
}

function doSatSeaLevel_mgL_fresh(T_C){
  // Common polynomial for freshwater DO saturation at 1 atm.
  const T = T_C;
  const sat = 14.652 - 0.41022*T + 0.007991*T*T - 0.000077774*T*T*T;
  return Math.max(0, sat);
}

function doSat_mgL(T_C, alt_m, tds_mgL){
  const P = pressureFromAltitude_kPa(alt_m);
  const sat0 = doSatSeaLevel_mgL_fresh(T_C);

  // Very light salinity-ish correction from TDS (ppt ~ g/L).
  // This is intentionally conservative/rough: you can override with calibration later.
  const sal_ppt = Math.max(0, tds_mgL/1000);
  const salFactor = clamp(1 - 0.01*sal_ppt, 0.80, 1.0); // ~1% per ppt (rough)

  const pressFactor = P / PHYS.P0_kPa;
  return sat0 * salFactor * pressFactor;
}

function oxygenMassInPumpedAir_g_per_day(airFlow_L_min, T_C, alt_m){
  // PV=nRT to convert airflow at ambient pressure into moles of gas, then oxygen mass.
  const P_kPa = pressureFromAltitude_kPa(alt_m);
  const P_Pa = P_kPa * 1000;
  const T_K = (T_C + 273.15);

  const V_m3_per_min = Math.max(0, airFlow_L_min) / 1000;
  const n_total_per_min = (P_Pa * V_m3_per_min) / (PHYS.R * T_K);
  const n_O2_per_min = n_total_per_min * PHYS.O2_FRACTION;
  const g_O2_per_min = n_O2_per_min * PHYS.M_O2;

  return g_O2_per_min * 1440;
}

function computeAreas(params){
  const L = Math.max(1e-6, params.lenCm/100);
  const W = Math.max(1e-6, params.widCm/100);
  const A_total = L * W;

  const openFrac = clamp(1 - params.blanketPct/100, 0, 1);
  const A_open = A_total * openFrac;
  const A_cov  = A_total - A_open;

  const rippleFrac = clamp(params.ripplePct/100, 0, 1);
  const A_ripple = A_total * rippleFrac;

  // Assume ripple happens mostly where bubbles are (uncovered zone), but allow overflow.
  const A_ripple_open = Math.min(A_ripple, A_open);
  const A_ripple_cov  = Math.max(0, A_ripple - A_ripple_open);

  const A_calm_open = Math.max(0, A_open - A_ripple_open);
  const A_calm_cov  = Math.max(0, A_cov  - A_ripple_cov);

  return {A_total, A_open, A_cov, A_ripple_open, A_ripple_cov, A_calm_open, A_calm_cov};
}

function computeHeadspace(params, areas){
  // Headspace height = (tank height - water surface height) + extra blanket gap above rim.
  const tankH_m = Math.max(0, params.tankHCm/100);
  const waterSurf_m = Math.max(0, params.waterSurfCm/100);
  const gap_m = Math.max(0, params.blanketGapCm/100);
  const headH_m = Math.max(0, (tankH_m - waterSurf_m) + gap_m);

  const V_head_m3 = areas.A_total * headH_m;
  const V_head_L = V_head_m3 * 1000;

  // How often the pump could replace the headspace volume, if air actually circulates.
  const turnover_min = (params.airFlow > 1e-9) ? (V_head_L / params.airFlow) : Infinity;

  return {headH_m, V_head_L, turnover_min};
}

function coverLeakFactor(params, head){
  // Blanket penalty is mostly about how well the headspace exchanges with room air.
  // Two forgiving factors:
  //   (a) pump constantly flushing the headspace (short turnover)
  //   (b) large headspace buffers composition drift (slower change)
  //
  // We fold those into an effective tightness and map it to a multiplier on surface k.

  const tight = clamp(params.tight, 0, 1);

  // If turnover is fast (<30 min), ventilation is strong ‚Üí penalty shrinks.
  const ventScore = Number.isFinite(head.turnover_min)
    ? clamp(30 / Math.max(1e-6, head.turnover_min), 0, 1)
    : 0;

  // Larger headspace is more forgiving even if tight (composition changes slower).
  const Vref = 15; // L (tunable)
  const bufferScore = clamp(Vref / (Vref + Math.max(0, head.V_head_L)), 0, 1);

  const effTight = tight * (1 - ventScore) * bufferScore;

  // effTight=0 ‚Üí almost no penalty
  // effTight=1 ‚Üí strong penalty (nearly sealed, small headspace, poor ventilation)
  return (1 - effTight) * 0.90 + effTight * 0.05;
}

function oxygenationModel(params){
  const T = params.Tnow;
  const Cstar = doSat_mgL(T, params.altM, params.tds); // mg/L

  const areas = computeAreas(params);
  const head  = computeHeadspace(params, areas);

  // Bubble transfer:
  // O2_in_air_g_day scales with pressure (altitude) and airflow.
  const depth_m = Math.max(0, params.diffDepthCm/100);
  const sote_per_m = Math.max(0, params.sotePerM/100); // fraction per meter
  const O2_in_air_g_day = oxygenMassInPumpedAir_g_per_day(params.airFlow, T, params.altM);

  // Efficiency fraction over depth. Cap to avoid silly inputs.
  const eff_bubble = clamp(sote_per_m * depth_m * Math.max(0.05, params.otrCal), 0, 0.35);
  const OTR_bubble_max = O2_in_air_g_day * eff_bubble;

  // Surface transfer:
  // Treat k as a "film speed" (m/day). OTR_surface_max = C* (g/m^3) * k*A (m^3/day).
  // Note: mg/L == g/m^3 numerically.
  const kC = clamp(params.kCalm,   0, 10);
  const kR = clamp(params.kRipple, 0, 10);

  const leak = coverLeakFactor(params, head);

  const kA_open = kC*areas.A_calm_open + kR*areas.A_ripple_open;
  const kA_cov  = (kC*areas.A_calm_cov + kR*areas.A_ripple_cov) * leak;

  const Cstar_g_m3 = Cstar;
  const OTR_surface_max = Cstar_g_m3 * (kA_open + kA_cov);

  // Total max transfer at DO‚âà0.
  const OTR_max = OTR_bubble_max + OTR_surface_max;

  // Infer kLa from OTR_max = kLa * C* * V
  const volL = Math.max(1e-6, params.volL);
  const kLa = (Cstar > 1e-9) ? ((OTR_max*1000) / (Cstar * volL)) : 0; // 1/day

  return {
    T, Cstar, areas, head,
    leak, O2_in_air_g_day, eff_bubble,
    OTR_bubble_max, OTR_surface_max, OTR_max, kLa
  };
}

/* =========================================================
   Demand model (mostly carried over)
========================================================= */
const FRACTIONS = { protein: 0.40, fat: 0.08, carb: 0.28 }; // tweak as needed
const CHEM = {
  // g O2 per g substrate oxidized to CO2 (approx)
  O2_protein_C: 1.42,
  O2_fat: 2.90,
  O2_carb: 1.185,
  CO2_per_gO2: 1.0,
  N_bio_per_COD: 0.1,

  // crude protein nitrogen fraction
  gN_per_g_protein: 1/6.25,

  // ion conversion ratios (mg/L as ion per mg/L as N)
  NH4_ion_per_N: 18.038/14.007,
  NO2_ion_per_N: 46.0055/14.007,
  NO3_ion_per_N: 62.0049/14.007,
  NH3_ion_per_N: 17.031/14.007,

  // nitrification stoich: per g N
  // NH4+ + 1.5 O2 -> NO2- + H2O + 2H+   (48 g O2 per 14 g N)
  // NO2- + 0.5 O2 -> NO3-              (16 g O2 per 14 g N)
  O2_per_gN_NH4_to_NO2: 48/14,
  O2_per_gN_NO2_to_NO3: 16/14
};

function pelletMassEach(pelLen_cm, pelDia_cm, rho_g_cm3){
  const r = pelDia_cm/2;
  const vol = Math.PI * r*r * pelLen_cm; // cm^3
  return vol * rho_g_cm3; // g
}

function nh3Fraction(pH, tempC){
  const T = tempC + 273.15;
  const pKa = 0.09018 + (2729.92 / T);
  const frac = 1 / (1 + Math.pow(10, pKa - pH));
  return clamp(frac, 0, 1);
}

function calcCO2EquilMgL(tempC){
  const tempAdj = clamp(1 - 0.02 * (tempC - 25), 0.5, 1.4);
  return clamp(0.6 * tempAdj, 0.2, 1.2);
}

function calcCO2SaturationMgL(tempC, altM){
  const tempAdj = clamp(1 - 0.03 * (tempC - 20), 0.4, 1.6);
  const pressureAdj = clamp(pressureFromAltitude_kPa(altM) / 101.325, 0.6, 1.2);
  return clamp(2.5 * tempAdj * pressureAdj, 0.5, 6.0);
}

function estimateCarbonatePartitioning(tempC, pH, alkalinity_mgL, dic_g, volL){
  const pKa1 = 6.35 - 0.015 * (tempC - 25);
  const pKa2 = 10.33 - 0.018 * (tempC - 25);
  const H = Math.pow(10, -clamp(pH, 5.5, 9.5));
  const K1 = Math.pow(10, -pKa1);
  const K2 = Math.pow(10, -pKa2);
  const alpha0 = 1 / (1 + (K1 / H) + (K1 * K2) / (H * H));
  const dic_mgL = (dic_g * 1000) / Math.max(1e-9, volL);
  const co2Free_mgL = dic_mgL * alpha0;
  const bufferCapacity = clamp(alkalinity_mgL / (alkalinity_mgL + dic_mgL + 1e-9), 0, 1);
  return {
    alpha0,
    dic_mgL,
    co2Free_mgL,
    co2Free_g: (co2Free_mgL * volL) / 1000,
    bufferCapacity
  };
}

// crude "sinks over first few days"
function sinkingHazard(day){
  if(day < 1) return 0;
  if(day >= 3) return 50;
  return 1 / Math.max(3 - day, 0.05);
}

function runSimulation(params){
  // dt: keep ~1200 points for smooth plots
  const targetPts = 1200;
  let dt = params.days/targetPts;
  dt = clamp(dt, 1/48, 1/6); // between 0.5h and 4h
  const n = Math.floor(params.days/dt) + 1;

  const oxy = oxygenationModel(params);

  // temperature factor (this is for biology only, not for physics C*)
  const Q10 = 2.0;
  const bioMult = (Number.isFinite(params.bioMult) ? params.bioMult : 1.0);

  // Kinetics base (1/day). Pellets slower than powder.
  const k_h_pel = {carb:0.35, prot:0.20, fat:0.08};
  const k_ox_pel= {carb:0.65, prot:0.40, fat:0.22};
  const Y_pel   = {carb:0.30, prot:0.42, fat:0.28};
  const k_endog_pel = 0.12;
  const k_nit_pel   = {nh4:0.75, no2:1.05};

  const k_h_pow = {carb:1.10, prot:0.80, fat:0.35};
  const k_ox_pow= {carb:1.60, prot:1.05, fat:0.55};
  const Y_pow   = {carb:0.34, prot:0.46, fat:0.30};
  const k_endog_pow = 0.18;
  const k_nit_pow   = {nh4:1.20, no2:1.70};

  const accessFloat = 1.00;
  const heaterLevel = clamp(Math.round(params.heaters || 0), 0, 2);
  const accessBottom= (heaterLevel === 2) ? 0.55 : (heaterLevel === 1 ? 0.40 : 0.30);
  const oxFloat = 1.00;
  const oxBottom= (heaterLevel === 2) ? 0.75 : (heaterLevel === 1 ? 0.55 : 0.45);

  // Pools (g as-fed broken into components)
  let pelFloat = {
    carb: params.pelletMass_g * FRACTIONS.carb,
    prot: params.pelletMass_g * FRACTIONS.protein,
    fat:  params.pelletMass_g * FRACTIONS.fat
  };
  let pelBot = {carb:0, prot:0, fat:0};
  let powBot = {
    carb: params.powderMass_g * FRACTIONS.carb,
    prot: params.powderMass_g * FRACTIONS.protein,
    fat:  params.powderMass_g * FRACTIONS.fat
  };

  let S = {carb:0, prot:0, fat:0}; // soluble pool (g)
  let S_slow = {carb:0, prot:0, fat:0}; // refractory pool (g)
  let COD_bio = 0; // g O2-eq stored in heterotroph biomass
  let N_bio = 0;   // g N stored in biomass
  let NH4 = 0;     // g N
  let NO2 = 0;     // g N
  let NO3 = 0;     // g N
  let DIC_g = 0;   // g total dissolved inorganic carbon
  let CO2_free_g = 0; // g free CO2 (aqueous)
  let macro_g = 0; // g (proxy)
  let micro_g = 0; // g (proxy)

  // Activity states (dimensionless 0..1)
  let Bhet = 0.04;
  let Bnit = 0.02;
  let Bden = 0.01;

  const Ks = 0.006; // g
  const Kn = 0.0012; // g N
  const rHet_base = 2.2;
  const dHet_base = 0.12;
  const nitQ10 = Number.isFinite(params.nitQ10) ? params.nitQ10 : 2.0;
  const rNit_base = 1.2;
  const dNit_base = 0.08;
  const rDen_base = 0.9;
  const dDen_base = 0.08;

  // DO dynamics
  const Cstar = oxy.Cstar;
  let DO = clamp(Cstar * (params.doInitPct/100), 0, Cstar*1.2);
  const kLa = oxy.kLa;

  const nitCap = clamp(Number(params.nitCap ?? 1), 0, 1);
  const denitCap = clamp(Number(params.denitCap ?? 1), 0, 1);
  const kNH4_g = (Number(params.kNH4Nit ?? 0) * params.volL) / 1000;
  const kNO2_g = (Number(params.kNO2Nit ?? 0) * params.volL) / 1000;
  const kDoHet = 0; // legacy metabolism: disable heterotroph O2 limitation
  const slowFrac = 0; // legacy metabolism: no refractory split
  const biofilmMult = 1; // legacy metabolism: no biofilm diffusion penalty
  const kDenit = 0; // legacy metabolism: denitrification off
  const fishMass = 0; // legacy metabolism: ignore fish respiration
  const fishO2 = 0;
  const plantO2 = 0; // legacy metabolism: ignore plant O2
  const tempAmp = 0; // legacy metabolism: no diurnal temperature swing
  const lightHour = 0;
  const macroRelease = Number(params.macroRelease ?? 0);
  const microRelease = Number(params.microRelease ?? 0);
  const macroUptake = Number(params.macroUptake ?? 0);
  const microUptake = Number(params.microUptake ?? 0);

  // Outputs
  const out = {
    t: new Array(n),
    rate: {
      carb:new Array(n).fill(0),
      prot:new Array(n).fill(0),
      fat:new Array(n).fill(0),
      endog:new Array(n).fill(0),
      nh4:new Array(n).fill(0),
      no2:new Array(n).fill(0),
      fish:new Array(n).fill(0),
      plant:new Array(n).fill(0),
      total:new Array(n).fill(0),
      supply:new Array(n).fill(0),
    },
    cum: {},
    DO_mgL: new Array(n).fill(0),
    DO_pct: new Array(n).fill(0),
    NH4_mgL: new Array(n).fill(0),
    NO2_mgL: new Array(n).fill(0),
    NO3_mgL: new Array(n).fill(0),
    NH3_mgL: new Array(n).fill(0),
    CO2_mgL: new Array(n).fill(0),
    DIC_mgL: new Array(n).fill(0),
    macro_mgL: new Array(n).fill(0),
    micro_mgL: new Array(n).fill(0),
    store_mgL: new Array(n).fill(0),
    chem: {
      nh4: new Array(n).fill(0),
      nh3: new Array(n).fill(0),
      no2: new Array(n).fill(0),
      no3: new Array(n).fill(0),
      co2: new Array(n).fill(0),
      dic: new Array(n).fill(0),
      store: new Array(n).fill(0),
      macro: new Array(n).fill(0),
      micro: new Array(n).fill(0),
    },
    audit: {
      nh4_from_pro:0,
      nh4_from_endog:0,
      nh4_to_no2:0,
      no2_to_no3:0,
      no3_to_n2:0,
      co2_from_ox:0,
      co2_from_endog:0,
      co2_from_denit:0,
      co2_degassed:0,
      co2_air_in:0,
      co2_air_out:0,
      o2_degassed:0,
      macro_release:0,
      macro_uptake:0,
      micro_release:0,
      micro_uptake:0,
      phyto_grazed:0,
      phyto_algae_grazed:0,
      phyto_plankton_grazed:0,
      biofilm_grazed:0,
      predator_grazed:0,
      biofilm_grazing_waste:0,
      predator_grazing_waste:0,
      n_balance_init:0,
      n_balance_end:0,
      c_balance_init:0,
      c_balance_end:0
    },
    meta: { dt, oxy, kLa, nitCap, denitCap, feedStart:0, feedEnd:0, maxDemand:0, maxSupply:0 }
  };

  // Events sorted
  const ev = [...params.events]
    .filter(e=>Number.isFinite(e.day) && Number.isFinite(e.pellets) && e.pellets>0)
    .sort((a,b)=>a.day-b.day);
  let evIdx = 0;
  const feeds = [...feedSchedule]
    .filter(e=>Number.isFinite(e.day))
    .sort((a,b)=>a.day-b.day);
  let feedIdx = 0;

  const pelletEachMass = pelletMassEach(params.pelLen, params.pelDia, params.pelRho);

  function blend(a,b,w){ return a*(1-w) + b*w; }

  function pelTotalComp(){
    return {
      carb: pelFloat.carb + pelBot.carb,
      prot: pelFloat.prot + pelBot.prot,
      fat:  pelFloat.fat  + pelBot.fat
    };
  }
  function removeFromPellets(compMass){
    for(const k of ["carb","prot","fat"]){
      let need = compMass[k];
      const takeF = Math.min(need, pelFloat[k]);
      pelFloat[k] -= takeF;
      need -= takeF;
      const takeB = Math.min(need, pelBot[k]);
      pelBot[k] -= takeB;
    }
  }
  function addToPowder(compMass){
    for(const k of ["carb","prot","fat"]) powBot[k] += compMass[k];
  }

  function fluxPellet(Pmass, k, access){
    // surface-limited intact pellet: ~ M^(2/3)
    return k * access * Math.pow(Math.max(Pmass,0), 2/3);
  }
  function fluxPowder(Pmass, k){
    // distributed powder: first-order
    return k * Math.max(Pmass,0);
  }
  function capFlux(flux, mass){
    if(mass <= 0) return 0;
    return Math.min(flux, mass/dt);
  }

  const initialN = params.pelletMass_g * FRACTIONS.protein * CHEM.gN_per_g_protein
    + params.powderMass_g * FRACTIONS.protein * CHEM.gN_per_g_protein;
  const initialC = params.pelletMass_g + params.powderMass_g;
  out.audit.n_balance_init = initialN;
  out.audit.c_balance_init = initialC;
  out.meta.feedStart = initialC;

  for(let i=0;i<n;i++){
    const day = i*dt;
    out.t[i] = day;

    const dielPhase = 2 * Math.PI * ((day + lightHour/24) % 1);
    const lightFactor = Math.max(0, Math.sin(dielPhase));
    const tempNow = oxy.T + tempAmp * Math.sin(dielPhase);
    const tempF = clamp(Math.pow(Q10, (tempNow - 25.0)/10) * bioMult, 0.25, 6.0);
    const tempFNit = Math.pow(nitQ10, (tempNow - 25.0)/10);
    const rHet = rHet_base * tempF;
    const dHet = dHet_base * tempF;
    const rNit = rNit_base * tempFNit;
    const dNit = dNit_base * tempFNit;
    const rDen_grow = rDen_base * tempF;
    const dDen = dDen_base * tempF;

    // Apply pop events at this time slice
    while(evIdx < ev.length && ev[evIdx].day <= day + dt/2){
      const e = ev[evIdx];
      const popMass_asfed = e.pellets * pelletEachMass;
      const popComp = {
        carb: popMass_asfed * FRACTIONS.carb,
        prot: popMass_asfed * FRACTIONS.protein,
        fat:  popMass_asfed * FRACTIONS.fat
      };
      const avail = pelTotalComp();
      const availTot = avail.carb+avail.prot+avail.fat;
      const wantTot = popComp.carb+popComp.prot+popComp.fat;
      const scale = (availTot>0 && wantTot>0) ? Math.min(1.0, availTot/wantTot) : 0;
      if(scale>0){
        const capped = {carb: popComp.carb*scale, prot: popComp.prot*scale, fat: popComp.fat*scale};
        removeFromPellets(capped);
        addToPowder(capped);
      }
      evIdx++;
    }

    // Sinking
    const hz = sinkingHazard(day);
    for(const k of ["carb","prot","fat"]){
      const dM = Math.min(hz * pelFloat[k] * dt, pelFloat[k]);
      pelFloat[k] -= dM;
      pelBot[k]   += dM;
    }
    const resus = clamp((params.ripplePct/100) * 0.15 + (params.airFlow/10) * 0.02, 0, 0.25);
    for(const k of ["carb","prot","fat"]){
      const up = Math.min(resus * pelBot[k] * dt, pelBot[k]);
      pelBot[k] -= up;
      pelFloat[k] += up;
    }

    // Blend kinetics based on how much is in powder state
    const pelMassNow = pelFloat.carb+pelFloat.prot+pelFloat.fat + pelBot.carb+pelBot.prot+pelBot.fat;
    const powMassNow = powBot.carb+powBot.prot+powBot.fat;
    const wPow = (pelMassNow + powMassNow) > 0 ? (powMassNow/(pelMassNow+powMassNow)) : 0;

    // Blend oxidation coefficients and yields
    const k_ox = {
      carb: tempF * blend(k_ox_pel.carb, k_ox_pow.carb, wPow),
      prot: tempF * blend(k_ox_pel.prot, k_ox_pow.prot, wPow),
      fat:  tempF * blend(k_ox_pel.fat,  k_ox_pow.fat,  wPow)
    };
    const Y = {
      carb: blend(Y_pel.carb, Y_pow.carb, wPow),
      prot: blend(Y_pel.prot, Y_pow.prot, wPow),
      fat:  blend(Y_pel.fat,  Y_pow.fat,  wPow)
    };
    const k_endog = tempF * blend(k_endog_pel, k_endog_pow, wPow);
    const k_nit_base = {
      nh4: tempFNit * blend(k_nit_pel.nh4, k_nit_pow.nh4, wPow),
      no2: tempFNit * blend(k_nit_pel.no2, k_nit_pow.no2, wPow)
    };

    // Optionally slow nitrification at low DO (a simple Monod term).
    let nitO2Mult = 1.0;
    if(params.o2Limit === "on"){
      const K = Math.max(1e-6, params.kDoNit);
      nitO2Mult = DO / (K + DO);
    }
    const k_nit = { nh4: k_nit_base.nh4 * nitO2Mult, no2: k_nit_base.no2 * nitO2Mult };

    // Hydrolysis coefficients
    const k_h_p = {
      carb: tempF * k_h_pel.carb,
      prot: tempF * k_h_pel.prot,
      fat:  tempF * k_h_pel.fat
    };
    const k_h_w = {
      carb: tempF * k_h_pow.carb,
      prot: tempF * k_h_pow.prot,
      fat:  tempF * k_h_pow.fat
    };

    let hydroTot = 0;
    // Hydrolysis fluxes per component
    for(const k of ["carb","prot","fat"]){
      const hf = capFlux(fluxPellet(pelFloat[k], k_h_p[k], accessFloat), pelFloat[k]);
      const hb = capFlux(fluxPellet(pelBot[k],   k_h_p[k], accessBottom), pelBot[k]);
      const hw = capFlux(fluxPowder(powBot[k],   k_h_w[k]), powBot[k]);

      pelFloat[k] -= hf*dt;
      pelBot[k]   -= hb*dt;
      powBot[k]   -= hw*dt;

      const fast = (hf+hb+hw) * (1 - slowFrac) * dt;
      const slow = (hf+hb+hw) * slowFrac * dt;
      S[k] += fast;
      S_slow[k] += slow;
      hydroTot += (hf+hb+hw)*dt;
    }

    for(const k of ["carb","prot","fat"]){
      const rel = Math.min(S_slow[k], (0.08 * tempF) * S_slow[k] * dt);
      S_slow[k] -= rel;
      S[k] += rel;
    }

    // Mixing penalty when hydrolysis happens mostly in bottom pellets
    const hPelFloat = fluxPellet(pelFloat.carb,k_h_p.carb,accessFloat)+fluxPellet(pelFloat.prot,k_h_p.prot,accessFloat)+fluxPellet(pelFloat.fat,k_h_p.fat,accessFloat);
    const hPelBot   = fluxPellet(pelBot.carb,k_h_p.carb,accessBottom)+fluxPellet(pelBot.prot,k_h_p.prot,accessBottom)+fluxPellet(pelBot.fat,k_h_p.fat,accessBottom);
    const hPow      = fluxPowder(powBot.carb,k_h_w.carb)+fluxPowder(powBot.prot,k_h_w.prot)+fluxPowder(powBot.fat,k_h_w.fat);
    const denom = (hPelFloat+hPelBot+hPow) + 1e-12;
    const mixMult = (oxFloat*hPelFloat + oxBottom*hPelBot + 1.0*hPow) / denom;

    // Nutrient release from hydrolyzed food (macro/micro proxy)
    const macroAdd_g = (macroRelease * hydroTot * params.volL) / 1000;
    const microAdd_g = (microRelease * hydroTot * params.volL) / 1000;
    macro_g += macroAdd_g;
    micro_g += microAdd_g;
    out.audit.macro_release += macroAdd_g;
    out.audit.micro_release += microAdd_g;

    // Oxidation of solubles
    const ox = {carb:0, prot:0, fat:0};
    for(const k of ["carb","prot","fat"]){
      const Ks_sub = 0.02;
      const fS = S[k] / (Ks_sub + S[k]);
      const fO2 = DO / (kDoHet + DO);
      const flux = k_ox[k] * Bhet * mixMult * fS * fO2 * S[k];
      ox[k] = Math.min(flux, S[k]/dt);
      S[k] -= ox[k]*dt;
    }

    // Oxygen demand (rates)
    const O2_carb = ox.carb * CHEM.O2_carb * (1 - Y.carb);
    const O2_prot = ox.prot * CHEM.O2_protein_C * (1 - Y.prot);
    const O2_fat  = ox.fat  * CHEM.O2_fat * (1 - Y.fat);

    // Biomass storage and endogenous respiration
    const COD_store = ox.carb*CHEM.O2_carb*Y.carb + ox.prot*CHEM.O2_protein_C*Y.prot + ox.fat*CHEM.O2_fat*Y.fat;
    const N_store   = ox.prot * CHEM.gN_per_g_protein * Y.prot;
    const NH4_prod  = ox.prot * CHEM.gN_per_g_protein * (1 - Y.prot);

    const endog = Math.min(k_endog * COD_bio, COD_bio/dt);
    const O2_endog = endog;
    const N_rel = (COD_bio > 1e-12) ? (N_bio / COD_bio) * endog : 0;

    COD_bio = COD_bio + COD_store*dt - endog*dt;
    const N_need = COD_store * CHEM.N_bio_per_COD;
    const N_assim = Math.min(NH4, Math.max(0, N_need - N_store) * dt);
    NH4 = NH4 - N_assim;
    N_bio   = N_bio   + N_store*dt + N_assim - N_rel*dt;

    // Nitrification (sequential)
    NH4 = NH4 + (NH4_prod + N_rel)*dt;

    const fNH4 = (kNH4_g > 0) ? (NH4 / (kNH4_g + NH4)) : 1.0;
    const fNO2 = (kNO2_g > 0) ? (NO2 / (kNO2_g + NO2)) : 1.0;

    const r1 = Math.min(Bnit * k_nit.nh4 * fNH4 * biofilmMult * NH4, NH4/dt); // g N/day
    NH4 = NH4 - r1*dt;
    NO2 = NO2 + r1*dt;

    const r2 = Math.min(Bnit * k_nit.no2 * fNO2 * biofilmMult * NO2, NO2/dt);
    NO2 = NO2 - r2*dt;
    NO3 = NO3 + r2*dt;

    const O2_nh4 = r1 * CHEM.O2_per_gN_NH4_to_NO2;
    const O2_no2 = r2 * CHEM.O2_per_gN_NO2_to_NO3;

    const fAnox = clamp(1 - DO/(kDoHet + DO), 0, 1);
    const rDen_flux = Math.min(Bden * kDenit * fAnox * NO3, NO3/dt);
    NO3 = NO3 - rDen_flux*dt;
    const COD_den = Math.min(COD_bio, rDen_flux * 2.5);
    COD_bio = Math.max(0, COD_bio - COD_den*dt);
    const CO2_den = COD_den;
    DIC_g += CO2_den * dt;
    out.audit.no3_to_n2 += rDen_flux * dt;
    out.audit.co2_from_denit += CO2_den * dt;

    const demand = O2_carb + O2_prot + O2_fat + O2_endog + O2_nh4 + O2_no2;

    const CO2_from_ox = (O2_carb + O2_prot + O2_fat) * CHEM.CO2_per_gO2;
    const CO2_from_endog = O2_endog * CHEM.CO2_per_gO2;
    CO2_g += (CO2_from_ox + CO2_from_endog) * dt;
    out.audit.co2_from_ox += CO2_from_ox * dt;
    out.audit.co2_from_endog += CO2_from_endog * dt;
    const co2PartitionLate = estimateCarbonatePartitioning(tempSmooth, params.pH ?? 7.0, alkalinity_mgL, DIC_g, params.volL);
    CO2_free_g = co2PartitionLate.co2Free_g;
    bufferCapacityMin = Math.min(bufferCapacityMin, co2PartitionLate.bufferCapacity);
    bufferCapacityLast = co2PartitionLate.bufferCapacity;
    co2FreeMin_mgL = Math.min(co2FreeMin_mgL, co2PartitionLate.co2Free_mgL);
    co2FreeLast_mgL = co2PartitionLate.co2Free_mgL;
    dicMin_mgL = Math.min(dicMin_mgL, co2PartitionLate.dic_mgL);
    dicLast_mgL = co2PartitionLate.dic_mgL;
    const co2Equil_mgL = co2Init_mgL;
    const co2SatDef_mgL = co2Equil_mgL - co2PartitionLate.co2Free_mgL;
    const kLaCO2 = oxy.kLa * 0.6;
    const co2AirFlux_g_day = (kLaCO2 * co2SatDef_mgL * params.volL) / 1000;
    const co2AirFlux_g = co2AirFlux_g_day * dt;
    DIC_g += co2AirFlux_g;
    if(co2AirFlux_g >= 0){
      co2AirIn_g += co2AirFlux_g;
      out.audit.co2_air_in += co2AirFlux_g;
    }else{
      const degas_g = Math.abs(co2AirFlux_g);
      co2AirOut_g += degas_g;
      out.audit.co2_air_out += degas_g;
    }
    if(co2PartitionLate.co2Free_g > co2Sat_g){
      const excessFree_g = co2PartitionLate.co2Free_g - co2Sat_g;
      const dicReduce = excessFree_g / Math.max(co2PartitionLate.alpha0, 1e-6);
      DIC_g = Math.max(0, DIC_g - dicReduce);
      co2DegasSteps++;
      co2Degassed_g += excessFree_g;
      out.audit.co2_degassed += excessFree_g;
    }

    out.audit.nh4_from_pro += NH4_prod * dt;
    out.audit.nh4_from_endog += N_rel * dt;
    out.audit.nh4_to_no2 += r1 * dt;
    out.audit.no2_to_no3 += r2 * dt;

    // DO dynamics (Euler)
    // supply_g_day = kLa*(C* - DO)*V
    const supply_g_day = (kLa * Math.max(0, (Cstar - DO)) * params.volL) / 1000;
    const plant_g_day = (plantO2 * lightFactor * params.volL) / 1000;
    const fish_g_day = (fishMass * fishO2) / 1000;
    const dDO = ((supply_g_day + plant_g_day - demand - fish_g_day) * 1000 / params.volL) * dt; // mg/L
    DO = clamp(DO + dDO, 0, Cstar*1.2);

    // Record outputs
    out.rate.carb[i]  = O2_carb;
    out.rate.prot[i]  = O2_prot;
    out.rate.fat[i]   = O2_fat;
    out.rate.endog[i] = O2_endog;
    out.rate.nh4[i]   = O2_nh4;
    out.rate.no2[i]   = O2_no2;
    out.rate.fish[i]  = fish_g_day;
    out.rate.plant[i] = plant_g_day;
    out.rate.total[i] = demand + fish_g_day;
    out.rate.supply[i]= supply_g_day + plant_g_day;
    out.meta.maxDemand = Math.max(out.meta.maxDemand, out.rate.total[i]);
    out.meta.maxSupply = Math.max(out.meta.maxSupply, out.rate.supply[i]);

    out.DO_mgL[i] = DO;
    out.DO_pct[i] = (Cstar>1e-9) ? (100*DO/Cstar) : 0;

    out.NH4_mgL[i] = (NH4*1000)/params.volL;
    out.NO2_mgL[i] = (NO2*1000)/params.volL;
    out.NO3_mgL[i] = (NO3*1000)/params.volL;

    const nh3Frac = nh3Fraction(params.pH ?? 7.0, oxy.T);
    const nh3AsN = out.NH4_mgL[i] * nh3Frac;
    out.NH3_mgL[i] = nh3AsN * CHEM.NH3_ion_per_N;

    CO2_g = Math.max(0, CO2_g - plant_g_day * CHEM.CO2_per_gO2 * dt);
    out.CO2_mgL[i] = (CO2_g*1000)/params.volL;

    const macroUptake_g = Math.min(macro_g, (macroUptake * params.volL / 1000) * dt);
    const microUptake_g = Math.min(micro_g, (microUptake * params.volL / 1000) * dt);
    macro_g = Math.max(0, macro_g - macroUptake_g);
    micro_g = Math.max(0, micro_g - microUptake_g);
    out.audit.macro_uptake += macroUptake_g;
    out.audit.micro_uptake += microUptake_g;

    out.macro_mgL[i] = (macro_g*1000)/params.volL;
    out.micro_mgL[i] = (micro_g*1000)/params.volL;

    out.DIC_mgL[i] = (DIC_g*1000)/params.volL;
    out.store_mgL[i] = 0;

    out.chem.nh4[i] = out.NH4_mgL[i];
    out.chem.nh3[i] = out.NH3_mgL[i];
    out.chem.no2[i] = out.NO2_mgL[i];
    out.chem.no3[i] = out.NO3_mgL[i];
    out.chem.co2[i] = out.CO2_mgL[i];
    out.chem.dic[i] = out.DIC_mgL[i];
    out.chem.store[i] = out.store_mgL[i];
    out.chem.macro[i] = out.macro_mgL[i];
    out.chem.micro[i] = out.micro_mgL[i];

    // Update activity states
    const S_tot = S.carb + S.prot + S.fat;
    const fS = S_tot / (Ks + S_tot);
    const fN = NH4 / (Kn + NH4);

    Bhet = clamp(Bhet + (rHet*fS*(1-Bhet) - dHet*Bhet)*dt, 0.0, 1.0);
    Bnit = clamp(Bnit + (rNit*fN*(nitCap-Bnit) - dNit*Bnit)*dt, 0.0, nitCap);
    const fDen = NO3 / (Kn + NO3);
    Bden = clamp(Bden + (rDen_grow*fDen*(denitCap-Bden) - dDen*Bden)*dt, 0.0, denitCap);
  }

  const chemCumResult = buildCumulativeSeries(out.chem, dt);
  out.chemCum = chemCumResult.series;
  out.meta.chemCumInfo = chemCumResult.info;

  out.audit.n_balance_end = NH4 + NO2 + NO3 + N_bio;
  out.audit.c_balance_end = CO2_g + COD_bio + S.carb + S.prot + S.fat + S_slow.carb + S_slow.prot + S_slow.fat
    + pelFloat.carb + pelFloat.prot + pelFloat.fat + pelBot.carb + pelBot.prot + pelBot.fat + powBot.carb + powBot.prot + powBot.fat;
  out.meta.feedEnd = pelFloat.carb + pelFloat.prot + pelFloat.fat + pelBot.carb + pelBot.prot + pelBot.fat + powBot.carb + powBot.prot + powBot.fat;
  if(initialN > 0 && Math.abs(out.audit.n_balance_end - initialN)/initialN > 0.15){
    addWarning('Nitrogen balance drift exceeds 15% ‚Äî check kinetics or timestep.');
  }
  if(initialC > 0 && Math.abs(out.audit.c_balance_end - initialC)/initialC > 0.25){
    addWarning('Carbon balance drift exceeds 25% ‚Äî check hydrolysis/CO2 terms.');
  }

  return out;
}
/* =========================================================
   Uncertainty mode (Monte Carlo)
========================================================= */

// Small PRNG so ‚Äúseed‚Äù is reproducible across browsers.
function mulberry32(seed){
  let a = seed >>> 0;
  return function(){
    a |= 0; a = (a + 0x6D2B79F5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function randn(rng){
  // Box‚ÄìMuller
  let u = 0, v = 0;
  while(u === 0) u = rng();
  while(v === 0) v = rng();
  return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}

function sampleLogNormalMean1(rng, cv){
  // lognormal with mean=1 and desired coefficient of variation
  const sigma = Math.sqrt(Math.log(1 + cv*cv));
  const mu = -0.5 * sigma * sigma;
  return Math.exp(mu + sigma * randn(rng));
}

function bandToQuantiles(bandPreset){
  if(bandPreset === '25-75') return {qLo:0.25, qHi:0.75};
  if(bandPreset === '5-95')  return {qLo:0.05, qHi:0.95};
  return {qLo:0.10, qHi:0.90}; // default 10‚Äì90
}

function profileForLevel(level){
  // These are ‚Äúpriors‚Äù: intentionally conservative. With calibration, shrink these.
  if(level === 'tight'){
    return {cvFlow:0.07, cvSote:0.12, cvSurf:0.18, cvBio:0.18, sdTemp:0.35, sdTight:0.10, cvInit:0.06};
  }
  if(level === 'wide'){
    return {cvFlow:0.25, cvSote:0.55, cvSurf:0.70, cvBio:0.70, sdTemp:1.20, sdTight:0.35, cvInit:0.18};
  }
  return {cvFlow:0.14, cvSote:0.30, cvSurf:0.35, cvBio:0.35, sdTemp:0.70, sdTight:0.20, cvInit:0.10}; // typical
}

function meanDeliveryFactor(diffType){
  // Rated pump flow is often higher than delivered flow once you add depth + diffuser backpressure.
  // This is a gentle, realism-biased default. Uncertainty adds noise around it.
  if(diffType === 'wood') return 0.65;
  if(diffType === 'microbubble') return 0.70;
  if(diffType === 'airstone_fine') return 0.80;
  return 0.90; // airstone_med or custom
}

function quantileFromSorted(sorted, q){
  if(sorted.length === 0) return NaN;
  const x = q * (sorted.length - 1);
  const i0 = Math.floor(x);
  const i1 = Math.min(sorted.length - 1, i0 + 1);
  const t = x - i0;
  return sorted[i0] * (1 - t) + sorted[i1] * t;
}

function scalarStats(values, qLo, qHi){
  const arr = values.slice().sort((a,b)=>a-b);
  return {
    lo: quantileFromSorted(arr, qLo),
    mid: quantileFromSorted(arr, 0.5),
    hi: quantileFromSorted(arr, qHi)
  };
}

function runMonteCarlo(baseParams){
  const runs = clamp(Math.round(baseParams.mcRuns || 0), 10, 5000);
  const {qLo, qHi} = bandToQuantiles(baseParams.bandPreset);
  const prof = profileForLevel(baseParams.uncLevel);
  const rng = mulberry32((Number.isFinite(baseParams.seed) ? baseParams.seed : 12345) | 0);

  // Keep time grid consistent for all runs by using base dt (as implemented inside runSimulation).
  // (runSimulation derives dt only from days.)
  const baseSim = runSimulation(baseParams);
  const n = baseSim.t.length;

  // Store per-run arrays we care about
  const DO_runs = new Array(runs);
  const tot_runs = new Array(runs);
  const sup_runs = new Array(runs);
  const cum_runs = new Array(runs);
  const chem_runs = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, new Array(runs)]));

  // Per-run scalars
  const minDO = new Array(runs);
  const minDO_day = new Array(runs);
  const under2 = new Array(runs);
  const under1 = new Array(runs);
  const deficitArea = new Array(runs);
  const nh4pk = new Array(runs);
  const no2pk = new Array(runs);
  const no3pk = new Array(runs);
  const nh3pk = new Array(runs);
  const co2pk = new Array(runs);
  const macroPk = new Array(runs);
  const microPk = new Array(runs);
  const storeMin = new Array(runs);
  const otrMax = new Array(runs);
  const kLa = new Array(runs);
  const Cstar = new Array(runs);
  const effFlow = new Array(runs);

  for(let r=0;r<runs;r++){
    const p = JSON.parse(JSON.stringify(baseParams)); // cheap clone; fine at these sizes

    // Sample uncertainties around the base choices
    if(baseParams.u && baseParams.u.temp){
      p.Tnow = p.Tnow + randn(rng) * prof.sdTemp;
    }

    if(baseParams.u && baseParams.u.initDO){
      p.doInitPct = clamp(p.doInitPct * sampleLogNormalMean1(rng, prof.cvInit), 10, 150);
    }

    if(baseParams.u && baseParams.u.tight){
      p.tight = clamp(p.tight + randn(rng) * prof.sdTight, 0, 1);
    }

    // Delivered flow: treat user-entered flow as ‚Äúrated-ish‚Äù, then sample delivery factor.
    if(baseParams.u && baseParams.u.air){
      const mean = meanDeliveryFactor(p.diffType);
      const mult = sampleLogNormalMean1(rng, prof.cvFlow);
      p.airFlow = clamp(p.airFlow * mean * mult, 0.05, 50);
      effFlow[r] = p.airFlow;
    }else{
      effFlow[r] = p.airFlow;
    }

    if(baseParams.u && baseParams.u.diff){
      p.sotePerM = clamp(p.sotePerM * sampleLogNormalMean1(rng, prof.cvSote), 0.1, 25);
    }

    if(baseParams.u && baseParams.u.surf){
      const m = sampleLogNormalMean1(rng, prof.cvSurf);
      const m2 = sampleLogNormalMean1(rng, prof.cvSurf * 0.35);
      p.kCalm = clamp(p.kCalm * m, 0.01, 6.0);
      p.kRipple = clamp(p.kRipple * m * m2, 0.01, 10.0);
    }

    if(baseParams.u && baseParams.u.bio){
      p.bioMult = clamp(sampleLogNormalMean1(rng, prof.cvBio), 0.1, 6.0);
    }else{
      p.bioMult = 1.0;
    }

    const sim = runSimulation(p);
    DO_runs[r]  = sim.DO_mgL;
    tot_runs[r] = sim.rate.total;
    sup_runs[r] = sim.rate.supply;
    cum_runs[r] = sim.cum.total;
    for(const s of CHEM_SERIES){
      chem_runs[s.key][r] = (sim.chemCum || sim.chem)[s.key];
    }

    // scalars
    let dmin = Infinity, dminDay = 0;
    let tU2 = 0, tU1 = 0;
    let defA = 0;
    for(let i=0;i<n;i++){
      const d = sim.DO_mgL[i];
      if(d < dmin){ dmin = d; dminDay = sim.t[i]; }
      if(d < 2.0) tU2 += sim.meta.dt;
      if(d < 1.0) tU1 += sim.meta.dt;
      const def = sim.rate.total[i] - sim.rate.supply[i];
      if(def > 0) defA += def * sim.meta.dt; // g/day * day = g
    }
    minDO[r] = dmin;
    minDO_day[r] = dminDay;
    under2[r] = tU2;
    under1[r] = tU1;
    deficitArea[r] = defA;

    let nh = 0, n2 = 0, n3 = 0, nh3 = 0, co2 = 0, mA = 0, mI = 0;
    let storeFloor = Infinity;
    for(let i=0;i<sim.NH4_mgL.length;i++) if(sim.NH4_mgL[i] > nh) nh = sim.NH4_mgL[i];
    for(let i=0;i<sim.NO2_mgL.length;i++) if(sim.NO2_mgL[i] > n2) n2 = sim.NO2_mgL[i];
    for(let i=0;i<sim.NO3_mgL.length;i++) if(sim.NO3_mgL[i] > n3) n3 = sim.NO3_mgL[i];
    for(let i=0;i<sim.NH3_mgL.length;i++) if(sim.NH3_mgL[i] > nh3) nh3 = sim.NH3_mgL[i];
    for(let i=0;i<sim.CO2_mgL.length;i++) if(sim.CO2_mgL[i] > co2) co2 = sim.CO2_mgL[i];
    for(let i=0;i<sim.macro_mgL.length;i++) if(sim.macro_mgL[i] > mA) mA = sim.macro_mgL[i];
    for(let i=0;i<sim.micro_mgL.length;i++) if(sim.micro_mgL[i] > mI) mI = sim.micro_mgL[i];
    for(let i=0;i<sim.store_mgL.length;i++) if(sim.store_mgL[i] < storeFloor) storeFloor = sim.store_mgL[i];
    nh4pk[r] = nh;
    no2pk[r] = n2;
    no3pk[r] = n3;
    nh3pk[r] = nh3;
    co2pk[r] = co2;
    macroPk[r] = mA;
    microPk[r] = mI;
    storeMin[r] = Number.isFinite(storeFloor) ? storeFloor : 0;

    otrMax[r] = oxySafe.OTR_max;
    kLa[r] = oxySafe.kLa;
    Cstar[r] = oxySafe.Cstar;
  }

  // Quantile arrays (time series)
  const qDO = {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)};
  const qTot= {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)};
  const qSup= {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)};
  const qCum= {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)};
  const qChem = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}]));

  const tmp = new Array(runs);
  let mcMissingRows = 0;
  let mcMissingValues = 0;
  const mcSeriesFallbacks = new Set();

  function fillQ(srcRuns, out, fallbackSeries, label){
    for(let i=0;i<n;i++){
      for(let r=0;r<runs;r++){
        const row = srcRuns[r];
        if(!row || !Array.isArray(row)){
          mcMissingRows += 1;
          if(label) mcSeriesFallbacks.add(label);
          tmp[r] = fallbackSeries ? fallbackSeries[i] : 0;
          continue;
        }
        const value = row[i];
        if(!Number.isFinite(value)){
          mcMissingValues += 1;
          if(label) mcSeriesFallbacks.add(label);
          tmp[r] = fallbackSeries ? fallbackSeries[i] : 0;
          continue;
        }
        tmp[r] = value;
      }
      tmp.sort((a,b)=>a-b);
      out.lo[i]  = quantileFromSorted(tmp, qLo);
      out.mid[i] = quantileFromSorted(tmp, 0.5);
      out.hi[i]  = quantileFromSorted(tmp, qHi);
    }
  }

  fillQ(DO_runs, qDO);
  fillQ(tot_runs, qTot);
  fillQ(sup_runs, qSup);
  fillQ(cum_runs, qCum);
  for(const s of CHEM_SERIES){
    fillQ(chem_runs[s.key], qChem[s.key]);
  }

  // Scalar bands
  const sMinDO = scalarStats(minDO, qLo, qHi);
  const sMinDODay = scalarStats(minDO_day, qLo, qHi);
  const sDefA  = scalarStats(deficitArea, qLo, qHi);
  const sNH4   = scalarStats(nh4pk, qLo, qHi);
  const sNO2   = scalarStats(no2pk, qLo, qHi);
  const sNO3   = scalarStats(no3pk, qLo, qHi);
  const sNH3   = scalarStats(nh3pk, qLo, qHi);
  const sCO2   = scalarStats(co2pk, qLo, qHi);
  const sMacro = scalarStats(macroPk, qLo, qHi);
  const sMicro = scalarStats(microPk, qLo, qHi);
  const sStoreMin = scalarStats(storeMin, qLo, qHi);
  const sOTR   = scalarStats(otrMax, qLo, qHi);
  const sKLA   = scalarStats(kLa, qLo, qHi);
  const sCstar = scalarStats(Cstar, qLo, qHi);

  // Probabilities (based on min DO)
  let pU2 = 0, pU1 = 0;
  for(let r=0;r<runs;r++){
    if(minDO[r] < 2.0) pU2++;
    if(minDO[r] < 1.0) pU1++;
  }
  pU2 /= runs; pU1 /= runs;

  return {
    baseSim,
    q: {DO:qDO, rateTotal:qTot, rateSupply:qSup, cumTotal:qCum, chemBands:qChem},
    scalars: {
      minDO:sMinDO,
      minDO_day:sMinDODay,
      deficitArea:sDefA,
      nh4pk:sNH4,
      no2pk:sNO2,
      no3pk:sNO3,
      nh3pk:sNH3,
      co2pk:sCO2,
      macroPk:sMacro,
      microPk:sMicro,
      storeMin:sStoreMin,
      otrMax:sOTR,
      kLa:sKLA,
      Cstar:sCstar,
      runs
    },
    probs: {anyUnder2:pU2, anyUnder1:pU1}
  };
}


/* =========================================================
   Plotting (canvas)
========================================================= */


// ---- Chart scaling helpers (avoid ‚Äúmystery math‚Äù, just readable axes) ----
// niceTop(yMax): round the plot ceiling to 1/2/5 * 10^n
function niceTop(max){
  max = Math.max(0, max);
  if(max === 0) return 1;
  const p = Math.pow(10, Math.floor(Math.log10(max)));
  const n = max / p;
  let top;
  if(n <= 1) top = 1;
  else if(n <= 2) top = 2;
  else if(n <= 5) top = 5;
  else top = 10;
  return top * p;
}
// niceStep(yTop): choose a ‚Äúpleasant‚Äù grid step for ~4‚Äì6 lines
function niceStep(top){
  top = Math.max(0, top);
  if(top === 0) return 1;
  const raw = top / 5;
  const p = Math.pow(10, Math.floor(Math.log10(raw)));
  const n = raw / p;
  let step;
  if(n < 1.5) step = 1 * p;
  else if(n < 3) step = 2 * p;
  else if(n < 7) step = 5 * p;
  else step = 10 * p;
  return step;
}

// niceXStep(xMax): choose a pleasant x-grid step (days) for ~5‚Äì7 vertical lines.
function niceXStep(xMax){
  xMax = Math.max(1e-9, xMax);
  const targetLines = 6;
  const raw = xMax / targetLines;
  const p = Math.pow(10, Math.floor(Math.log10(raw)));
  const n = raw / p;
  let step;
  if(n < 1.5) step = 1 * p;
  else if(n < 3) step = 2 * p;
  else if(n < 7) step = 5 * p;
  else step = 10 * p;
  // Avoid ‚Äú0‚Äù step and keep labels sensible for short runs
  if(step <= 0) step = xMax;
  // If the run is very short, allow half-day ticks
  if(xMax <= 5 && step > 1) step = 1;
  if(xMax <= 2 && step > 0.5) step = 0.5;
  return step;
}

function drawPlot(canvas, tArr, seriesDict, opts={}){
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const m = {l:56*devicePixelRatio, r:56*devicePixelRatio, t:30*devicePixelRatio, b:34*devicePixelRatio};
  const pw = w - m.l - m.r;
  const ph = h - m.t - m.b;

  const xMax = tArr[tArr.length-1] || 1;

  const seriesList = opts.series || RATE_SERIES;
  const visibleMap = opts.visible || visibleRate;

  // y max from visible series + optional bands
  let yMax = 0;
  for(const s of seriesList){
    if(!visibleMap[s.key]) continue;
    const arr = seriesDict[s.key];
    if(arr) for(const v of arr) if(v>yMax) yMax=v;
  }
  if(opts.bands){
    for(const key of Object.keys(opts.bands)){
      if(visibleMap[key] === false) continue;
      const b = opts.bands[key];
      if(b && b.hi){
        for(let i=0;i<b.hi.length;i++){
          const v = b.hi[i];
          if(v>yMax) yMax=v;
        }
      }
    }
  }
  yMax = Math.max(0.0001, yMax);
  const yTop = niceTop(yMax);
  const yStep = niceStep(yTop);

  // frame
  ctx.strokeStyle = 'rgba(231,236,255,0.18)';
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.strokeRect(m.l, m.t, pw, ph);

  // grid
  ctx.strokeStyle = 'rgba(231,236,255,0.06)';
  ctx.lineWidth = 1*devicePixelRatio;
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
  }
  const xStep = niceXStep(xMax);
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.beginPath();
    ctx.moveTo(px, m.t);
    ctx.lineTo(px, m.t+ph);
    ctx.stroke();
  }

  // axis labels
  ctx.fillStyle = 'rgba(231,236,255,0.75)';
  ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    const txt = (yTop >= 1) ? y.toFixed(2) : y.toExponential(2);
    ctx.fillText(txt, m.l-8, py);
  }
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.fillStyle = 'rgba(231,236,255,0.70)';
    const xLbl = (xStep < 1) ? x.toFixed(1) : String(Math.round(x));

        ctx.fillText(xLbl, px, m.t+ph+10);
  }

  // title
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillStyle = 'rgba(231,236,255,0.9)';
  ctx.font = `13px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
  ctx.fillText(opts.title || '', m.l, 10);

  // helper: band fill
  const drawBand = (lo, hi, alpha, color)=>{
    if(!lo || !hi) return;
    ctx.save();
    ctx.globalAlpha = alpha ?? 0.15;
    ctx.fillStyle = color;
    ctx.beginPath();
    // upper
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (hi[i]/yTop)*ph;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    // lower (reverse)
    for(let i=tArr.length-1;i>=0;i--){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (lo[i]/yTop)*ph;
      ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  };

  // draw bands first (so lines sit on top)
  if(opts.bands){
    for(const [key,b] of Object.entries(opts.bands)){
      if(visibleMap[key] === false) continue;
      let color = 'rgba(255,140,171,1)'; // demand-ish
      if(key === 'supply') color = 'rgba(97,230,180,1)';
      if(key === 'total')  color = 'rgba(255,140,171,1)';
      if(opts.bandColors && opts.bandColors[key]) color = opts.bandColors[key];
      drawBand(b.lo, b.hi, b.alpha ?? 0.14, color);
    }
  }

  // series (base lines)
  for(const s of seriesList){
    if(!visibleMap[s.key]) continue;
    const arr = seriesDict[s.key];
    if(!arr) continue;

    // If we have uncertainty bands for this series, draw base line more subtly to avoid clutter
    const hasBand = opts.bands && opts.bands[s.key] && opts.bands[s.key].mid;
    if(hasBand){
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.setLineDash([3*devicePixelRatio, 3*devicePixelRatio]);
    }else{
      ctx.setLineDash([]);
    }

    ctx.lineWidth = (s.bold ? 2.6 : 1) * devicePixelRatio;
    ctx.strokeStyle = s.color;
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (arr[i]/yTop)*ph;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // median lines from bands (draw on top)
  if(opts.bands){
    for(const [key,b] of Object.entries(opts.bands)){
      if(visibleMap[key] === false) continue;
      if(!b.mid) continue;
      let color = 'rgba(255,140,171,1)';
      if(key === 'supply') color = 'rgba(97,230,180,1)';
      if(key === 'total')  color = 'rgba(255,140,171,1)';
      if(opts.bandColors && opts.bandColors[key]) color = opts.bandColors[key];
      ctx.save();
      ctx.lineWidth = 2.2 * devicePixelRatio;
      ctx.strokeStyle = color;
      ctx.setLineDash([]);
      ctx.beginPath();
      for(let i=0;i<tArr.length;i++){
        const x = m.l + (tArr[i]/xMax)*pw;
        const y = m.t + ph - (b.mid[i]/yTop)*ph;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  return {m, pw, ph, xMax, yTop, tArr, seriesDict, opts};
}

function drawDOPlot(canvas, sim, overlay=null){
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const m = {l:56*devicePixelRatio, r:16*devicePixelRatio, t:30*devicePixelRatio, b:34*devicePixelRatio};
  const pw = w - m.l - m.r;
  const ph = h - m.t - m.b;

  const tArr = sim.t;
  const xMax = tArr[tArr.length-1] || 1;

  let yMax = sim.meta.oxy.Cstar * 1.1;
  for(const v of sim.DO_mgL) if(v>yMax) yMax=v;
  if(overlay && overlay.DO && overlay.DO.hi){
    for(let i=0;i<overlay.DO.hi.length;i++) if(overlay.DO.hi[i] > yMax) yMax = overlay.DO.hi[i];
  }
  if(overlay && overlay.Cstar && Number.isFinite(overlay.Cstar.hi)){
    yMax = Math.max(yMax, overlay.Cstar.hi * 1.1);
  }
  yMax = Math.max(0.1, yMax);
  const yTop = niceTop(yMax);
  const yStep = niceStep(yTop);

  // frame
  ctx.strokeStyle = 'rgba(231,236,255,0.18)';
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.strokeRect(m.l, m.t, pw, ph);

  // grid
  ctx.strokeStyle = 'rgba(231,236,255,0.06)';
  ctx.lineWidth = 1*devicePixelRatio;
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
  }
  const xStep = niceXStep(xMax);
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.beginPath();
    ctx.moveTo(px, m.t);
    ctx.lineTo(px, m.t+ph);
    ctx.stroke();
  }

  const CstarRef = (overlay && overlay.Cstar && Number.isFinite(overlay.Cstar.mid)) ? overlay.Cstar.mid : sim.meta.oxy.Cstar;

  // y labels (mg/L)
  ctx.fillStyle = 'rgba(231,236,255,0.75)';
  ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    ctx.fillText(y.toFixed(1), m.l-8, py);
  }
  // right axis (% saturation)
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    const pct = (CstarRef > 1e-9) ? (100 * y / CstarRef) : 0;
    ctx.fillText(`${Math.round(pct)}%`, m.l+pw+8, py);
  }
  // x labels
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.fillStyle = 'rgba(231,236,255,0.70)';
    const xLbl = (xStep < 1) ? x.toFixed(1) : String(Math.round(x));

        ctx.fillText(xLbl, px, m.t+ph+10);
  }

  // title
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillStyle = 'rgba(231,236,255,0.9)';
  ctx.font = `13px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
  ctx.fillText('Dissolved Oxygen (mg/L)', m.l, 10);
  ctx.textAlign = 'right';
  ctx.fillText('% saturation', m.l + pw, 10);

  // C* band + line
  const drawHBand = (yLo, yHi, alpha)=>{
    const py1 = m.t + ph - (yHi/yTop)*ph;
    const py2 = m.t + ph - (yLo/yTop)*ph;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = 'rgba(231,236,255,1)';
    ctx.fillRect(m.l, py1, pw, py2-py1);
    ctx.restore();
  };

  if(overlay && overlay.Cstar && Number.isFinite(overlay.Cstar.lo)){
    drawHBand(overlay.Cstar.lo, overlay.Cstar.hi, 0.07);
    const yMed = overlay.Cstar.mid;
    const py = m.t + ph - (yMed/yTop)*ph;
    ctx.save();
    ctx.setLineDash([6*devicePixelRatio, 6*devicePixelRatio]);
    ctx.strokeStyle = 'rgba(231,236,255,0.75)';
    ctx.lineWidth = 2*devicePixelRatio;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
    ctx.restore();
  }else{
    const y = sim.meta.oxy.Cstar;
    const py = m.t + ph - (y/yTop)*ph;
    ctx.save();
    ctx.setLineDash([6*devicePixelRatio, 6*devicePixelRatio]);
    ctx.strokeStyle = 'rgba(231,236,255,0.65)';
    ctx.lineWidth = 2*devicePixelRatio;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
    ctx.restore();
  }

  // DO band
  if(overlay && overlay.DO && overlay.DO.lo && overlay.DO.hi){
    ctx.save();
    ctx.globalAlpha = overlay.DO.alpha ?? 0.16;
    ctx.fillStyle = 'rgba(118,178,255,1)';
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (overlay.DO.hi[i]/yTop)*ph;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    for(let i=tArr.length-1;i>=0;i--){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (overlay.DO.lo[i]/yTop)*ph;
      ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // base DO (subtle if band exists)
  ctx.save();
  ctx.lineWidth = 2.4*devicePixelRatio;
  ctx.strokeStyle = 'rgba(118,178,255,1)';
  if(overlay && overlay.DO && overlay.DO.mid){
    ctx.globalAlpha = 0.30;
    ctx.setLineDash([3*devicePixelRatio, 3*devicePixelRatio]);
  }else{
    ctx.setLineDash([]);
  }
  ctx.beginPath();
  for(let i=0;i<tArr.length;i++){
    const x = m.l + (tArr[i]/xMax)*pw;
    const y = m.t + ph - (sim.DO_mgL[i]/yTop)*ph;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();

  // median DO line
  if(overlay && overlay.DO && overlay.DO.mid){
    ctx.save();
    ctx.lineWidth = 2.8*devicePixelRatio;
    ctx.strokeStyle = 'rgba(118,178,255,1)';
    ctx.setLineDash([]);
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (overlay.DO.mid[i]/yTop)*ph;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  return {m, pw, ph, xMax, yTop, tArr, sim, overlay};
}

/* =========================================================
   Legend + events
========================================================= */
function buildLegendRate(){
  const root = el('legendRate');
  if(!root) return;
  root.innerHTML = '';
  for(const s of RATE_SERIES){
    const d = document.createElement('div');
    d.className = 'leg' + (visibleRate[s.key] ? '' : ' off');
    d.innerHTML = `<span class="dot" style="background:${s.color}"></span><span>${s.name}</span>`;
    d.addEventListener('click', ()=>{
      visibleRate[s.key] = !visibleRate[s.key];
      buildLegendRate();
      recompute();
    });
    root.appendChild(d);
  }
}

function buildLegendChem(){
  const root = el('legendChem');
  if(!root) return;
  root.innerHTML = '';
  for(const s of CHEM_SERIES){
    const d = document.createElement('div');
    d.className = 'leg' + (visibleChem[s.key] ? '' : ' off');
    d.innerHTML = `<span class="dot" style="background:${s.color}"></span><span>${s.name}</span>`;
    d.addEventListener('click', ()=>{
      visibleChem[s.key] = !visibleChem[s.key];
      buildLegendChem();
      recompute();
    });
    root.appendChild(d);
  }
}

let EVENTS = [];

function maxPelletCountFromInputs(){
  const pelletEachInputMass = pelletMassEach(Number(el('pelLen')?.value || 1.0), Number(el('pelDia')?.value || 0.2), Number(el('pelRho')?.value || 0.55));
  const totalMass = Number(el('pelMassN')?.value || 0);
  return pelletEachInputMass > 0 ? totalMass / pelletEachInputMass : 0;
}

function normalizeEvents(){
  const daysMax = Number(el('daysN')?.value);
  const maxPel = maxPelletCountFromInputs();
  let remaining = maxPel;
  let truncated = false;
  const cleaned = [];

  EVENTS.sort((a,b)=>a.day-b.day);
  for(const raw of EVENTS){
    const day = clamp(Number(raw.day || 0), 0, Number.isFinite(daysMax) ? daysMax : raw.day);
    let pel = Math.max(0, Math.round(Number(raw.pellets || 0)));
    if(pel > remaining){
      pel = Math.max(0, Math.floor(remaining));
      truncated = true;
    }
    if(pel > 0){
      cleaned.push({day, pellets: pel});
      remaining -= pel;
    }
  }
  if(truncated){
    addWarning('Pop events truncated to avoid exceeding available pellets.');
  }
  EVENTS = cleaned;
}

function renderEvents(){
  const table = el('eventsTable');
  if(!table){
    addWarning('Events table missing (#eventsTable). Skipping event rendering.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'eventsTable', context:'renderEvents'});
    return;
  }
  const tb = table.querySelector('tbody');
  if(!tb){
    addWarning('Events table missing tbody. Skipping event rendering.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'eventsTable.tbody', context:'renderEvents'});
    return;
  }
  normalizeEvents();
  tb.innerHTML = '';
  EVENTS.forEach((e, idx)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.1" min="0" value="${Number(e.day).toFixed(1)}" data-idx="${idx}" data-k="day"></td>
      <td><input type="number" step="1" min="0" value="${Math.round(Number(e.pellets))}" data-idx="${idx}" data-k="pellets"></td>
      <td><button class="btn danger" data-del="${idx}">Remove</button></td>
    `;
    tb.appendChild(tr);
  });

  tb.querySelectorAll('input').forEach(inp=>{
    inp.addEventListener('input', (ev)=>{
      const i = Number(ev.target.dataset.idx);
      const k = ev.target.dataset.k;
      EVENTS[i][k] = Number(ev.target.value);
      saveState();
      renderEvents();
      recompute();
    });
  });

  tb.querySelectorAll('button[data-del]').forEach(btn=>{
    btn.addEventListener('click',(ev)=>{
      const i = Number(ev.target.dataset.del);
      EVENTS.splice(i,1);
      saveState();
      renderEvents();
      recompute();
    });
  });
}

/* =========================================================
   State persistence
========================================================= */
const STATE_VERSION = 4;

function saveState(){
  const s = {
    version: STATE_VERSION,
    // main sliders
    pelMass: grabNumField('pelMassN', 0, 'saveState'),
    powMass: grabNumField('powMassN', 0, 'saveState'),
    blanket: grabNumField('blanketN', 0, 'saveState'),
    days: grabNumField('daysN', 30, 'saveState'),

    // environment
    volL: grabNumField('volL', 65, 'saveState'),
    airFlow: grabNumField('airFlow', 4, 'saveState'),
    Tnow: grabNumField('Tnow', 22, 'saveState'),
    pH: grabNumField('pH', 7.2, 'saveState'),
    altM: grabNumField('altM', 0, 'saveState'),
    tds: grabNumField('tds', 0, 'saveState'),

    // geometry + exchange
    ripplePct: grabNumField('ripplePct', 50, 'saveState'),
    lenCm: grabNumField('lenCm', 78, 'saveState'),
    widCm: grabNumField('widCm', 31, 'saveState'),
    tankHCm: grabNumField('tankHCm', 48, 'saveState'),
    waterSurfCm: grabNumField('waterSurfCm', 22, 'saveState'),
    blanketGapCm: grabNumField('blanketGapCm', 0, 'saveState'),
    diffDepthCm: grabNumField('diffDepthCm', 17, 'saveState'),
    heaters: grabNumField('heaters', 0, 'saveState'),

    // presets + numbers
    diffType: grabSelectField('diffType', 'airstone_med', 'saveState'),
    sotePerM: grabNumField('sotePerM', 2.5, 'saveState'),

    surfacePreset: grabSelectField('surfacePreset', 'typical', 'saveState'),
    kCalm: grabNumField('kCalm', 0.3, 'saveState'),
    kRipple: grabNumField('kRipple', 1.0, 'saveState'),

    tightPreset: grabSelectField('tightPreset', 'loose_high', 'saveState'),
    tight: grabNumField('tight', 0.25, 'saveState'),

    otrPreset: grabSelectField('otrPreset', 'typical', 'saveState'),
    otrCal: grabNumField('otrCal', 1.0, 'saveState'),

    initDOPreset: grabSelectField('initDOPreset', '95', 'saveState'),
    doInitPct: grabNumField('doInitPct', 95, 'saveState'),

    // kinetics options
    o2Limit: grabSelectField('o2Limit', 'off', 'saveState'),
    kDoNit: grabNumField('kDoNit', 0.5, 'saveState'),
    kDoHet: grabNumField('kDoHet', 0.8, 'saveState'),
    slowFrac: grabNumField('slowFrac', 0.25, 'saveState'),
    biofilmMm: grabNumField('biofilmMm', 0.6, 'saveState'),
    kDenit: grabNumField('kDenit', 0.15, 'saveState'),
    denitCap: grabNumField('denitCap', 0.6, 'saveState'),
    fishMass: grabNumField('fishMass', 0, 'saveState'),
    fishO2: grabNumField('fishO2', 0, 'saveState'),
    plantO2: grabNumField('plantO2', 0, 'saveState'),
    tempAmp: grabNumField('tempAmp', 0.6, 'saveState'),
    lightHour: grabNumField('lightHour', 9, 'saveState'),
    kNH4Nit: grabNumField('kNH4Nit', 0.4, 'saveState'),
    kNO2Nit: grabNumField('kNO2Nit', 0.25, 'saveState'),
    nitCap: grabNumField('nitCap', 0.8, 'saveState'),
    nitQ10: grabNumField('nitQ10', 2.0, 'saveState'),
    nUnits: grabSelectField('nUnits', 'asN', 'saveState'),
    chemNerd: grabCheckField('chemNerd', false, 'saveState'),
    macroRelease: grabNumField('macroRelease', 8.0, 'saveState'),
    microRelease: grabNumField('microRelease', 1.2, 'saveState'),
    macroUptake: grabNumField('macroUptake', 0.35, 'saveState'),
    microUptake: grabNumField('microUptake', 0.08, 'saveState'),

    // pellet geometry
    pelLen: 1.00, // hardcoded
    pelDia: 0.20, // hardcoded
    pelRho: grabNumField('pelRho', 0.55, 'saveState'),

    // uncertainty mode
    runMode: grabSelectField('runMode', 'uncertainty', 'saveState'),
    uncLevel: grabSelectField('uncLevel', 'typical', 'saveState'),
    mcRuns: grabNumField('mcRuns', 200, 'saveState'),
    bandPreset: grabSelectField('bandPreset', '10-90', 'saveState'),
    seed: grabNumField('seed', 12345, 'saveState'),
    liveRecompute: grabSelectField('liveRecompute', 'on', 'saveState'),
    uAir: grabCheckField('uAir', true, 'saveState'),
    uDiff: grabCheckField('uDiff', true, 'saveState'),
    uSurf: grabCheckField('uSurf', true, 'saveState'),
    uTight: grabCheckField('uTight', true, 'saveState'),
    uBio: grabCheckField('uBio', true, 'saveState'),
    uTemp: grabCheckField('uTemp', true, 'saveState'),
    uInitDO: grabCheckField('uInitDO', true, 'saveState'),

    events: EVENTS
  };
  localStorage.setItem('o2planner_state_v3', JSON.stringify(s));
}

function loadState(){
  try{
    let raw = localStorage.getItem('o2planner_state_v3');
    if(!raw) raw = localStorage.getItem('o2planner_state_v2'); // backwards compatibility
    if(!raw) return;

    const s = JSON.parse(raw);
    const set = (id, v)=>{ if(el(id) && v !== undefined && v !== null) el(id).value = v; };
    const setCheck = (id, v)=>{ if(el(id) && v !== undefined && v !== null) el(id).checked = !!v; };

    // sliders (range+number pairs)
    if(s.pelMass !== undefined && el('pelMass') && el('pelMassN')){ el('pelMass').value = s.pelMass; el('pelMassN').value = s.pelMass; }
    if(s.powMass !== undefined && el('powMass') && el('powMassN')){ el('powMass').value = s.powMass; el('powMassN').value = s.powMass; }
    if(s.blanket !== undefined && el('blanket') && el('blanketN')){ el('blanket').value = s.blanket; el('blanketN').value = s.blanket; }
    if(s.days !== undefined && el('days') && el('daysN')){ el('days').value = s.days; el('daysN').value = s.days; }

    // environment + geometry
    ['volL','airFlow','Tnow','pH','altM','tds','ripplePct','lenCm','widCm','tankHCm','waterSurfCm','blanketGapCm','diffDepthCm',
     'heaters','sotePerM','kCalm','kRipple','tight','otrCal','doInitPct','kDoNit','kNH4Nit','kNO2Nit','nitCap','nitQ10',
     'kDoHet','slowFrac','biofilmMm','kDenit','denitCap','fishMass','fishO2','plantO2','tempAmp','lightHour',
     'pelLen','pelDia','pelRho','macroRelease','microRelease','macroUptake','microUptake'
    ].forEach(k=>set(k, s[k]));

    if(!s.version || s.version < STATE_VERSION){
      if(s.fishMass === undefined) set('fishMass', 0);
      if(s.fishO2 === undefined) set('fishO2', 0);
      if(s.plantO2 === undefined) set('plantO2', 0);
    }

    if(s.diffType !== undefined && el('diffType')) el('diffType').value = s.diffType;
    if(s.surfacePreset !== undefined && el('surfacePreset')) el('surfacePreset').value = s.surfacePreset;
    if(s.tightPreset !== undefined && el('tightPreset')) el('tightPreset').value = s.tightPreset;
    if(s.otrPreset !== undefined && el('otrPreset')) el('otrPreset').value = s.otrPreset;
    if(s.initDOPreset !== undefined && el('initDOPreset')) el('initDOPreset').value = s.initDOPreset;

    if(s.o2Limit !== undefined && el('o2Limit')) el('o2Limit').value = s.o2Limit;
    if(s.nUnits !== undefined && el('nUnits')) el('nUnits').value = s.nUnits;
    setCheck('chemNerd', s.chemNerd);

    // uncertainty mode
    if(el('runMode') && s.runMode !== undefined) el('runMode').value = s.runMode;
    if(el('uncLevel') && s.uncLevel !== undefined) el('uncLevel').value = s.uncLevel;
    if(el('mcRuns') && s.mcRuns !== undefined){ el('mcRuns').value = s.mcRuns; if(el('mcRunsRange')) el('mcRunsRange').value = s.mcRuns; }
    if(el('bandPreset') && s.bandPreset !== undefined) el('bandPreset').value = s.bandPreset;
    if(el('seed') && s.seed !== undefined) el('seed').value = s.seed;
    if(el('liveRecompute') && s.liveRecompute !== undefined) el('liveRecompute').value = s.liveRecompute;

    setCheck('uAir', s.uAir);
    setCheck('uDiff', s.uDiff);
    setCheck('uSurf', s.uSurf);
    setCheck('uTight', s.uTight);
    setCheck('uBio', s.uBio);
    setCheck('uTemp', s.uTemp);
    setCheck('uInitDO', s.uInitDO);

    EVENTS = Array.isArray(s.events) ? s.events : [];
    EVENTS = EVENTS.map(ev=>{
      if(ev && ev.pop !== undefined && ev.pellets === undefined){
        return {day: ev.day, pellets: ev.pop};
      }
      return ev;
    });
    // re-sync preset numeric fields after load
    try{ applyAllPresets(); }catch(_){}
  }catch(_){}
}

/* =========================================================
   Tooltips + click-to-add-event (bind once)
========================================================= */
let lastSim = null;
let lastMC = null;
let rateGeom = null;
let doGeom = null;
let chemGeom = null;
let interactionsBound = false;

function initCanvasInteractions(){
  const tip = ensureTooltip();

  const hide = ()=>{ if(!tip) return; tip.style.display='none'; };
  const show = (ev, html)=>{
    if(!tip) return;
    tip.innerHTML = html;
    tip.style.display = 'block';
    const pad = 14;
    const x = ev.clientX + pad;
    const y = ev.clientY + pad;
    tip.style.left = x + 'px';
    tip.style.top = y + 'px';
  };

  function idxFromEvent(ev, geom){
    const rect = ev.target.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * devicePixelRatio;
    const y = (ev.clientY - rect.top) * devicePixelRatio;
    if(x < geom.m.l || x > geom.m.l + geom.pw || y < geom.m.t || y > geom.m.t + geom.ph) return null;
    const frac = clamp((x - geom.m.l)/geom.pw, 0, 1);
    const day = frac * geom.xMax;
    const idx = clamp(Math.round(day / lastSim.meta.dt), 0, lastSim.t.length-1);
    return idx;
  }

  function bandLine(label, mid, lo, hi, color){
    return `<div style="margin-top:4px; color:${color}; opacity:.95">${label}: <span class="mono">${mid.toFixed(3)}</span> <span class="small" style="opacity:.9">[${lo.toFixed(3)}‚Äì${hi.toFixed(3)}]</span></div>`;
  }
  function bandLine2(label, mid, lo, hi, color){
    return `<div style="margin-top:4px; color:${color}; opacity:.95">${label}: <span class="mono">${mid.toFixed(2)}</span> <span class="small" style="opacity:.9">[${lo.toFixed(2)}‚Äì${hi.toFixed(2)}]</span></div>`;
  }

  const bind = (canvas, getGeom, kind)=>{
    if(canvas.dataset.bound === '1') return;
    canvas.dataset.bound = '1';

    canvas.addEventListener('mousemove', (ev)=>{
      if(!lastSim) return;
      const geom = getGeom();
      if(!geom) return;
      const idx = idxFromEvent(ev, geom);
      if(idx === null){ hide(); return; }

      const day = lastSim.t[idx];

      if(kind === 'rate'){
        const lines = [];
        lines.push(`<div><b>Day ${day.toFixed(2)}</b></div>`);
        for(const s of RATE_SERIES){
          if(!visibleRate[s.key]) continue;
          const v = lastSim.rate[s.key]?.[idx];
          if(v === undefined) continue;
          lines.push(`<div style="margin-top:4px"><span style="color:${s.color}">‚óè</span> ${s.name}: <b class="mono">${v.toFixed(3)}</b></div>`);
        }

        const DO = lastSim.DO_mgL[idx], DOpc = lastSim.DO_pct[idx];
        lines.push(`<div style="margin-top:6px; color:rgba(231,236,255,0.8)">DO (base): <span class="mono">${DO.toFixed(2)} mg/L</span> (${DOpc.toFixed(0)}%)</div>`);

        if(lastMC){
          const tmid = lastMC.q.rateTotal.mid[idx], tlo = lastMC.q.rateTotal.lo[idx], thi = lastMC.q.rateTotal.hi[idx];
          const smid = lastMC.q.rateSupply.mid[idx], slo = lastMC.q.rateSupply.lo[idx], shi = lastMC.q.rateSupply.hi[idx];
          lines.push(`<div class="hr" style="margin:8px 0"></div>`);
          lines.push(`<div class="small" style="opacity:.85">Uncertainty band:</div>`);
          lines.push(bandLine('Total demand', tmid, tlo, thi, 'rgba(255,140,171,1)'));
          lines.push(bandLine('O‚ÇÇ supply', smid, slo, shi, 'rgba(97,230,180,1)'));
          const dmid = lastMC.q.DO.mid[idx], dlo = lastMC.q.DO.lo[idx], dhi = lastMC.q.DO.hi[idx];
          lines.push(bandLine2('DO', dmid, dlo, dhi, 'rgba(118,178,255,1)'));
        }

        show(ev, lines.join(''));
      }

      if(kind === 'chem'){
        const lines = [];
        lines.push(`<div><b>Day ${day.toFixed(2)}</b></div>`);
        for(const s of CHEM_SERIES){
          if(!visibleChem[s.key]) continue;
          const v = lastSim.chemCum?.[s.key]?.[idx];
          if(v === undefined) continue;
          lines.push(`<div style="margin-top:4px"><span style="color:${s.color}">‚óè</span> ${s.name}: <b class="mono">${v.toFixed(3)}</b></div>`);
        }

        if(lastMC){
          const band = lastMC.q.chemBands;
          if(band){
            lines.push(`<div class="hr" style="margin:8px 0"></div>`);
            lines.push(`<div class="small" style="opacity:.85">Uncertainty band:</div>`);
            for(const s of CHEM_SERIES){
              if(!visibleChem[s.key]) continue;
              const b = band[s.key];
              if(!b) continue;
              lines.push(bandLine2(s.name, b.mid[idx], b.lo[idx], b.hi[idx], s.color));
            }
          }
        }

        show(ev, lines.join(''));
      }

      if(kind === 'do'){
        const lines = [];
        lines.push(`<div><b>Day ${day.toFixed(2)}</b></div>`);
        const DO = lastSim.DO_mgL[idx], DOpc = lastSim.DO_pct[idx];
        lines.push(`<div style="margin-top:4px"><span style="color:rgba(118,178,255,1)">‚óè</span> DO (base): <b class="mono">${DO.toFixed(2)} mg/L</b> (${DOpc.toFixed(0)}%)</div>`);
        const c = lastSim.meta.oxy.Cstar;
        lines.push(`<div style="margin-top:4px; opacity:.8">C* (base): <span class="mono">${c.toFixed(2)} mg/L</span></div>`);

        if(lastMC){
          const dmid = lastMC.q.DO.mid[idx], dlo = lastMC.q.DO.lo[idx], dhi = lastMC.q.DO.hi[idx];
          lines.push(`<div class="hr" style="margin:8px 0"></div>`);
          lines.push(`<div class="small" style="opacity:.85">Uncertainty band:</div>`);
          lines.push(bandLine2('DO', dmid, dlo, dhi, 'rgba(118,178,255,1)'));
          lines.push(`<div style="margin-top:4px; opacity:.8">C*: <span class="mono">${lastMC.scalars.Cstar.mid.toFixed(2)} mg/L</span> <span class="small">[${lastMC.scalars.Cstar.lo.toFixed(2)}‚Äì${lastMC.scalars.Cstar.hi.toFixed(2)}]</span></div>`);
        }

        show(ev, lines.join(''));
      }
    });

    canvas.addEventListener('mouseleave', hide);
  };

  const rateCanvas = el('rateCanvas');
  bind(rateCanvas, ()=>rateGeom, 'rate');
  bind(el('chemCanvas'), ()=>chemGeom, 'chem');
  bind(el('doCanvas'), ()=>doGeom, 'do');

  if(rateCanvas && rateGeom && rateCanvas.dataset.clickBound !== '1'){
    rateCanvas.dataset.clickBound = '1';
    rateCanvas.addEventListener('click', (ev)=>{
      if(!lastSim || !rateGeom) return;
      const idx = idxFromEvent(ev, rateGeom);
      if(idx === null) return;
      el('evDay').value = lastSim.t[idx].toFixed(2);
    });
  }
}

/* =========================================================
   Flags + summary
========================================================= */
function setFlags(sim, params, mc){
  let flags = el('flags');
  if(!flags){
    addWarning('Flags container missing (#flags). Creating fallback container.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'flags', context:'setFlags'});
    const cards = document.querySelectorAll('.wrap .card');
    const host = cards.length ? cards[cards.length-1] : document.body;
    flags = document.createElement('div');
    flags.id = 'flags';
    flags.className = 'flags';
    flags.style.marginTop = '10px';
    host.appendChild(flags);
  }
  flags.innerHTML = '';
  let flagCount = 0;

  const kindAliases = {ok:'ok', warn:'warn', danger:'danger', note:'note', good:'ok'};
  const good = kindAliases.good;
  const normalizeKind = (kind)=>{
    if(typeof kind !== 'string') return 'note';
    const norm = kindAliases[kind] || 'note';
    if(norm !== kind){
      addWarning(`Unknown flag kind "${kind}" normalized to "${norm}".`);
    }
    return norm;
  };

  const add = (kind, title, msg)=>{
    const div = document.createElement('div');
    const safeKind = normalizeKind(kind);
    div.className = 'flag-card';
    div.innerHTML = `
      <div class="flag-tag ${safeKind}">${title}<span>${safeKind.toUpperCase()}</span></div>
      <div class="flag-body"><div class="small">${msg}</div></div>
    `;
    flags.appendChild(div);
    flagCount++;
  };

  let tags = el('chemTags');
  if(!tags){
    addWarning('Chemistry tags container missing (#chemTags). Creating fallback container.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'chemTags', context:'setFlags'});
    const cards = document.querySelectorAll('.wrap .card');
    const host = cards.length ? cards[cards.length-1] : document.body;
    tags = document.createElement('div');
    tags.id = 'chemTags';
    tags.className = 'tag-stack';
    tags.style.marginTop = '10px';
    host.appendChild(tags);
  }
  tags.innerHTML = '';

  const estPellets = pelletMassEach(params.pelLen, params.pelDia, params.pelRho);
  const pelCount = estPellets > 0 ? (params.pelletMass_g / estPellets) : 0;
  const eventTotal = (params.events || []).reduce((acc, e)=>acc + (Number(e.pellets) || 0), 0);
  if(eventTotal > pelCount + 1){
    add('warn', 'Pop events exceed pellets', `Total pops (${eventTotal.toFixed(0)}) exceed estimated pellet count (${pelCount.toFixed(0)}). The model caps pops automatically, but the schedule is probably too aggressive.`);
  }
  if(sim.meta?.chemCumInfo?.invalidCount){
    add('warn', 'Chemistry cumulative data gap', `Detected ${sim.meta.chemCumInfo.invalidCount} non-finite chemistry samples. Cumulative plot replaces them with 0 so the chart remains readable.`);
  }

  const rate = sim.rate.total;
  const supply = sim.rate.supply;

  // Peak demand and peak deficit vs supply (base run)
  let peak = {v:0, day:0, idx:0};
  let peakDef = {v:0, day:0, idx:0};
  for(let i=0;i<rate.length;i++){
    if(rate[i] > peak.v) peak = {v:rate[i], day:sim.t[i], idx:i};
    const def = rate[i] - supply[i];
    if(def > peakDef.v) peakDef = {v:def, day:sim.t[i], idx:i};
  }

  // Base deficit area
  let baseArea = 0;
  for(let i=0;i<rate.length;i++) baseArea += Math.max(0, rate[i]-supply[i]) * sim.meta.dt;

  // Base DO min
  let doMinStats = {v:Infinity, day:0, idx:0};
  let tUnder2 = 0, tUnder1 = 0;
  for(let i=0;i<sim.DO_mgL.length;i++){
    const v = sim.DO_mgL[i];
    if(v < doMinStats.v) doMinStats = {v, day:sim.t[i], idx:i};
    if(v < 2.0) tUnder2 += sim.meta.dt;
    if(v < 1.0) tUnder1 += sim.meta.dt;
  }

  let nh4PeakValue = 0, no2PeakValue = 0, no3PeakValue = 0, nh3PeakValue = 0;
  for(let i=0;i<sim.NH4_mgL.length;i++) if(sim.NH4_mgL[i] > nh4PeakValue) nh4PeakValue = sim.NH4_mgL[i];
  for(let i=0;i<sim.NO2_mgL.length;i++) if(sim.NO2_mgL[i] > no2PeakValue) no2PeakValue = sim.NO2_mgL[i];
  for(let i=0;i<sim.NO3_mgL.length;i++) if(sim.NO3_mgL[i] > no3PeakValue) no3PeakValue = sim.NO3_mgL[i];
  for(let i=0;i<sim.NH3_mgL.length;i++) if(sim.NH3_mgL[i] > nh3PeakValue) nh3PeakValue = sim.NH3_mgL[i];
  const denitN_mgL = (sim.audit.no3_to_n2 * 1000) / params.volL;

  // --------------------------
  // Uncertainty mode flags
  // --------------------------
  if(mc){
    const p2 = mc.probs.anyUnder2;
    const p1 = mc.probs.anyUnder1;

    // Severity by probability of dipping below thresholds (based on min DO across the run)
    if(p1 > 0.25){
      add('danger', 'Very high hypoxia risk', `In ${fmtPct(p1)} of runs, DO dips below <b>1 mg/L</b> at least once. That's ‚Äúfish emergency‚Äù territory.`);
    }else if(p1 > 0.10){
      add('warn', 'High hypoxia risk', `In ${fmtPct(p1)} of runs, DO dips below <b>1 mg/L</b>. Consider reducing input, increasing aeration, or increasing open surface exchange.`);
    }
  }
  const classify = (mode, value, good, warn)=>{
    if(!Number.isFinite(value)){
      addWarning('Chem tag value missing; check simulation outputs.');
      return {tone:'warn', label:'unknown'};
    }
    if(mode === 'min'){
      if(value >= good) return {tone:'ok', label:'good'};
      if(value >= warn) return {tone:'warn', label:'watch'};
      return {tone:'danger', label:'risk'};
    }
    if(value <= good) return {tone:'ok', label:'good'};
    if(value <= warn) return {tone:'warn', label:'watch'};
    return {tone:'danger', label:'risk'};
  };
  const addTag = ({label, tone, status, summary, details})=>{
    const det = document.createElement('details');
    det.className = `tag-line tone-${tone}`;
    det.innerHTML = `
      <summary>
        <span class="tag-title">${label}</span>
        <span class="tag-meta">${summary}</span>
        <span class="tag-chip ${tone}">${status}</span>
      </summary>
      <div class="tag-details">${details.map(line=>`<div>${line}</div>`).join('')}</div>
    `;
    tags.appendChild(det);
  };

  const isMC = !!mc;
  const nFactorNH4 = params.nUnits === 'asIon' ? CHEM.NH4_ion_per_N : 1;
  const nFactorNO2 = params.nUnits === 'asIon' ? CHEM.NO2_ion_per_N : 1;
  const nFactorNO3 = params.nUnits === 'asIon' ? CHEM.NO3_ion_per_N : 1;

  const doMin = isMC ? mc.scalars.minDO.mid : Math.min(...sim.DO_mgL);
  const nh3Peak = isMC ? mc.scalars.nh3pk.mid : Math.max(...sim.NH3_mgL);
  const nh4Peak = isMC ? (mc.scalars.nh4pk.mid * nFactorNH4) : Math.max(...sim.NH4_mgL) * nFactorNH4;
  const no2Peak = isMC ? (mc.scalars.no2pk.mid * nFactorNO2) : Math.max(...sim.NO2_mgL) * nFactorNO2;
  const no3Peak = isMC ? (mc.scalars.no3pk.mid * nFactorNO3) : Math.max(...sim.NO3_mgL) * nFactorNO3;
  const co2Peak = isMC ? mc.scalars.co2pk.mid : Math.max(...sim.CO2_mgL);
  const macroPeak = isMC ? mc.scalars.macroPk.mid : Math.max(...sim.macro_mgL);
  const microPeak = isMC ? mc.scalars.microPk.mid : Math.max(...sim.micro_mgL);

  const doClass = classify('min', doMin, 5, 2);
  addTag({
    label:'Dissolved oxygen (DO)',
    tone: doClass.tone,
    status: doClass.label,
    summary:`min ${fmtVal(doMin, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median minimum' : 'minimum'}: ${fmtVal(doMin, 'mg/L')}.`,
      fmtBandLine('min', 5, 2, 'mg/L'),
      `Context: pH ${params.pH}, temperature ${params.Tnow}¬∞C, volume ${params.volL} L.`
    ]
  });

  const nh3Class = classify('max', nh3Peak, 0.02, 0.05);
  addTag({
    label:'NH‚ÇÉ (unionized)',
    tone: nh3Class.tone,
    status: nh3Class.label,
    summary:`peak ${fmtVal(nh3Peak, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(nh3Peak, 'mg/L')}.`,
      fmtBandLine('max', 0.02, 0.05, 'mg/L'),
      `Unionized fraction depends on pH ${params.pH} and temperature ${params.Tnow}¬∞C.`
    ]
  });

  // --------------------------
  // Single-run flags
  // --------------------------
  if(!mc){
    if(doMinStats.v < 1.0){
      add('danger', 'DO crash', `Min DO is <b>${doMinStats.v.toFixed(2)} mg/L</b> at day ${doMinStats.day.toFixed(2)}. That‚Äôs a crash risk.`);
    }else if(doMinStats.v < 2.0){
      add('warn', 'Low DO window', `Min DO is <b>${doMinStats.v.toFixed(2)} mg/L</b> at day ${doMinStats.day.toFixed(2)}. Many animals get stressed below ~2 mg/L.`);
    }else if(doMinStats.v < 4.0){
      add('note', 'Moderate DO dip', `Min DO is ${doMinStats.v.toFixed(2)} mg/L at day ${doMinStats.day.toFixed(2)}. Probably fine for hardier stock, but still worth watching.`);
    }else{
      add('note', 'DO looks comfortable', `Min DO is ${doMinStats.v.toFixed(2)} mg/L at day ${doMinStats.day.toFixed(2)}.`);
    }

    if(peakDef.v > 0.1){
      add('warn', 'Demand exceeds supply', `Peak deficit is <b>${peakDef.v.toFixed(2)} g/day</b> at day ${peakDef.day.toFixed(2)}. Expect DO to trend downward around that window.`);
    }else{
      add('note', 'Supply generally keeps up', `Peak deficit is ${peakDef.v.toFixed(2)} g/day.`);
    }
  }

  const co2Class = classify('max', co2Peak, 15, 30);
  addTag({
    label:'CO‚ÇÇ free',
    tone: co2Class.tone,
    status: co2Class.label,
    summary:`peak ${fmtVal(co2Peak, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(co2Peak, 'mg/L')}.`,
      fmtBandLine('max', 15, 30, 'mg/L'),
      `CO‚ÇÇ spikes often track heavy feeding or respiration loads.`
    ]
  });

  const storeClass = classify('min', storeMin, 1.0, 0.4);
  addTag({
    label:'Nutrient stores',
    tone: storeClass.tone,
    status: storeClass.label,
    summary:`min ${fmtVal(storeMin, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(macroPeak, 'mg/L')}.`,
      fmtBandLine('max', 1.5, 3.0, 'mg/L'),
      `Proxy nutrients help compare relative load across scenarios.`
    ]
  });

  if(nh3PeakValue > 0.10){
    add('danger', 'NH‚ÇÉ toxicity risk', `Unionized NH‚ÇÉ peaks near ${nh3PeakValue.toFixed(3)} mg/L. Consider lower pH, reduced load, or more nitrification capacity.`);
  }else if(nh3PeakValue > 0.05){
    add('warn', 'NH‚ÇÉ watch zone', `Unionized NH‚ÇÉ peaks near ${nh3PeakValue.toFixed(3)} mg/L. Keep an eye on sensitive stock.`);
  }else{
    add('note', 'NH‚ÇÉ stays low', `Unionized NH‚ÇÉ peaks near ${nh3PeakValue.toFixed(3)} mg/L.`);
  }

  add('note', 'Nitrogen peaks (single run)', `NH‚ÇÑ: ${nh4PeakValue.toFixed(3)} mg/L ‚Ä¢ NO‚ÇÇ: ${no2PeakValue.toFixed(3)} mg/L ‚Ä¢ NO‚ÇÉ: ${no3PeakValue.toFixed(3)} mg/L.`);
  if(denitN_mgL > 0.2){
    add('note', 'Denitrification activity', `Estimated NO‚ÇÉ ‚Üí N‚ÇÇ conversion: ${denitN_mgL.toFixed(2)} mg/L as N. Low-DO windows are driving denitrification.`);
  }
  DEBUG_STATE.lastFlagsCount = flagCount;
}

/* =========================================================
   Main recompute + render
========================================================= */
function getParams(){
  // Keep ‚Äúpreset selectors‚Äù synced to their numeric fields before reading
  try{ applyAllPresets(); }catch(_){}

  // Hardcoded pellet geometry (project standard)
  try{
    if(el('pelLen')) el('pelLen').value = '1.00';
    if(el('pelDia')) el('pelDia').value = '0.20';
  }catch(_){}

  const p = {
    pelletMass_g: grabNumField('pelMassN', 0, 'params'),
    powderMass_g: grabNumField('powMassN', 0, 'params'),
    blanketPct: grabNumField('blanketN', 0, 'params'),
    days: grabNumField('daysN', 30, 'params'),

    volL: grabNumField('volL', 65, 'params'),
    airFlow: grabNumField('airFlow', 4, 'params'),
    Tnow: grabNumField('Tnow', 22, 'params'),
    pH: grabNumField('pH', 7.2, 'params'),
    altM: grabNumField('altM', 0, 'params'),
    tds: grabNumField('tds', 0, 'params'),

    ripplePct: grabNumField('ripplePct', 50, 'params'),

    lenCm: grabNumField('lenCm', 78, 'params'),
    widCm: grabNumField('widCm', 31, 'params'),
    tankHCm: grabNumField('tankHCm', 48, 'params'),
    waterSurfCm: grabNumField('waterSurfCm', 22, 'params'),
    blanketGapCm: grabNumField('blanketGapCm', 0, 'params'),
    diffDepthCm: grabNumField('diffDepthCm', 17, 'params'),
    heaters: grabNumField('heaters', 0, 'params'),

    diffType: grabSelectField('diffType', 'airstone_med', 'params'),
    sotePerM: grabNumField('sotePerM', 2.5, 'params'),
    surfacePreset: grabSelectField('surfacePreset', 'typical', 'params'),
    kCalm: grabNumField('kCalm', 0.3, 'params'),
    kRipple: grabNumField('kRipple', 1.0, 'params'),

    tightPreset: grabSelectField('tightPreset', 'loose_high', 'params'),
    tight: grabNumField('tight', 0.25, 'params'),

    otrPreset: grabSelectField('otrPreset', 'typical', 'params'),
    otrCal: grabNumField('otrCal', 1.0, 'params'),

    initDOPreset: grabSelectField('initDOPreset', '95', 'params'),
    doInitPct: grabNumField('doInitPct', 95, 'params'),

    o2Limit: grabSelectField('o2Limit', 'off', 'params'),
    kDoNit: grabNumField('kDoNit', 0.5, 'params'),
    kDoHet: grabNumField('kDoHet', 0.8, 'params'),
    slowFrac: grabNumField('slowFrac', 0.25, 'params'),
    biofilmMm: grabNumField('biofilmMm', 0.6, 'params'),
    kDenit: grabNumField('kDenit', 0.15, 'params'),
    denitCap: grabNumField('denitCap', 0.6, 'params'),
    fishMass: grabNumField('fishMass', 0, 'params'),
    fishO2: grabNumField('fishO2', 0, 'params'),
    plantO2: grabNumField('plantO2', 0, 'params'),
    tempAmp: grabNumField('tempAmp', 0.6, 'params'),
    lightHour: grabNumField('lightHour', 9, 'params'),
    kNH4Nit: grabNumField('kNH4Nit', 0.4, 'params'),
    kNO2Nit: grabNumField('kNO2Nit', 0.25, 'params'),
    nitCap: grabNumField('nitCap', 0.8, 'params'),
    nitQ10: grabNumField('nitQ10', 2.0, 'params'),
    nUnits: grabSelectField('nUnits', 'asN', 'params'),
    chemNerd: grabCheckField('chemNerd', false, 'params'),
    macroRelease: grabNumField('macroRelease', 8.0, 'params'),
    microRelease: grabNumField('microRelease', 1.2, 'params'),
    macroUptake: grabNumField('macroUptake', 0.35, 'params'),
    microUptake: grabNumField('microUptake', 0.08, 'params'),

    pelLen: grabNumField('pelLen', 1.0, 'params'),
    pelDia: grabNumField('pelDia', 0.2, 'params'),
    pelRho: grabNumField('pelRho', 0.55, 'params'),

    // Uncertainty mode controls
    runMode: grabSelectField('runMode', 'uncertainty', 'params'),
    uncLevel: grabSelectField('uncLevel', 'typical', 'params'),
    mcRuns: grabNumField('mcRuns', 200, 'params'),
    bandPreset: grabSelectField('bandPreset', '10-90', 'params'),
    seed: grabNumField('seed', 12345, 'params'),
    liveRecompute: grabSelectField('liveRecompute', 'on', 'params'),
    u: {
      air: grabCheckField('uAir', true, 'params'),
      diff: grabCheckField('uDiff', true, 'params'),
      surf: grabCheckField('uSurf', true, 'params'),
      tight: grabCheckField('uTight', true, 'params'),
      bio: grabCheckField('uBio', true, 'params'),
      temp: grabCheckField('uTemp', true, 'params'),
      initDO: grabCheckField('uInitDO', true, 'params'),
    },

    events: EVENTS
  };

  // light sanitization
  p.mcRuns = clamp(Math.round(p.mcRuns || 0), 10, 5000);
  p.pH = clamp(Number.isFinite(p.pH) ? p.pH : 7.0, 5.0, 9.5);
  p.nitCap = clamp(Number.isFinite(p.nitCap) ? p.nitCap : 1.0, 0, 1);
  p.denitCap = clamp(Number.isFinite(p.denitCap) ? p.denitCap : 1.0, 0, 1);
  p.lightHour = clamp(Number.isFinite(p.lightHour) ? p.lightHour : 8, 0, 23);
  return p;
}

function fmtBand(stats, unit, decimals=2){
  const lo = stats.lo, mid = stats.mid, hi = stats.hi;
  if(!Number.isFinite(lo) || !Number.isFinite(mid) || !Number.isFinite(hi)) return '‚Äî';
  return `${mid.toFixed(decimals)} ${unit}  [${lo.toFixed(decimals)}‚Äì${hi.toFixed(decimals)}]`;
}

function fmtVal(value, unit, decimals = null){
  if(!Number.isFinite(value)) return '‚Äî';
  const places = decimals ?? (Math.abs(value) < 1 ? 3 : 2);
  const text = value.toFixed(places);
  return unit ? `${text} ${unit}` : text;
}

function fmtBandLine(mode, good, warn, unit){
  if(mode === 'min'){
    return `Safe ‚â• ${fmtVal(good, unit)} ‚Ä¢ Watch ${fmtVal(warn, unit)}‚Äì${fmtVal(good, unit)} ‚Ä¢ Risk < ${fmtVal(warn, unit)}`;
  }
  return `Safe ‚â§ ${fmtVal(good, unit)} ‚Ä¢ Watch ${fmtVal(good, unit)}‚Äì${fmtVal(warn, unit)} ‚Ä¢ Risk > ${fmtVal(warn, unit)}`;
}

function convertStats(stats, factor){
  if(!stats) return stats;
  return {lo: stats.lo*factor, mid: stats.mid*factor, hi: stats.hi*factor};
}

function fmtPct(p){
  if(!Number.isFinite(p)) return '‚Äî';
  return `${(100*p).toFixed(1)}%`;
}

function recompute(){
  clearError();
  if(debounceTimerId !== null){
    clearTimeout(debounceTimerId);
    debounceTimerId = null;
  }
  DEBUG_STATE.debounceQueued = 0;
  setRecomputeBubbleState(true);
  setStage('recompute', 'start');
  DEBUG_STATE.warnings = [];
  DEBUG_STATE.lastOxyMissingCount = 0;
  DEBUG_STATE.lastMCSeriesFallbacks = null;
  DEBUG_STATE.lastBiofilmMetaMissing = null;
  DEBUG_STATE.missingInputs = [];
  DEBUG_STATE.lastMissingInputsCount = 0;
  const recomputeStart = performance.now();
  setRecomputeBubbleState('running', {phase: 'start'});

  try{
    setStage('UI', 'apply presets');
    applyAllPresets();

    setStage('UI', 'read params');
    const params = getParams();
    DEBUG_STATE.lastParams = params;
    DEBUG_STATE.lastMode = params.runMode;
    DEBUG_STATE.lastUpdateISO = new Date().toISOString();

    updateChemSeriesLabels(params.nUnits);
    buildLegendChem();

    assertFinite('days', params.days);
    assertFinite('volL', params.volL);

    saveState();

    // Pellet derived quantities
    setStage('Pellets', 'derive pellet count');
    const pelletEachMassLive = pelletMassEach(params.pelLen, params.pelDia, params.pelRho);
    const nPel = (pelletEachMassLive > 0) ? (params.pelletMass_g / pelletEachMassLive) : 0;
    setText('pelCount', `${nPel.toFixed(1)} pellets`);
    setText('pelEach', `${pelletEachMassLive.toFixed(4)} g each`);

    // Base sim (used for breakdown lines + UI even in uncertainty mode)
    setStage('Simulation', 'run base sim');
    const baseSim = runSimulation(params);
    lastSim = baseSim;
    lastMC = null;

    const oxy = baseSim.meta.oxy;
    DEBUG_STATE.lastOxy = oxy;
    DEBUG_STATE.lastSimMeta = baseSim.meta;
    DEBUG_STATE.lastChemCumInfo = baseSim.meta.chemCumInfo || null;
    if(baseSim.meta.chemCumInfo?.invalidCount){
      addWarning(`Chemistry cumulative series had ${baseSim.meta.chemCumInfo.invalidCount} non-finite samples; treated as 0 in the cumulative plot.`);
    }

    // If uncertainty mode: run MC overlay
    if(params.runMode === 'uncertainty'){
      setStage('Uncertainty', 'Monte Carlo');
      const mc = runMonteCarlo(params);
      lastMC = mc;
      DEBUG_STATE.lastScalars = mc.scalars;

      // Oxygenation meta (bands)
      setText('cStarOut', fmtBand(mc.scalars.Cstar, 'mg/L', 2));
      setText('otrOut', fmtBand(mc.scalars.otrMax, 'g/day', 2));
      setText('klaOut', fmtBand(mc.scalars.kLa, '1/day', 3));

      // DO min + risk
      setText('doMinOut', `${fmtBand(mc.scalars.minDO, 'mg/L', 2)}  @ day ${fmtBand(mc.scalars.minDO_day, '', 2).replace('  [','[')}`);
      setText('pUnder2Out', fmtPct(mc.probs.anyUnder2));
      setText('pUnder1Out', fmtPct(mc.probs.anyUnder1));

      const nh4Stats = params.nUnits === 'asIon' ? convertStats(mc.scalars.nh4pk, CHEM.NH4_ion_per_N) : mc.scalars.nh4pk;
      const no2Stats = params.nUnits === 'asIon' ? convertStats(mc.scalars.no2pk, CHEM.NO2_ion_per_N) : mc.scalars.no2pk;
      const no3Stats = params.nUnits === 'asIon' ? convertStats(mc.scalars.no3pk, CHEM.NO3_ion_per_N) : mc.scalars.no3pk;

      setText('nh4Out', fmtBand(nh4Stats, 'mg/L', 3));
      setText('no2Out', fmtBand(no2Stats, 'mg/L', 3));
      setText('no3Out', fmtBand(no3Stats, 'mg/L', 3));
      setText('nh3Out', fmtBand(mc.scalars.nh3pk, 'mg/L', 3));
      setText('co2Out', fmtBand(mc.scalars.co2pk, 'mg/L', 2));
      const macroStats = mc.scalars.macroPk;
      const microStats = mc.scalars.microPk;
      setText('nutrOut', `${fmtBand(macroStats, 'mg/L', 2)} ‚Ä¢ ${fmtBand(microStats, 'mg/L', 2)}`);

      // Plots with bands
      setStage('Plots', 'rate');
      rateGeom = drawPlot(el('rateCanvas'), baseSim.t, baseSim.rate, {
        title:"Oxygen RATE (g O‚ÇÇ/day)",
        bands:{
          total:{lo:mc.q.rateTotal.lo, hi:mc.q.rateTotal.hi, mid:mc.q.rateTotal.mid, alpha:0.18},
          supply:{lo:mc.q.rateSupply.lo, hi:mc.q.rateSupply.hi, mid:mc.q.rateSupply.mid, alpha:0.14}
        }
      });

      setStage('Plots', 'dissolved oxygen');
      doGeom = drawDOPlot(el('doCanvas'), baseSim, {
        DO:{lo:mc.q.DO.lo, hi:mc.q.DO.hi, mid:mc.q.DO.mid, alpha:0.18},
        Cstar: mc.scalars.Cstar
      });

      setStage('Plots', 'chemistry');
      const chemBands = mc.q.chemBands;
      chemGeom = drawPlot(el('chemCanvas'), baseSim.t, baseSim.chemCum, {
        title:"Chemistry / Compounds (mg/L)",
        series: CHEM_SERIES,
        visible: visibleChem,
        bands: Object.fromEntries(CHEM_SERIES.map(s=>[
          s.key,
          {lo:chemBands[s.key].lo, hi:chemBands[s.key].hi, mid:chemBands[s.key].mid, alpha:0.12}
        ])),
        bandColors: Object.fromEntries(CHEM_SERIES.map(s=>[s.key, s.color]))
      });

      setStage('Flags', 'evaluate');
      setFlags(baseSim, params, mc);

      // Debug (human-readable summary + machine snapshot)
      const dbg = [];
      dbg.push(`Mode: Uncertainty (Monte Carlo)`);
      dbg.push(`Runs: ${mc.scalars.runs}, band: ${params.bandPreset}, level: ${params.uncLevel}`);
      dbg.push(`What varies: air=${params.u.air}, diffuser=${params.u.diff}, surface=${params.u.surf}, cover=${params.u.tight}, bio=${params.u.bio}, temp=${params.u.temp}, initDO=${params.u.initDO}`);
      dbg.push(`Pressure @ altitude: ${pressureFromAltitude_kPa(params.altM).toFixed(2)} kPa`);
      dbg.push(`Base O2 in pumped air (rated flow): ${oxy.O2_in_air_g_day.toFixed(2)} g/day`);
      dbg.push(`Base bubble eff fraction: ${(100*oxy.eff_bubble).toFixed(2)}%  (depth ${params.diffDepthCm.toFixed(1)} cm, SOTE/m ${params.sotePerM.toFixed(2)}%)`);
      dbg.push(`Surface areas: total ${oxy.areas.A_total.toFixed(4)} m¬≤; open ${oxy.areas.A_open.toFixed(4)}; covered ${oxy.areas.A_cov.toFixed(4)}`);
      dbg.push(`Cover leak factor (base): ${oxy.leak.toFixed(3)} (tight=${params.tight.toFixed(2)}, headspace ${oxy.head.V_head_L.toFixed(1)} L)`);
      dbg.push(`Base OTR surface max: ${oxy.OTR_surface_max.toFixed(3)} g/day  (kCalm ${params.kCalm}, kRipple ${params.kRipple}, ripple ${params.ripplePct}%)`);
      dbg.push(`Base OTR bubble max: ${oxy.OTR_bubble_max.toFixed(3)} g/day`);
      dbg.push(`Base OTR max: ${oxy.OTR_max.toFixed(3)} g/day`);
      dbg.push(`Base kLa inferred: ${oxy.kLa.toFixed(4)} 1/day`);
      dbg.push(`Sim dt: ${baseSim.meta.dt.toFixed(4)} days (~${(baseSim.meta.dt*24).toFixed(2)} h)`);
      dbg.push(`Feed mass: start ${baseSim.meta.feedStart.toFixed(3)} g ‚Üí end ${baseSim.meta.feedEnd.toFixed(3)} g`);
      dbg.push(`Rate peaks: demand ${baseSim.meta.maxDemand.toFixed(3)} g/day ‚Ä¢ supply ${baseSim.meta.maxSupply.toFixed(3)} g/day`);
      dbg.push('Metabolism mode: legacy (denit/diurnal/plant/fish/slow COD disabled)');
      dbg.push(`Biofilm proxy: ${params.biofilmMm} mm ‚Ä¢ slowFrac ${params.slowFrac}`);
      dbg.push(`Denit: k=${params.kDenit} 1/day ‚Ä¢ cap=${params.denitCap}`);
      dbg.push(`Fish O2: ${params.fishMass} g @ ${params.fishO2} mg/g/day ‚Ä¢ Plant O2 peak ${params.plantO2} mg/L/day`);
      dbg.push(`Diurnal: tempAmp ${params.tempAmp}¬∞C ‚Ä¢ lights @ ${params.lightHour}:00`);
      dbg.push(`N units: ${params.nUnits} ‚Ä¢ pH=${params.pH} ‚Ä¢ NH3 frac=${nh3Fraction(params.pH ?? 7.0, params.Tnow).toFixed(3)}`);
      dbg.push('');
      dbg.push('--- Snapshot ---');
      dbg.push(...buildDebugSnapshot([]));
      setDebugText(dbg);

    }else{
      setStage('Mode', 'deterministic single run');

      // Deterministic (single)
      setText('cStarOut', `${oxy.Cstar.toFixed(2)} mg/L`);
      setText('otrOut', `${oxy.OTR_max.toFixed(2)} g/day`);
      setText('klaOut', `${oxy.kLa.toFixed(3)} 1/day`);

      // Min DO display
      let doMinValue = Infinity;
      let doMinDay = 0;
      for(let i=0;i<baseSim.DO_mgL.length;i++){
        if(baseSim.DO_mgL[i] < doMinValue){ doMinValue = baseSim.DO_mgL[i]; doMinDay = baseSim.t[i]; }
      }
      el('doMinOut').textContent = `${doMinValue.toFixed(2)} mg/L @ day ${doMinDay.toFixed(2)}`;
      el('pUnder2Out').textContent = '‚Äî';
      el('pUnder1Out').textContent = '‚Äî';

      const nFactorNH4 = params.nUnits === 'asIon' ? CHEM.NH4_ion_per_N : 1;
      const nFactorNO2 = params.nUnits === 'asIon' ? CHEM.NO2_ion_per_N : 1;
      const nFactorNO3 = params.nUnits === 'asIon' ? CHEM.NO3_ion_per_N : 1;
      const nh4Peak = Math.max(...baseSim.NH4_mgL) * nFactorNH4;
      const no2Peak = Math.max(...baseSim.NO2_mgL) * nFactorNO2;
      const no3Peak = Math.max(...baseSim.NO3_mgL) * nFactorNO3;
      const nh3Peak = Math.max(...baseSim.NH3_mgL);
      const co2Peak = Math.max(...baseSim.CO2_mgL);
      const macroPeak = Math.max(...baseSim.macro_mgL);
      const microPeak = Math.max(...baseSim.micro_mgL);
      setText('nh4Out', `${nh4Peak.toFixed(3)} mg/L`);
      setText('no2Out', `${no2Peak.toFixed(3)} mg/L`);
      setText('no3Out', `${no3Peak.toFixed(3)} mg/L`);
      setText('nh3Out', `${nh3Peak.toFixed(3)} mg/L`);
      setText('co2Out', `${co2Peak.toFixed(2)} mg/L`);
      setText('nutrOut', `${macroPeak.toFixed(2)} mg/L ‚Ä¢ ${microPeak.toFixed(2)} mg/L`);

      // Draw plots
      setStage('Plots', 'rate');
      rateGeom = drawPlot(el('rateCanvas'), baseSim.t, baseSim.rate, {
        title:"Oxygen RATE (g O‚ÇÇ/day)"
      });
      setStage('Plots', 'dissolved oxygen');
      doGeom   = drawDOPlot(el('doCanvas'), baseSim);
      setStage('Plots', 'chemistry');
      chemGeom  = drawPlot(el('chemCanvas'),  baseSim.t, baseSim.chemCum,  {
        title:"Chemistry / Compounds (mg/L)",
        series: CHEM_SERIES,
        visible: visibleChem
      });

      // Flags
      setStage('Flags', 'evaluate');
      setFlags(baseSim, params, null);

      // Debug text
      const dbg = [];
      dbg.push(`Mode: Single run (deterministic)`);
      dbg.push(`Pressure @ altitude: ${pressureFromAltitude_kPa(params.altM).toFixed(2)} kPa`);
      dbg.push(`O2 in pumped air: ${oxy.O2_in_air_g_day.toFixed(2)} g O2/day`);
      dbg.push(`Bubble eff fraction: ${(100*oxy.eff_bubble).toFixed(2)}%  (depth ${params.diffDepthCm.toFixed(1)} cm, SOTE/m ${params.sotePerM.toFixed(2)}%)`);
      dbg.push(`Surface areas: total ${oxy.areas.A_total.toFixed(4)} m¬≤; open ${oxy.areas.A_open.toFixed(4)}; covered ${oxy.areas.A_cov.toFixed(4)}`);
      dbg.push(`Cover leak factor: ${oxy.leak.toFixed(3)}  (tight ${params.tight.toFixed(2)}, headspace ${oxy.head.V_head_L.toFixed(1)} L)`);
      dbg.push(`OTR surface max: ${oxy.OTR_surface_max.toFixed(3)} g/day  (kCalm ${params.kCalm}, kRipple ${params.kRipple}, ripple ${params.ripplePct}%)`);
      dbg.push(`OTR bubble max: ${oxy.OTR_bubble_max.toFixed(3)} g/day`);
      dbg.push(`OTR max: ${oxy.OTR_max.toFixed(3)} g/day`);
      dbg.push(`kLa inferred: ${oxy.kLa.toFixed(4)} 1/day`);
      dbg.push(`Sim dt: ${baseSim.meta.dt.toFixed(4)} days (~${(baseSim.meta.dt*24).toFixed(2)} h)`);
      dbg.push(`Feed mass: start ${baseSim.meta.feedStart.toFixed(3)} g ‚Üí end ${baseSim.meta.feedEnd.toFixed(3)} g`);
      dbg.push(`Rate peaks: demand ${baseSim.meta.maxDemand.toFixed(3)} g/day ‚Ä¢ supply ${baseSim.meta.maxSupply.toFixed(3)} g/day`);
      dbg.push('Metabolism mode: legacy (denit/diurnal/plant/fish/slow COD disabled)');
      dbg.push(`Biofilm proxy: ${params.biofilmMm} mm ‚Ä¢ slowFrac ${params.slowFrac}`);
      dbg.push(`Denit: k=${params.kDenit} 1/day ‚Ä¢ cap=${params.denitCap}`);
      dbg.push(`Fish O2: ${params.fishMass} g @ ${params.fishO2} mg/g/day ‚Ä¢ Plant O2 peak ${params.plantO2} mg/L/day`);
      dbg.push(`Diurnal: tempAmp ${params.tempAmp}¬∞C ‚Ä¢ lights @ ${params.lightHour}:00`);
      dbg.push(`N units: ${params.nUnits} ‚Ä¢ pH=${params.pH} ‚Ä¢ NH3 frac=${nh3Fraction(params.pH ?? 7.0, params.Tnow).toFixed(3)}`);
      dbg.push('');
      dbg.push('--- Snapshot ---');
      dbg.push(...buildDebugSnapshot([]));
      setDebugText(dbg);
    }

    const auditEl = el('chemAudit');
    const auditDetails = el('chemAuditDetails');
    if(auditEl && auditDetails){
      const showAudit = !!params.chemNerd;
      auditDetails.style.display = showAudit ? 'block' : 'none';
      auditDetails.open = showAudit;
      if(showAudit){
        const a = baseSim.audit;
        const lines = [
          `NH‚ÇÑ from protein oxidation: ${(a.nh4_from_pro*1000/params.volL).toFixed(3)} mg/L as N`,
          `NH‚ÇÑ from biomass turnover: ${(a.nh4_from_endog*1000/params.volL).toFixed(3)} mg/L as N`,
          `NH‚ÇÑ ‚Üí NO‚ÇÇ consumed: ${(a.nh4_to_no2*1000/params.volL).toFixed(3)} mg/L as N`,
          `NO‚ÇÇ ‚Üí NO‚ÇÉ consumed: ${(a.no2_to_no3*1000/params.volL).toFixed(3)} mg/L as N`,
          `NO‚ÇÉ ‚Üí N‚ÇÇ (denit): ${(a.no3_to_n2*1000/params.volL).toFixed(3)} mg/L as N`,
          `CO‚ÇÇ from oxidation: ${(a.co2_from_ox*1000/params.volL).toFixed(2)} mg/L`,
          `CO‚ÇÇ from endogenous: ${(a.co2_from_endog*1000/params.volL).toFixed(2)} mg/L`,
          `CO‚ÇÇ from denit: ${(a.co2_from_denit*1000/params.volL).toFixed(2)} mg/L`,
          `Macros released: ${(a.macro_release*1000/params.volL).toFixed(2)} mg/L`,
          `Macros uptake: ${(a.macro_uptake*1000/params.volL).toFixed(2)} mg/L`,
          `Micros released: ${(a.micro_release*1000/params.volL).toFixed(2)} mg/L`,
          `Micros uptake: ${(a.micro_uptake*1000/params.volL).toFixed(2)} mg/L`,
          `N balance: ${(a.n_balance_end*1000/params.volL).toFixed(3)} mg/L as N (initial ${(a.n_balance_init*1000/params.volL).toFixed(3)})`,
          `C balance: ${(a.c_balance_end*1000/params.volL).toFixed(2)} mg/L (initial ${(a.c_balance_init*1000/params.volL).toFixed(2)})`
        ];
        auditEl.textContent = lines.join('\n');
      }
    }

    setStage('Interactions', 'init canvases');
    initCanvasInteractions();

    setRecomputeBubbleState(false);
    setStage('recompute', 'done');
    DEBUG_STATE.lastRecomputeMs = performance.now() - recomputeStart;
    setRecomputeBubbleState('ready', {ms: Number.isFinite(DEBUG_STATE.lastRecomputeMs) ? DEBUG_STATE.lastRecomputeMs.toFixed(1) : 'n/a'});
    if(DEBUG_STATE.lastRecomputeMs > 800){
      addWarning(`Recompute took ${DEBUG_STATE.lastRecomputeMs.toFixed(0)} ms. Consider reducing Monte Carlo runs or disabling live recompute.`);
    }

  }catch(err){
    setRecomputeBubbleState('error', {message: err && err.message ? err.message : String(err)});
    showError(err);
  }
}

function applyDiffuserPreset(){
  const t = el('diffType').value;
  const s = el('sotePerM');
  let v = null;

  // ‚ÄúReasonable starting points‚Äù. Real SOTE depends a lot on bubble size, contact time, and circulation.
  if(t === 'airstone_med')      v = 2.5;
  else if(t === 'airstone_fine')v = 3.5;
  else if(t === 'microbubble') v = 5.5;
  else if(t === 'wood')        v = 4.5;

  if(v !== null){
    s.value = v;
    s.disabled = true;
    s.title = 'Preset value. Choose Custom to edit.';
  }else{
    s.disabled = false;
    s.title = '';
  }
}

function applySurfacePreset(){
  const t = el('surfacePreset').value;
  const kc = el('kCalm');
  const kr = el('kRipple');
  let v = null;

  if(t === 'still')        v = {kCalm:0.15, kRipple:0.45};
  else if(t === 'typical') v = {kCalm:0.30, kRipple:1.00};
  else if(t === 'rippling')v = {kCalm:0.45, kRipple:1.60};
  else if(t === 'splashy') v = {kCalm:0.70, kRipple:2.50};

  if(v){
    kc.value = v.kCalm;
    kr.value = v.kRipple;
    kc.disabled = true; kr.disabled = true;
    kc.title = 'Preset value. Choose Custom to edit.';
    kr.title = 'Preset value. Choose Custom to edit.';
  }else{
    kc.disabled = false; kr.disabled = false;
    kc.title = ''; kr.title = '';
  }
}

function applyTightPreset(){
  const t = el('tightPreset').value;
  const ti = el('tight');
  let v = null;

  if(t === 'open')        v = 0.00;
  else if(t === 'loose_high') v = 0.15;
  else if(t === 'typical')    v = 0.35;
  else if(t === 'near_sealed')v = 0.80;

  if(v !== null){
    ti.value = v;
    ti.disabled = true;
    ti.title = 'Preset value. Choose Custom to edit.';
  }else{
    ti.disabled = false;
    ti.title = '';
  }
}

function applyOtrPreset(){
  const t = el('otrPreset').value;
  const o = el('otrCal');
  let v = null;
  if(t === 'typical') v = 1.00;
  else if(t === 'under') v = 0.75;
  else if(t === 'over') v = 1.25;

  if(v !== null){
    o.value = v;
    o.disabled = true;
    o.title = 'Preset value. Choose Custom to edit.';
  }else{
    o.disabled = false;
    o.title = '';
  }
}

function applyInitDOPreset(){
  const t = el('initDOPreset').value;
  const d = el('doInitPct');
  if(t !== 'custom'){
    d.value = Number(t);
    d.disabled = true;
    d.title = 'Preset value. Choose Custom to edit.';
  }else{
    d.disabled = false;
    d.title = '';
  }
}

function applyAllPresets(){
  // These keep the ‚Äúhuman presets‚Äù and the numeric fields in sync.
  if(el('diffType')) applyDiffuserPreset();
  if(el('surfacePreset')) applySurfacePreset();
  if(el('tightPreset')) applyTightPreset();
  if(el('otrPreset')) applyOtrPreset();
  if(el('initDOPreset')) applyInitDOPreset();
}


/* =========================================================
   Init
========================================================= */
let debounceTimerId = null;
function scheduleRecompute(){
  const mode = el('liveRecompute') ? el('liveRecompute').value : 'on';
  if(mode === 'off'){
    if(el('recomputeBtn')) el('recomputeBtn').style.display = 'inline-block';
    DEBUG_STATE.debounceQueued = 0;
    DEBUG_STATE.debounceMs = null;
    return;
  }
  if(el('recomputeBtn')) el('recomputeBtn').style.display = 'none';
  const debounceDelayMs = 1000;
  DEBUG_STATE.debounceMs = debounceDelayMs;
  if(debounceTimerId !== null){
    DEBUG_STATE.debounceQueued = (DEBUG_STATE.debounceQueued || 0) + 1;
  }else{
    DEBUG_STATE.debounceQueued = 1;
  }
  clearTimeout(debounceTimerId);
  debounceTimerId = setTimeout(()=>{
    DEBUG_STATE.debounceQueued = 0;
    recompute();
  }, debounceDelayMs);
}

function updateModeUI(){
  if(!el('runMode')) return;
  const mode = el('runMode').value;
  if(el('uncSection')) el('uncSection').style.display = (mode === 'uncertainty') ? 'block' : 'none';
  if(el('singleNote')) el('singleNote').style.display = (mode === 'single') ? 'block' : 'none';
}

function init(){
  installGlobalErrorHandlers();
  dedupeAppNodes();
  loadState();
  try{ applyAllPresets(); }catch(_){}

  updateModeUI();
  setDebugText(buildDebugSnapshot(['Init: handlers ready, awaiting recompute.']));
  wireActiveControlGlow();
  enableDebugCopyRoutine();
  measurePanelOverflow();
  if(!window.__panelOverflowBound){
    window.__panelOverflowBound = true;
    window.addEventListener('resize', ()=>measurePanelOverflow());
  }

  // Link sliders
  linkRangeAndNumber(el('pelMass'), el('pelMassN'), ()=>{ scheduleRecompute(); });
  linkRangeAndNumber(el('powMass'), el('powMassN'), ()=>{ scheduleRecompute(); });
  linkRangeAndNumber(el('blanket'), el('blanketN'), ()=>{ scheduleRecompute(); });
  linkRangeAndNumber(el('days'), el('daysN'), ()=>{ scheduleRecompute(); });

  if(el('mcRunsRange') && el('mcRuns')){
    linkRangeAndNumber(el('mcRunsRange'), el('mcRuns'), ()=>{ scheduleRecompute(); });
  }

  // Inputs that trigger recompute
  [
    'volL','airFlow','Tnow','pH','altM','tds','ripplePct',
    'lenCm','widCm','tankHCm','waterSurfCm','blanketGapCm','diffDepthCm','heaters',
    'sotePerM','kCalm','kRipple','tight','otrCal',
    'doInitPct','kDoNit','kNH4Nit','kNO2Nit','nitCap','nitQ10','nUnits',
    'kDoHet','slowFrac','biofilmMm','kDenit','denitCap','fishMass','fishO2','plantO2','tempAmp','lightHour',
    'macroRelease','microRelease','macroUptake','microUptake','chemNerd',
    'pelLen','pelDia','pelRho',
    'diffType','surfacePreset','tightPreset','otrPreset','initDOPreset',
    'runMode','uncLevel','bandPreset','seed','liveRecompute',
    'uAir','uDiff','uSurf','uTight','uBio','uTemp','uInitDO',
    'o2Limit'
  ].forEach(id=>{
    const e = el(id);
    if(!e) return;
    const ev = (e.type === 'checkbox' || e.tagName === 'SELECT') ? 'change' : 'input';
    e.addEventListener(ev, ()=>{
      if(id === 'runMode') updateModeUI();
      // presets need to refresh numeric fields before sim
      if(['diffType','surfacePreset','tightPreset','otrPreset','initDOPreset'].includes(id)){
        try{ applyAllPresets(); }catch(_){}
      }
      scheduleRecompute();
    });
  });

  // Events UI
  const addBtn = el('addEventBtn');
  if(!addBtn){
    addWarning('Missing add-event button (#addEventBtn).');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'addEventBtn', context:'init'});
  }else{
    addBtn.addEventListener('click', ()=>{
    const day = Number(el('evDay').value);
    const pellets = Number(el('evPellets').value);
    const daysMax = Number(el('daysN').value);
    if(!Number.isFinite(day) || !Number.isFinite(pellets)) return;
    const safeDay = clamp(day, 0, Number.isFinite(daysMax) ? daysMax : day);
    const safePel = Math.max(0, Math.round(pellets));
    if(safePel <= 0) return;
    EVENTS.push({day: safeDay, pellets: safePel});
    normalizeEvents();
    saveState();
    renderEvents();
    scheduleRecompute();
    });
  }

  const clearBtn = el('clearEventsBtn');
  if(!clearBtn){
    addWarning('Missing clear-events button (#clearEventsBtn).');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'clearEventsBtn', context:'init'});
  }else{
    clearBtn.addEventListener('click', ()=>{
    EVENTS = [];
    saveState();
    renderEvents();
    scheduleRecompute();
    });
  }

  const recomputeBtn = el('recomputeBtn');
  if(recomputeBtn){
    recomputeBtn.addEventListener('click', ()=>{
      recompute();
      if(el('liveRecompute') && el('liveRecompute').value !== 'off'){
        recomputeBtn.style.display = 'none';
      }
    });
  }

  buildLegendRate();
  buildLegendChem();
  renderEvents();
  recompute();
}

function boot(){
  DEBUG_STATE.initReadyState = document.readyState;
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, {once:true});
  }else{
    init();
  }
}

boot();
})();
</script>
</body>
</html>
