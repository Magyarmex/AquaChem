<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aquarium O₂ Demand Planner (DO + oxygenation model)</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop stop-color='%237aa2ff'/%3E%3Cstop offset='1' stop-color='%2363e6be'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='14' fill='%230b1020'/%3E%3Cpath d='M32 10c9.5 0 17.2 7.7 17.2 17.2S41.5 50 32 50 14.8 42.3 14.8 32 22.5 10 32 10Z' fill='url(%23g)' fill-opacity='.35'/%3E%3Cpath d='M32 17c7.2 0 13 5.8 13 13s-5.8 13-13 13-13-5.8-13-13 5.8-13 13-13Z' fill='url(%23g)'/%3E%3Cpath d='M31.7 23.5c2.7 4 5.3 7.2 5.3 10.2 0 3-2.4 5.4-5.3 5.4s-5.3-2.4-5.3-5.4c0-3 2.6-6.2 5.3-10.2Z' fill='%230b1020' fill-opacity='.85'/%3E%3C/svg%3E" />
  <style>
    :root{
      --bg:#0b1020; --panel:#111a33; --panel2:#0f1730; --text:#e7ecff; --muted:#a9b3d6;
      --line:#2a3766; --accent:#7aa2ff; --warn:#ffcf5a; --danger:#ff6b6b; --ok:#63e6be;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 15% -10%, rgba(122,162,255,.18), transparent 60%),
        radial-gradient(900px 400px at 90% 0%, rgba(99,230,190,.12), transparent 55%),
        linear-gradient(180deg,#070a14,#0b1020 25%,#0b1020);
      color:var(--text);
      font-family:var(--sans);
      min-height:100vh;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background-image: linear-gradient(rgba(255,255,255,.04) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,.03) 1px, transparent 1px);
      background-size: 42px 42px, 42px 42px;
      opacity:.25;
      z-index:0;
    }
    header{
      padding:22px 20px 16px;
      border-bottom:1px solid var(--line);
      position:sticky;
      top:0;
      background:linear-gradient(180deg, rgba(11,16,32,.98), rgba(11,16,32,.88));
      backdrop-filter: blur(12px);
      z-index:10;
    }
    header h1{margin:0;font-size:20px;font-weight:700;letter-spacing:.3px}
    header p{margin:8px 0 0;color:var(--muted);font-size:13px;max-width:1100px;line-height:1.45}
    .wrap{max-width:1280px;margin:0 auto;padding:20px;display:grid;gap:16px;grid-template-columns: 480px 1fr;position:relative;z-index:1;}
    @media (max-width: 1100px){ .wrap{grid-template-columns:1fr;} header{position:static;} }
    .card{
      background:linear-gradient(180deg,rgba(17,26,51,.98),rgba(13,20,44,.96));
      border:1px solid rgba(122,162,255,.16);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:16px;
      backdrop-filter: blur(6px);
    }
    .card h2{margin:0 0 12px;font-size:14px;color:#dfe6ff;text-transform:uppercase;letter-spacing:.12em}
    .grid2{display:grid;gap:10px;grid-template-columns:1fr 1fr;}

    .grid3{display:grid;gap:10px;grid-template-columns:1fr 1fr 1fr;}
    .grid4{display:grid;gap:10px;grid-template-columns:1fr 1fr 1fr 1fr;}
    @media (max-width: 900px){
      .grid3{grid-template-columns:1fr 1fr;}
      .grid4{grid-template-columns:1fr 1fr;}
    }
    @media (max-width: 560px){
      .grid3{grid-template-columns:1fr;}
      .grid4{grid-template-columns:1fr;}
    }
    .row{display:flex;gap:12px;align-items:center}
    .row label{flex:1;color:var(--muted);font-size:12px;letter-spacing:.02em}
    input[type="range"]{width:100%}
    input[type="number"], input[type="text"], select{
      background:#0a1024;border:1px solid rgba(122,162,255,.26);color:var(--text);
      border-radius:12px;padding:9px 12px;font-size:13px;outline:none;
      transition:border-color .2s ease, box-shadow .2s ease, transform .2s ease;
    }
    input[type="number"]:focus, input[type="text"]:focus, select:focus{
      border-color:rgba(122,162,255,.55);
      box-shadow:0 0 0 3px rgba(122,162,255,.18);
      transform:translateY(-1px);
    }
    input[type="range"]{accent-color:var(--accent)}
    input[type="number"]{width:120px}
    select{width:100%}
    .small{font-size:12px;color:var(--muted);line-height:1.35}
    .mono{font-family:var(--mono)}
    .pill{
      display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.16); background:rgba(255,255,255,.05); font-size:12px;
    }
    .pill.ok{border-color:rgba(99,230,190,.35);} .pill.warn{border-color:rgba(255,207,90,.45);} .pill.danger{border-color:rgba(255,107,107,.45);}
    .flags{display:grid;gap:12px}
    .flag-card{
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04);
      overflow:hidden;
      box-shadow:var(--shadow);
    }
    .flag-tag{
      padding:6px 12px;
      font-weight:700;
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .flag-tag.ok{background:rgba(99,230,190,.18); color:#d5fff1;}
    .flag-tag.warn{background:rgba(255,207,90,.22); color:#fff3d1;}
    .flag-tag.danger{background:rgba(255,107,107,.22); color:#ffd1d1;}
    .flag-tag.note{background:rgba(122,162,255,.18); color:#dfe6ff;}
    .flag-body{padding:10px 12px;color:var(--text)}
    .tag-stack{display:grid;gap:8px}
    .tag-line{
      border:1px solid rgba(255,255,255,.14);
      border-radius:12px;
      padding:8px 12px;
      background:rgba(0,0,0,.18);
    }
    .tag-line summary{
      display:flex;
      align-items:center;
      gap:10px;
      list-style:none;
      cursor:pointer;
      color:#dfe6ff;
      font-weight:600;
      font-size:13px;
    }
    .tag-line summary::-webkit-details-marker{display:none}
    .tag-line .tag-title{flex:1;min-width:0}
    .tag-line .tag-meta{color:var(--muted);font-weight:500;font-size:12px;white-space:nowrap}
    .tag-line .tag-spark{
      width:90px;
      height:26px;
      flex:0 0 auto;
      border-radius:8px;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.12);
    }
    .tag-line .tag-chip{
      padding:2px 8px;
      border-radius:999px;
      font-size:10px;
      letter-spacing:.08em;
      text-transform:uppercase;
      border:1px solid transparent;
    }
    .tag-line.tone-ok{border-color:rgba(99,230,190,.32)}
    .tag-line.tone-warn{border-color:rgba(255,207,90,.32)}
    .tag-line.tone-danger{border-color:rgba(255,107,107,.32)}
    .tag-line .tag-chip.ok{background:rgba(99,230,190,.18); color:#d5fff1; border-color:rgba(99,230,190,.45)}
    .tag-line .tag-chip.warn{background:rgba(255,207,90,.18); color:#fff3d1; border-color:rgba(255,207,90,.45)}
    .tag-line .tag-chip.danger{background:rgba(255,107,107,.18); color:#ffd1d1; border-color:rgba(255,107,107,.45)}
    .tag-details{margin-top:8px;color:var(--muted);font-size:12px;line-height:1.45}
    .btn{
      background:rgba(122,162,255,.18);
      border:1px solid rgba(122,162,255,.35);
      color:var(--text);
      border-radius:12px;
      padding:9px 12px;
      font-size:13px;
      cursor:pointer;
      user-select:none;
      transition:transform .2s ease, box-shadow .2s ease, background .2s ease;
    }
    .btn:hover{background:rgba(122,162,255,.26);transform:translateY(-1px);box-shadow:0 8px 18px rgba(0,0,0,.25)}
    .btn.danger{border-color:rgba(255,107,107,.55); background:rgba(255,107,107,.12)}
    .btn.danger:hover{background:rgba(255,107,107,.18)}
    .btn.ghost{background:transparent;border-color:rgba(255,255,255,.18)}
    .btn.ghost:hover{background:rgba(255,255,255,.06)}
    details{border:1px solid rgba(255,255,255,.14);border-radius:12px;padding:12px;background:rgba(0,0,0,.16)}
    details summary{cursor:pointer;color:#dfe6ff;font-weight:600;font-size:13px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:8px 6px;border-bottom:1px solid rgba(255,255,255,.08);font-size:12px;color:var(--muted)}
    tr:nth-child(even) td{background:rgba(255,255,255,.02)}
    th{color:#dfe6ff;text-align:left;font-weight:600}
    td input[type="number"]{width:90px}
    canvas{width:100%;height:300px;border-radius:14px;background:linear-gradient(180deg,#070b18,#070f1d);border:1px solid rgba(255,255,255,.08)}
    .charts{display:grid;gap:12px;grid-template-columns:1fr}
    .legend{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
    .leg{
      display:flex;gap:8px;align-items:center;font-size:12px;color:var(--muted);
      padding:6px 10px;border:1px solid rgba(255,255,255,.12);border-radius:12px;background:rgba(255,255,255,.05);
      cursor:pointer; user-select:none;
    }
    .dot{width:10px;height:10px;border-radius:50%}
    .leg.off{opacity:.35}
    .tooltip{
      position:fixed; pointer-events:none; z-index:99;
      background:rgba(17,26,51,.95); border:1px solid rgba(255,255,255,.14);
      border-radius:12px; padding:10px 12px; box-shadow:var(--shadow);
      font-size:12px; color:var(--text); max-width:360px; display:none;
    }
    .kbd{font-family:var(--mono);font-size:11px;padding:2px 6px;border:1px solid rgba(255,255,255,.16);border-radius:8px;background:rgba(255,255,255,.06);color:#dfe6ff}
    .note{color:var(--muted);font-size:12px;line-height:1.45}
    .footer{margin-top:8px;color:var(--muted);font-size:11px}
    .hr{height:1px;background:rgba(255,255,255,.10);margin:10px 0}
    .errbox{border:1px solid rgba(255,107,107,.35);background:rgba(255,107,107,.08);padding:10px;border-radius:12px;color:#ffd1d1;font-size:12px;display:none}
    .errbox pre{margin:8px 0 0;white-space:pre-wrap;word-break:break-word;color:#ffd1d1}
  </style>
</head>
<body>
<header class="app-header">
  <h1>O₂ Demand Planner — pellets + powder + “pop” events + DO simulation</h1>
  <p>
    This sim estimates <b>oxygen demand</b> from decomposing feed and (optionally) nitrification.
    It also simulates <b>dissolved oxygen (DO)</b> using an inferred oxygenation model:
    <b>bubble transfer</b> (airflow + depth + diffuser efficiency) + <b>surface transfer</b> (ripples + blanket coverage + headspace ventilation).
    The goal is inference: plausible numbers you can tune later with even one real-world measurement.
  </p>
</header>

<div class="wrap">
  <div class="card">
    <h2>Inputs</h2>

    <div class="row">
      <label>Pellet mass added (as-fed, g)</label>
      <input id="pelMass" type="range" min="0" max="5" step="0.01" value="1.00"/>
      <input id="pelMassN" type="number" min="0" max="50" step="0.01" value="1.00"/>
    </div>
    <div class="small" style="margin-top:-6px">
      Provided feed mass ≈ <b id="pelCount">—</b> (<span id="pelEach">—</span> each).
    </div>

    <div class="row">
      <label>Powder mass added (as-fed, g)</label>
      <input id="powMass" type="range" min="0" max="5" step="0.01" value="0.00"/>
      <input id="powMassN" type="number" min="0" max="50" step="0.01" value="0.00"/>
    </div>

    <div class="row">
      <label>Blanket cover (%) — uncovered = chimney</label>
      <input id="blanket" type="range" min="0" max="100" step="1" value="80"/>
      <input id="blanketN" type="number" min="0" max="100" step="1" value="80"/>
    </div>

    <div class="row">
      <label>Simulation time (days)</label>
      <input id="days" type="range" min="7" max="180" step="1" value="30"/>
      <input id="daysN" type="number" min="1" max="365" step="1" value="30"/>
    </div>

    <details id="uncModeDetails" open style="margin-top:10px">
      <summary>Uncertainty Mode (Monte Carlo)</summary>
      <div class="small" style="margin-top:10px">
        Default mode: the sim runs many plausible “nearby realities” and shows a band (not a single pretend-precise line).
        Without a real DO measurement, this is the honest way to use the model.
      </div>

      <div class="grid2" style="margin-top:10px">
        <div class="row">
          <label>Run mode</label>
          <select id="runMode">
            <option value="uncertainty" selected>Uncertainty (recommended)</option>
            <option value="single">Single run (deterministic)</option>
          </select>
        </div>
        <div class="row">
          <label>Uncertainty level</label>
          <select id="uncLevel">
            <option value="tight">Tight (you measured most things)</option>
            <option value="typical" selected>Typical (some guesses)</option>
            <option value="wide">Wide (many guesses)</option>
          </select>
        </div>

        <div class="row">
          <label>Monte Carlo runs</label>
          <input id="mcRunsRange" type="range" min="50" max="800" step="10" value="200"/>
          <input id="mcRuns" type="number" min="10" max="2000" step="10" value="200"/>
        </div>

        <div class="row">
          <label>Band shown</label>
          <select id="bandPreset">
            <option value="10-90" selected>10–90% (wide)</option>
            <option value="25-75">25–75% (mid)</option>
            <option value="5-95">5–95% (very wide)</option>
          </select>
        </div>

        <div class="row">
          <label>Random seed</label>
          <input id="seed" type="number" step="1" value="12345"/>
        </div>
        <div class="row">
          <label>Live recompute</label>
          <select id="liveRecompute">
            <option value="on" selected>On (debounced)</option>
            <option value="off">Off (click Recompute)</option>
          </select>
        </div>
      </div>

      <div style="margin-top:10px">
        <button class="btn" id="recomputeBtn" style="display:none">Recompute</button>
      </div>

      <div class="hr"></div>

      <div class="small"><b>What varies across runs:</b></div>
      <div class="grid2" style="margin-top:8px">
        <div class="row"><label><input id="uAir" type="checkbox" checked> Pump delivered airflow</label></div>
        <div class="row"><label><input id="uDiff" type="checkbox" checked> Bubble transfer efficiency</label></div>
        <div class="row"><label><input id="uSurf" type="checkbox" checked> Surface exchange (k values)</label></div>
        <div class="row"><label><input id="uTight" type="checkbox" checked> Blanket “tightness” / leakiness</label></div>
        <div class="row"><label><input id="uBio" type="checkbox" checked> Biology speed (microbes, kinetics)</label></div>
        <div class="row"><label><input id="uTemp" type="checkbox" checked> Water temperature</label></div>
        <div class="row"><label><input id="uInitDO" type="checkbox" checked> Initial DO</label></div>
      </div>

      <div class="small" style="margin-top:8px">
        The band is a <b>distribution</b>, not a promise. If you calibrate with real DO data later, the band shrinks and gets less “vibes, more physics”.
      </div>
    </details>



    <div class="hr"></div>

    <h2>Pop events (convert pellets → powder)</h2>
    <div class="note">
      Click the <span class="kbd">RATE</span> graph to add an event at that day, or use the table below.
      Each event converts whole pellets into powder at that moment (mass is conserved).
    </div>
    <div class="grid3" style="margin-top:10px">
      <div class="row">
        <label>Event day</label>
        <input id="evDay" type="number" min="0" step="0.1" value="3.0"/>
      </div>
      <div class="row">
        <label>Pellets to pop</label>
        <input id="evPellets" type="number" min="0" step="1" value="10"/>
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn" id="addEventBtn">Add event</button>
      </div>
    </div>
    <div style="margin-top:8px">
      <button class="btn ghost" id="clearEventsBtn">Clear events</button>
    </div>

    <div style="margin-top:10px; max-height:220px; overflow:auto;">
      <table id="eventsTable">
        <thead>
          <tr><th>Day</th><th>Pellets to pop</th><th></th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="hr"></div>
    <div class="errbox" id="errBox">
      <b>Model error</b>
      <div class="small" style="margin-top:6px">
        If this repeats, open Dev / debug and copy the stack trace.
      </div>
      <pre id="errText"></pre>
    </div>

    <details style="margin-top:12px" open>
      <summary>Advanced: Environment & tank</summary>

      <div class="grid2" style="margin-top:10px">
        <div class="row">
          <label>Tank water volume (L)</label>
          <input id="volL" type="number" step="0.1" value="65.0"/>
        </div>
        <div class="row">
          <label>Water temp (°C) at current blanket setting</label>
          <input id="Tnow" type="number" step="0.1" value="22.0"/>
        </div>

        <div class="row">
          <label>Water pH (for NH₃ fraction)</label>
          <input id="pH" type="number" step="0.05" value="7.4"/>
        </div>
        <div class="row">
          <label>Altitude (m)</label>
          <input id="altM" type="number" step="10" value="2300"/>
        </div>
        <div class="row">
          <label>TDS (mg/L)</label>
          <input id="tds" type="number" step="10" value="660"/>
        </div>

        <div class="row">
          <label>Tank length (cm)</label>
          <input id="lenCm" type="number" step="0.1" value="78.0"/>
        </div>
        <div class="row">
          <label>Tank width (cm)</label>
          <input id="widCm" type="number" step="0.1" value="31.0"/>
        </div>
        <div class="row">
          <label>Tank height (cm)</label>
          <input id="tankHCm" type="number" step="0.1" value="48.0"/>
        </div>
        <div class="row">
          <label>Water surface from bottom (cm)</label>
          <input id="waterSurfCm" type="number" step="0.1" value="22.0"/>
        </div>
        <div class="row">
          <label>Blanket gap above rim (cm)</label>
          <input id="blanketGapCm" type="number" step="0.1" value="0.0"/>
        </div>
        <div class="row">
          <label>Diffuser depth below surface (cm)</label>
          <input id="diffDepthCm" type="number" step="0.1" value="17.0"/>
        </div>
        <div class="row">
          <label>Water column heaters (0–2)</label>
          <input id="heaters" type="number" step="1" min="0" max="2" value="0"/>
        </div>
      </div>
    </details>

    <details style="margin-top:12px" open>
      <summary>Advanced: Aeration & surface exchange</summary>

      <div class="grid2" style="margin-top:10px">
        <div class="row">
          <label>Air pump delivered flow (L/min)</label>
          <input id="airFlow" type="number" step="0.1" value="4.0"/>
        </div>
        <div class="row">
          <label>Surface ripples (% of surface)</label>
          <input id="ripplePct" type="number" step="1" value="50"/>
        </div>

        <div class="row">
          <label>Bubble transfer preset</label>
          <select id="diffType">
            <option value="airstone_med" selected>Typical airstones (medium bubbles)</option>
            <option value="airstone_fine">Fine airstone (smaller bubbles)</option>
            <option value="microbubble">Microbubble diffuser (very fine)</option>
            <option value="wood">Wooden airstone (very fine, higher backpressure)</option>
            <option value="custom">Custom</option>
          </select>
        </div>

        <div class="row">
          <label>Custom bubble efficiency: SOTE per meter (%)</label>
          <input id="sotePerM" type="number" step="0.1" value="2.5"/>
        </div>
        <div class="small" style="margin-top:-6px; opacity:.85">
          SOTE per meter is a <b>rough transfer efficiency</b> (how much O₂ in the air actually dissolves per meter of bubble travel).
          If you’re unsure, use the preset — the uncertainty mode already widens results around it.
        </div>

        <div class="row" style="margin-top:10px">
          <label>Surface exchange preset</label>
          <select id="surfacePreset">
            <option value="still">Still water (low exchange)</option>
            <option value="typical" selected>Typical aquarium (some ripples)</option>
            <option value="rippling">Strong ripples (good exchange)</option>
            <option value="splashy">Splashy / fan / very agitated (very high)</option>
            <option value="custom">Custom</option>
          </select>
        </div>

        <div class="row">
          <label>Surface k (calm) (m/day)</label>
          <input id="kCalm" type="number" step="0.05" value="0.30"/>
        </div>
        <div class="row">
          <label>Surface k (rippling) (m/day)</label>
          <input id="kRipple" type="number" step="0.05" value="1.00"/>
        </div>

        <div class="row" style="margin-top:10px">
          <label>Cover leakiness preset</label>
          <select id="tightPreset">
            <option value="open">No cover (open tank)</option>
            <option value="loose_high" selected>Loose blanket (high above water)</option>
            <option value="typical">Typical blanket (some restriction)</option>
            <option value="near_sealed">Near-sealed lid (strong restriction)</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div class="row">
          <label>Leakiness number (0 drafty → 1 sealed)</label>
          <input id="tight" type="number" step="0.05" min="0" max="1" value="0.25"/>
        </div>

        <div class="row" style="margin-top:10px">
          <label>Aeration performance preset</label>
          <select id="otrPreset">
            <option value="typical" selected>Typical (as expected)</option>
            <option value="under">Underperforming (backpressure / leaks)</option>
            <option value="over">Overperforming (very efficient)</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div class="row">
          <label>Aeration performance factor</label>
          <input id="otrCal" type="number" step="0.05" value="1.00"/>
        </div>
      </div>

      <div class="footer">
        <b>How the oxygenation estimate works</b> (in plain talk):
        <ul style="margin:6px 0 0 18px; padding:0; color:var(--muted)">
          <li><b>Bubble side</b>: compute O₂ mass entering per day from the airflow (altitude affects pressure), then multiply by an efficiency fraction that scales with depth and diffuser type.</li>
          <li><b>Surface side</b>: use a gas-film “speed” k (m/day) times surface area. Ripples get a higher k. Covered area gets k multiplied by a leak factor based on tightness + headspace ventilation.</li>
          <li>Combine both into an <b>OTRmax</b> (g/day at DO≈0). Convert that into an inferred <b>kLa</b> so supply increases as DO drops: supply = kLa·(C*−DO)·V.</li>
        </ul>
      </div>
    </details>

    <details style="margin-top:12px" open>
      <summary>Advanced: Biology & chemistry</summary>

      <div class="grid2" style="margin-top:10px">
        <div class="row">
          <label>Initial DO assumption</label>
          <select id="initDOPreset">
            <option value="100">Near saturation (100%)</option>
            <option value="95" selected>High (95%)</option>
            <option value="85">Moderate (85%)</option>
            <option value="70">Low (70%)</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div class="row">
          <label>Initial DO (% of local saturation)</label>
          <input id="doInitPct" type="number" step="1" min="0" max="150" value="95"/>
        </div>

        <div class="row">
          <label>Fish biomass (g) — respiration inferred</label>
          <input id="fishMass" type="number" step="1" min="0" value="0"/>
        </div>
        <div class="row">
          <label>Photosynthetic mass (g wet biomass)</label>
          <input id="photoMass" type="number" step="1" min="0" value="0"/>
        </div>
        <div class="small" style="margin-top:-6px; opacity:.85">
          Photosynthetic mass combines plants, algae, and phytoplankton. Oxygen production + nutrient uptake are inferred from this.
        </div>

        <div class="row">
          <label>Diurnal temp amplitude (°C)</label>
          <input id="tempAmp" type="number" step="0.1" min="0" value="0.6"/>
        </div>
        <div class="row">
          <label>Lights on (hour 0–23)</label>
          <input id="lightHour" type="number" step="1" min="0" max="23" value="9"/>
        </div>

        <div class="row">
          <label>Enable oxygen limitation for nitrification</label>
          <select id="o2Limit">
            <option value="off">Off (demand not reduced when DO is low)</option>
            <option value="on">On (nitrification slows as DO drops)</option>
          </select>
        </div>
        <div class="row">
          <label>Nitrifier DO half-saturation K (mg/L)</label>
          <input id="kDoNit" type="number" step="0.05" value="0.50"/>
        </div>
        <div class="row">
          <label>NH₄ half-saturation K (mg/L as N)</label>
          <input id="kNH4Nit" type="number" step="0.05" value="0.40"/>
        </div>
        <div class="row">
          <label>NO₂ half-saturation K (mg/L as N)</label>
          <input id="kNO2Nit" type="number" step="0.05" value="0.25"/>
        </div>
        <div class="row">
          <label>Nitrifier capacity (0–1)</label>
          <input id="nitCap" type="number" step="0.05" min="0" max="1" value="0.80"/>
        </div>
        <div class="row">
          <label>Nitrifier Q10 (temperature response)</label>
          <input id="nitQ10" type="number" step="0.05" value="2.0"/>
        </div>
        <div class="row">
          <label>Heterotroph DO half-saturation K (mg/L)</label>
          <input id="kDoHet" type="number" step="0.05" value="0.80"/>
        </div>
        <div class="row">
          <label>Refractory fraction (slow COD)</label>
          <input id="slowFrac" type="number" step="0.05" min="0" max="0.9" value="0.25"/>
        </div>
        <div class="row">
          <label>Biofilm thickness proxy (mm)</label>
          <input id="biofilmMm" type="number" step="0.1" min="0" value="0.6"/>
        </div>
        <div class="row">
          <label>Denitrification rate (1/day)</label>
          <input id="kDenit" type="number" step="0.05" value="0.15"/>
        </div>
        <div class="row">
          <label>Denitrifier capacity (0–1)</label>
          <input id="denitCap" type="number" step="0.05" min="0" max="1" value="0.60"/>
        </div>

        <div class="row">
          <label>Nitrogen display units</label>
          <select id="nUnits">
            <option value="asN" selected>as N (mg/L)</option>
            <option value="asIon">as ion (mg/L)</option>
          </select>
        </div>
        <div class="row">
          <label>Chemistry audit (nerd mode)</label>
          <input id="chemNerd" type="checkbox"/>
        </div>
      </div>
    </details>

    <details style="margin-top:12px" open>
      <summary>Advanced: Pellet geometry</summary>

      <div class="grid2" style="margin-top:10px">
        <div class="row">
          <label>Pellet length (cm)</label>
          <input id="pelLen" type="number" step="0.01" value="1.00" disabled title="Hardcoded: 1.00 cm"/>
        </div>
        <div class="row">
          <label>Pellet diameter (cm)</label>
          <input id="pelDia" type="number" step="0.01" value="0.20" disabled title="Hardcoded: 0.20 cm"/>
        </div>
        <div class="row">
          <label>Pellet density (g/cm³)</label>
          <input id="pelRho" type="number" step="0.01" value="0.55"/>
        </div>
      </div>
    </details>

  </div>

  <div class="card">
    <h2>Charts</h2>
    <div class="charts">
      <div>
        <canvas id="rateCanvas" width="1200" height="360"></canvas>
        <div class="small" style="margin-top:6px">Rate chart (g O₂/day). Click to add a “pop” event at that day.</div>
      </div>
      <div>
        <canvas id="doCanvas" width="1200" height="360"></canvas>
        <div class="small" style="margin-top:6px">Dissolved oxygen (mg/L). Dashed line is local saturation C*.</div>
      </div>
      <div>
        <canvas id="chemCanvas" width="1200" height="360"></canvas>
        <div class="small" style="margin-top:6px">Chemistry / compounds (mg/L). Choose net concentrations, production-only, or cumulative production; toggle NH₄/NO₂/NO₃ units in Advanced.</div>
        <div class="row" style="margin-top:8px">
          <label>Chemistry display mode</label>
          <select id="chemDisplay">
            <option value="bio" selected>Net concentrations (after consumption)</option>
            <option value="prod">Production only (no consumption)</option>
            <option value="cum">Cumulative production</option>
          </select>
        </div>
      </div>
      <div>
        <canvas id="bioCanvas" width="1200" height="320"></canvas>
        <div class="small" style="margin-top:6px">Expected biomass fluctuations (heterotroph + phyto). Right axis shows % change from initial mass.</div>
      </div>
    </div>

    <div class="small" style="margin-top:8px">Rate chart series</div>
    <div class="legend" id="legendRate"></div>
    <div class="small" style="margin-top:12px">Chemistry chart series</div>
    <div class="legend" id="legendChem"></div>
    <div class="small" style="margin-top:12px">Biomass chart series</div>
    <div class="legend" id="legendBio"></div>

    <div class="hr"></div>

    <h2>Chemistry overview</h2>
    <div class="small">Tag lines summarize modeled peaks/mins (including NO₂, NO₃, and copper proxy). Tap a line to expand details and see safe vs caution vs dangerous reference bands.</div>
    <div class="tag-stack" id="chemTags" style="margin-top:10px"></div>

    <details id="chemAuditDetails" style="margin-top:10px; display:none;">
      <summary>Chemistry audit (nerd mode)</summary>
      <div class="small" style="margin-top:8px">Audit trails for nitrogen + CO₂ + nutrients.</div>
      <pre id="chemAudit" class="mono" style="white-space:pre-wrap; word-break:break-word; color:rgba(231,236,255,.82)"></pre>
    </details>

    <div class="hr"></div>

    <div class="note">
      <b>Interpretation tip:</b> When DO is high, supply is smaller because (C*−DO) is smaller. As DO falls, the same aeration becomes more “hungry” and transfers more O₂.
      If the DO curve still crashes, the model is saying “even when the water is starving for O₂, your demand beats your supply.”
    </div>


<details id="dbgDetails" style="margin-top:14px">
  <summary>Dev / debug</summary>
  <div class="small" style="margin-top:10px">
    Errors and warnings also show in the browser console.
  </div>
  <div class="hr"></div>
  <div class="small"><b>Last recompute diagnostics</b></div>
  <pre id="dbg" class="mono" style="white-space:pre-wrap; word-break:break-word; color:rgba(231,236,255,.82)"></pre>
</details>


  </div>
</div>

<div class="tooltip" id="tip"></div>

<script>

/* =========================================================
   Series registry (rate + chemistry charts)
========================================================= */
const RATE_SERIES = [
  {key:"carb",  name:"Carbs → CO₂ (direct)", color:"#54a0ff"},
  {key:"prot",  name:"Protein → CO₂ + NH₄ (direct)", color:"#ff9f43"},
  {key:"fat",   name:"Fat → CO₂ (direct)", color:"#2ecc71"},
  {key:"endog", name:"Endogenous respiration", color:"#ff6b6b"},
  {key:"nh4",   name:"NH₄ → NO₂ (nitrification)", color:"#a29bfe"},
  {key:"no2",   name:"NO₂ → NO₃ (nitrification)", color:"#c8d6e5"},
  {key:"fish",  name:"Heterotroph respiration", color:"#ff9ff3"},
  {key:"plant", name:"Phyto O₂ production", color:"#1dd1a1"},
  {key:"total", name:"TOTAL demand", color:"#ff5fd2", bold:true},
  {key:"supply",name:"O₂ transfer into water (dynamic)", color:"#63e6be", dash:true},
];

const CHEM_SERIES = [
  {key:"nh4", name:"NH₄ (total ammonia)", color:"#ffd166"},
  {key:"nh3", name:"NH₃ (unionized)", color:"#ff8fab"},
  {key:"no2", name:"NO₂", color:"#a29bfe"},
  {key:"no3", name:"NO₃", color:"#63e6be"},
  {key:"co2", name:"CO₂ (produced)", color:"#54a0ff"},
  {key:"macro", name:"Macros (proxy)", color:"#f4d35e"},
  {key:"micro", name:"Micros (proxy)", color:"#b8c0ff"},
];

const BIOMASS_SERIES = [
  {key:"hetero_g", name:"Heterotroph mass (g)", color:"#ff9f43", bold:true},
  {key:"phyto_g", name:"Phyto mass (g)", color:"#1dd1a1", bold:true},
  {key:"hetero_pct", name:"Heterotroph Δ% (right axis)", color:"#ffd166", dash:true},
  {key:"phyto_pct", name:"Phyto Δ% (right axis)", color:"#a8e6cf", dash:true}
];

let visibleRate = Object.fromEntries(RATE_SERIES.map(s=>[s.key, true]));
let visibleChem = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, true]));

function updateChemSeriesLabels(nUnits){
  if(nUnits === 'asIon'){
    CHEM_SERIES.find(s=>s.key==='nh4').name = 'NH₄⁺ (ion)';
    CHEM_SERIES.find(s=>s.key==='no2').name = 'NO₂⁻ (ion)';
    CHEM_SERIES.find(s=>s.key==='no3').name = 'NO₃⁻ (ion)';
  }else{
    CHEM_SERIES.find(s=>s.key==='nh4').name = 'NH₄-N';
    CHEM_SERIES.find(s=>s.key==='no2').name = 'NO₂-N';
    CHEM_SERIES.find(s=>s.key==='no3').name = 'NO₃-N';
  }
}

function buildCumulativeSeries(seriesDict, dt){
  const series = {};
  const totals = {};
  let invalidCount = 0;
  for(const [key, arr] of Object.entries(seriesDict || {})){
    const cum = new Array(arr.length);
    let sum = 0;
    let bad = 0;
    for(let i=0;i<arr.length;i++){
      const v = arr[i];
      const safe = Number.isFinite(v) ? v : 0;
      if(!Number.isFinite(v)) bad++;
      sum += safe * dt;
      cum[i] = sum;
    }
    series[key] = cum;
    totals[key] = sum;
    invalidCount += bad;
  }
  return {series, info:{invalidCount, totals, dt}};
}

/* =========================================================
   DOM helpers + error plumbing
========================================================= */
const el = id => document.getElementById(id);
const setText = (id, value)=>{
  const node = el(id);
  if(node) node.textContent = value;
};

function ensureTooltip(){
  // Robust: support either #tip or legacy #tooltip. Create if missing.
  let t = el('tip') || el('tooltip');
  if(!t){
    t = document.createElement('div');
    t.className = 'tooltip';
    t.id = 'tip';
    document.body.appendChild(t);
  }
  return t;
}
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

function showError(err){
  let box = el('errBox');
  let txt = el('errText');
  const msg = (err && err.stack) ? err.stack : String(err);

  if(!box || !txt){
    box = document.createElement('div');
    box.id = 'errBox';
    box.className = 'errbox';
    box.style.display = 'block';
    box.innerHTML = `<b>Model error</b><pre id="errText"></pre>`;
    document.body.appendChild(box);
    txt = el('errText');
  }

  // Visible error banner
  if(box) box.style.display = 'block';
  if(txt) txt.textContent = msg;

  // Record into debug state
  try{
    DEBUG_STATE.errors.push({
      timeISO: new Date().toISOString(),
      name: (err && err.name) ? err.name : 'Error',
      message: (err && err.message) ? err.message : String(err),
      stack: (err && err.stack) ? err.stack : '',
      stage: DEBUG_STATE.stage,
      stageExtra: DEBUG_STATE.stageExtra
    });
  }catch(_){}

  // Populate debug panel with a snapshot + full stack
  try{
    const extra = [
      'Error:',
      msg
    ];
    setDebugText(buildDebugSnapshot(extra));
    const det = el('dbgDetails');
    if(det) det.open = true;
  }catch(_){}

  console.error(err);
}
function clearError(){
  const box = el('errBox');
  const text = el('errText');
  if(box) box.style.display = 'none';
  if(text) text.textContent = '';
}


// ---------------- Debug state (for “what just happened?”) ----------------
const DEBUG_STATE = {
  stage: 'init',
  stageExtra: '',
  lastParams: null,
  lastOxy: null,
  lastMode: null,
  lastSimMeta: null,
  lastScalars: null,
  lastChemCumInfo: null,
  lastRecomputeMs: null,
  lastFlagsCount: null,
  lastFlagsMode: null,
  lastPhotoModel: null,
  lastFeedProfileId: null,
  lastFeedProfileStoredAt: null,
  lastRateBandKeys: null,
  lastChemBandKeys: null,
  lastOxygenClampCount: null,
  lastPlantLimitedSteps: null,
  lastBiomassSummary: null,
  lastTagSparkCount: null,
  lastUpdateISO: null,
  missingContainers: [],
  initReadyState: null,
  errors: [],  // newest last
  warnings: []
};

function setStage(stage, extra=null){
  DEBUG_STATE.stage = String(stage || '');
  DEBUG_STATE.stageExtra = extra ? String(extra) : '';
}

function addWarning(message){
  if(!message) return;
  DEBUG_STATE.warnings.push({
    timeISO: new Date().toISOString(),
    message: String(message),
    stage: DEBUG_STATE.stage,
    stageExtra: DEBUG_STATE.stageExtra
  });
}

function ensureFeedProfileMemory(){
  try{
    const key = 'aquachem.feedProfile';
    const existing = localStorage.getItem(key);
    if(!existing){
      localStorage.setItem(key, JSON.stringify(FEED_PROFILE));
      DEBUG_STATE.lastFeedProfileStoredAt = new Date().toISOString();
    }else{
      try{
        const parsed = JSON.parse(existing);
        if(parsed?.id !== FEED_PROFILE.id){
          localStorage.setItem(key, JSON.stringify(FEED_PROFILE));
          DEBUG_STATE.lastFeedProfileStoredAt = new Date().toISOString();
        }
      }catch(_){
        localStorage.setItem(key, JSON.stringify(FEED_PROFILE));
        DEBUG_STATE.lastFeedProfileStoredAt = new Date().toISOString();
      }
    }
    DEBUG_STATE.lastFeedProfileId = FEED_PROFILE.id;
  }catch(err){
    addWarning(`Unable to store feed profile memory: ${err?.message || err}`);
  }
}

function setDebugText(lines){
  const pre = el('dbg');
  if(!pre) return;
  pre.textContent = Array.isArray(lines) ? lines.join('\n') : String(lines ?? '');
}

function compactJSON(obj, maxLen=2200){
  try{
    const s = JSON.stringify(obj, (k,v)=>{
      // avoid dumping giant arrays into the debug panel
      if(Array.isArray(v) && v.length > 60){
        return {__array__: true, length: v.length, head: v.slice(0, 10), tail: v.slice(-10)};
      }
      return v;
    }, 2);
    return s.length > maxLen ? (s.slice(0, maxLen) + "\n…(truncated)…") : s;
  }catch(e){
    return `[unserializable: ${e}]`;
  }
}

function buildDebugSnapshot(extraLines=[]){
  const lines = [];
  lines.push(`Time: ${new Date().toISOString()}`);
  lines.push(`Stage: ${DEBUG_STATE.stage}${DEBUG_STATE.stageExtra ? ' — ' + DEBUG_STATE.stageExtra : ''}`);
  if(DEBUG_STATE.lastMode) lines.push(`Mode: ${DEBUG_STATE.lastMode}`);
  lines.push(`devicePixelRatio: ${devicePixelRatio}`);
  lines.push(`UserAgent: ${navigator.userAgent}`);
  // DOM sanity
  try{
    const tipEl = el('tip') || el('tooltip');
    lines.push(`TooltipEl: ${tipEl ? ('#'+tipEl.id+' .' + (tipEl.className||'')) : 'missing'}`);
    const dbg = el('dbg');
    lines.push(`DebugEl: ${dbg ? '#dbg OK' : 'missing'}`);
  }catch(_){}
  if(DEBUG_STATE.lastParams){
    lines.push('');
    lines.push('--- Params (last) ---');
    const p = DEBUG_STATE.lastParams;
    // small, human-relevant subset first
    const dtDays = (p.dt != null) ? p.dt : (DEBUG_STATE.lastSimMeta && DEBUG_STATE.lastSimMeta.dt != null ? DEBUG_STATE.lastSimMeta.dt : null);
    const dtHours = (dtDays != null && Number.isFinite(dtDays)) ? (dtDays*24) : NaN;
    lines.push(`volL=${p.volL}, days=${p.days}, dtHours≈${Number.isFinite(dtHours) ? dtHours.toFixed(2) : 'n/a'}, airFlow=${p.airFlow} L/min @ alt=${p.altM} m`);
lines.push(`surface=${p.lenCm}×${p.widCm} cm, blanket=${p.blanketPct}%, ripple=${p.ripplePct}%`);
    lines.push(`diffuser=${p.diffType || 'n/a'}, depth=${p.diffDepthCm} cm, tight=${p.tight}`);
    lines.push(`pH=${p.pH}, heaters=${p.heaters}, nitCap=${p.nitCap}, nUnits=${p.nUnits}`);
    lines.push('');
    lines.push(compactJSON(p, 1600));
  }
  if(DEBUG_STATE.lastOxy){
    lines.push('');
    lines.push('--- Oxygenation (last) ---');
    const o = DEBUG_STATE.lastOxy;
    try{
      lines.push(`C*≈${(o.Cstar!=null?Number(o.Cstar).toFixed(2):(o.Cstar_mgL!=null?Number(o.Cstar_mgL).toFixed(2):'n/a'))} mg/L; OTRmax≈${(o.OTR_max!=null?Number(o.OTR_max).toFixed(3):(o.OTR_max_g_day!=null?Number(o.OTR_max_g_day).toFixed(3):'n/a'))} g/day; kLa≈${(o.kLa!=null?Number(o.kLa).toFixed(4):'n/a')} 1/day`);
      if(o.OTR_bubble_max!=null && o.OTR_surface_max!=null){
        lines.push(`bubble≈${Number(o.OTR_bubble_max).toFixed(3)} g/day; surface≈${Number(o.OTR_surface_max).toFixed(3)} g/day`);
      }
    }catch(_){}
    lines.push(compactJSON(o, 1800));
  }
  if(DEBUG_STATE.lastSimMeta){
    lines.push('');
    lines.push('--- Sim meta (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastSimMeta, 900));
  }
  if(DEBUG_STATE.lastTagSummary){
    lines.push('');
    lines.push('--- Chemistry tags (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastTagSummary, 1200));
  }
  if(DEBUG_STATE.lastScalars){
    lines.push('');
    lines.push('--- Uncertainty scalars (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastScalars, 1200));
  }
  if(Number.isFinite(DEBUG_STATE.lastFlagsCount)){
    lines.push('');
    lines.push('--- Flags rendered (last) ---');
    lines.push(`Cards: ${DEBUG_STATE.lastFlagsCount}`);
    if(DEBUG_STATE.lastFlagsMode){
      lines.push(`Mode: ${DEBUG_STATE.lastFlagsMode}`);
    }
  }
  if(DEBUG_STATE.lastPhotoModel){
    lines.push('');
    lines.push('--- Photosynthesis model (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastPhotoModel, 900));
  }
  if(DEBUG_STATE.lastFeedProfileId){
    lines.push('');
    lines.push('--- Feed profile memory ---');
    lines.push(`Profile: ${DEBUG_STATE.lastFeedProfileId}`);
    if(DEBUG_STATE.lastFeedProfileStoredAt){
      lines.push(`Stored: ${DEBUG_STATE.lastFeedProfileStoredAt}`);
    }
  }
  if(DEBUG_STATE.lastBiomassSummary){
    lines.push('');
    lines.push('--- Biomass summary (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastBiomassSummary, 800));
  }
  if(Number.isFinite(DEBUG_STATE.lastTagSparkCount)){
    lines.push('');
    lines.push('--- Chemistry tag sparklines ---');
    lines.push(`Rendered: ${DEBUG_STATE.lastTagSparkCount}`);
  }
  if(DEBUG_STATE.lastRateBandKeys){
    lines.push('');
    lines.push('--- Uncertainty bands (rate) ---');
    lines.push(DEBUG_STATE.lastRateBandKeys.join(', '));
  }
  if(DEBUG_STATE.lastChemBandKeys){
    lines.push('');
    lines.push('--- Uncertainty bands (chem) ---');
    lines.push(DEBUG_STATE.lastChemBandKeys.join(', '));
  }
  if(Number.isFinite(DEBUG_STATE.lastOxygenClampCount)){
    lines.push('');
    lines.push('--- Oxygen saturation clamps ---');
    lines.push(`DO clamped steps: ${DEBUG_STATE.lastOxygenClampCount}`);
    if(Number.isFinite(DEBUG_STATE.lastPlantLimitedSteps)){
      lines.push(`Plant output limited steps: ${DEBUG_STATE.lastPlantLimitedSteps}`);
    }
  }
  if(DEBUG_STATE.missingContainers.length){
    lines.push('');
    lines.push('--- Missing containers (recent) ---');
    const recent = DEBUG_STATE.missingContainers.slice(-3);
    recent.forEach((m, i)=>{
      lines.push(`#${DEBUG_STATE.missingContainers.length - recent.length + i + 1} ${m.timeISO} — ${m.id} (${m.context})`);
    });
  }
  if(Number.isFinite(DEBUG_STATE.lastRecomputeMs)){
    lines.push('');
    lines.push('--- Recompute timing (last) ---');
    lines.push(`Total recompute: ${DEBUG_STATE.lastRecomputeMs.toFixed(1)} ms`);
  }
  if(DEBUG_STATE.initReadyState){
    lines.push('');
    lines.push('--- Init ---');
    lines.push(`ReadyState at init: ${DEBUG_STATE.initReadyState}`);
  }
  if(DEBUG_STATE.lastChemCumInfo){
    lines.push('');
    lines.push('--- Chemistry cumulative (last) ---');
    lines.push(compactJSON(DEBUG_STATE.lastChemCumInfo, 900));
  }
  if(extraLines && extraLines.length){
    lines.push('');
    lines.push('--- Notes ---');
    for(const l of extraLines) lines.push(String(l));
  }
  // recent errors
  if(DEBUG_STATE.errors.length){
    lines.push('');
    lines.push('--- Recent errors ---');
    const recent = DEBUG_STATE.errors.slice(-3);
    recent.forEach((e, i)=>{
      lines.push(`#${DEBUG_STATE.errors.length - recent.length + i + 1} ${e.timeISO} — ${e.name}: ${e.message}`);
      if(e.stage) lines.push(`  stage: ${e.stage}${e.stageExtra ? ' — ' + e.stageExtra : ''}`);
      if(e.stack) lines.push('  stack: ' + e.stack.split('\n').slice(0,5).join(' | '));
    });
  }
  if(DEBUG_STATE.warnings.length){
    lines.push('');
    lines.push('--- Recent warnings ---');
    const recent = DEBUG_STATE.warnings.slice(-3);
    recent.forEach((w, i)=>{
      lines.push(`#${DEBUG_STATE.warnings.length - recent.length + i + 1} ${w.timeISO} — ${w.message}`);
      if(w.stage) lines.push(`  stage: ${w.stage}${w.stageExtra ? ' — ' + w.stageExtra : ''}`);
    });
  }
  return lines;
}
function assertFinite(name, v){
  if(!Number.isFinite(v)) throw new Error(`Non-finite value for ${name}: ${v}`);
  return v;
}

function installGlobalErrorHandlers(){
  if(window.__o2planner_err_bound) return;
  window.__o2planner_err_bound = true;
  window.addEventListener('error', (event)=>{
    const err = event?.error || new Error(event?.message || 'Unknown error');
    showError(err);
  });
  window.addEventListener('unhandledrejection', (event)=>{
    const err = event?.reason instanceof Error ? event.reason : new Error(String(event?.reason || 'Unhandled rejection'));
    showError(err);
  });
}

function linkRangeAndNumber(rangeEl, numEl, onChange){
  const sync = (src, dst)=>{ dst.value = src.value; onChange(); };
  rangeEl.addEventListener("input", ()=>sync(rangeEl, numEl));
  numEl.addEventListener("input", ()=>sync(numEl, rangeEl));
}

window.addEventListener('error', (e)=>{ try{ showError(e.error || e.message || e); }catch(_){ }});
window.addEventListener('unhandledrejection', (e)=>{ try{ showError(e.reason || e); }catch(_){ }});

/* =========================================================
   Oxygenation / DO model (inference)
========================================================= */
const PHYS = {
  R: 8.314462618,     // J/mol/K
  O2_FRACTION: 0.2095,
  M_O2: 31.998,       // g/mol
  P0_kPa: 101.325
};

function pressureFromAltitude_kPa(alt_m){
  // Standard atmosphere approximation:
  // P = 101.325 * (1 - 2.25577e-5*h)^5.25588
  const h = Math.max(0, alt_m);
  const P = PHYS.P0_kPa * Math.pow(1 - 2.25577e-5*h, 5.25588);
  return clamp(P, 30, 110);
}

function doSatSeaLevel_mgL_fresh(T_C){
  // Common polynomial for freshwater DO saturation at 1 atm.
  const T = T_C;
  const sat = 14.652 - 0.41022*T + 0.007991*T*T - 0.000077774*T*T*T;
  return Math.max(0, sat);
}

function doSat_mgL(T_C, alt_m, tds_mgL){
  const P = pressureFromAltitude_kPa(alt_m);
  const sat0 = doSatSeaLevel_mgL_fresh(T_C);

  // Very light salinity-ish correction from TDS (ppt ~ g/L).
  // This is intentionally conservative/rough: you can override with calibration later.
  const sal_ppt = Math.max(0, tds_mgL/1000);
  const salFactor = clamp(1 - 0.01*sal_ppt, 0.80, 1.0); // ~1% per ppt (rough)

  const pressFactor = P / PHYS.P0_kPa;
  return sat0 * salFactor * pressFactor;
}

function oxygenMassInPumpedAir_g_per_day(airFlow_L_min, T_C, alt_m){
  // PV=nRT to convert airflow at ambient pressure into moles of gas, then oxygen mass.
  const P_kPa = pressureFromAltitude_kPa(alt_m);
  const P_Pa = P_kPa * 1000;
  const T_K = (T_C + 273.15);

  const V_m3_per_min = Math.max(0, airFlow_L_min) / 1000;
  const n_total_per_min = (P_Pa * V_m3_per_min) / (PHYS.R * T_K);
  const n_O2_per_min = n_total_per_min * PHYS.O2_FRACTION;
  const g_O2_per_min = n_O2_per_min * PHYS.M_O2;

  return g_O2_per_min * 1440;
}

function computeAreas(params){
  const L = Math.max(1e-6, params.lenCm/100);
  const W = Math.max(1e-6, params.widCm/100);
  const A_total = L * W;

  const openFrac = clamp(1 - params.blanketPct/100, 0, 1);
  const A_open = A_total * openFrac;
  const A_cov  = A_total - A_open;

  const rippleFrac = clamp(params.ripplePct/100, 0, 1);
  const A_ripple = A_total * rippleFrac;

  // Assume ripple happens mostly where bubbles are (uncovered zone), but allow overflow.
  const A_ripple_open = Math.min(A_ripple, A_open);
  const A_ripple_cov  = Math.max(0, A_ripple - A_ripple_open);

  const A_calm_open = Math.max(0, A_open - A_ripple_open);
  const A_calm_cov  = Math.max(0, A_cov  - A_ripple_cov);

  return {A_total, A_open, A_cov, A_ripple_open, A_ripple_cov, A_calm_open, A_calm_cov};
}

function computeHeadspace(params, areas){
  // Headspace height = (tank height - water surface height) + extra blanket gap above rim.
  const tankH_m = Math.max(0, params.tankHCm/100);
  const waterSurf_m = Math.max(0, params.waterSurfCm/100);
  const gap_m = Math.max(0, params.blanketGapCm/100);
  const headH_m = Math.max(0, (tankH_m - waterSurf_m) + gap_m);

  const V_head_m3 = areas.A_total * headH_m;
  const V_head_L = V_head_m3 * 1000;

  // How often the pump could replace the headspace volume, if air actually circulates.
  const turnover_min = (params.airFlow > 1e-9) ? (V_head_L / params.airFlow) : Infinity;

  return {headH_m, V_head_L, turnover_min};
}

function coverLeakFactor(params, head){
  // Blanket penalty is mostly about how well the headspace exchanges with room air.
  // Two forgiving factors:
  //   (a) pump constantly flushing the headspace (short turnover)
  //   (b) large headspace buffers composition drift (slower change)
  //
  // We fold those into an effective tightness and map it to a multiplier on surface k.

  const tight = clamp(params.tight, 0, 1);

  // If turnover is fast (<30 min), ventilation is strong → penalty shrinks.
  const ventScore = Number.isFinite(head.turnover_min)
    ? clamp(30 / Math.max(1e-6, head.turnover_min), 0, 1)
    : 0;

  // Larger headspace is more forgiving even if tight (composition changes slower).
  const Vref = 15; // L (tunable)
  const bufferScore = clamp(Vref / (Vref + Math.max(0, head.V_head_L)), 0, 1);

  const effTight = tight * (1 - ventScore) * bufferScore;

  // effTight=0 → almost no penalty
  // effTight=1 → strong penalty (nearly sealed, small headspace, poor ventilation)
  return (1 - effTight) * 0.90 + effTight * 0.05;
}

function oxygenationModel(params){
  const T = params.Tnow;
  const Cstar = doSat_mgL(T, params.altM, params.tds); // mg/L

  const areas = computeAreas(params);
  const head  = computeHeadspace(params, areas);

  // Bubble transfer:
  // O2_in_air_g_day scales with pressure (altitude) and airflow.
  const depth_m = Math.max(0, params.diffDepthCm/100);
  const sote_per_m = Math.max(0, params.sotePerM/100); // fraction per meter
  const O2_in_air_g_day = oxygenMassInPumpedAir_g_per_day(params.airFlow, T, params.altM);

  // Efficiency fraction over depth. Cap to avoid silly inputs.
  const eff_bubble = clamp(sote_per_m * depth_m * Math.max(0.05, params.otrCal), 0, 0.35);
  const OTR_bubble_max = O2_in_air_g_day * eff_bubble;

  // Surface transfer:
  // Treat k as a "film speed" (m/day). OTR_surface_max = C* (g/m^3) * k*A (m^3/day).
  // Note: mg/L == g/m^3 numerically.
  const kC = clamp(params.kCalm,   0, 10);
  const kR = clamp(params.kRipple, 0, 10);

  const leak = coverLeakFactor(params, head);

  const kA_open = kC*areas.A_calm_open + kR*areas.A_ripple_open;
  const kA_cov  = (kC*areas.A_calm_cov + kR*areas.A_ripple_cov) * leak;

  const Cstar_g_m3 = Cstar;
  const OTR_surface_max = Cstar_g_m3 * (kA_open + kA_cov);

  // Total max transfer at DO≈0.
  const OTR_max = OTR_bubble_max + OTR_surface_max;

  // Infer kLa from OTR_max = kLa * C* * V
  const volL = Math.max(1e-6, params.volL);
  const kLa = (Cstar > 1e-9) ? ((OTR_max*1000) / (Cstar * volL)) : 0; // 1/day

  return {
    T, Cstar, areas, head,
    leak, O2_in_air_g_day, eff_bubble,
    OTR_bubble_max, OTR_surface_max, OTR_max, kLa
  };
}

/* =========================================================
   Demand model (mostly carried over)
========================================================= */
const FEED_PROFILE = {
  id: 'lomas-premium-reptile-sticks',
  name: 'Store Lomas Premium Reptile Sticks',
  guaranteedAnalysis: {
    proteinMin: 0.40,
    fatMin: 0.08,
    fiberMax: 0.04,
    moistureMax: 0.10
  },
  ingredients: [
    'fish meal', 'chicken meal', 'crab meal', 'soybean meal', 'wheat flour/byproducts',
    'corn gluten', 'stabilized fish oil', 'orthophosphate',
    'vitamins (A, D3, B12, riboflavin, niacin, pantothenic acid, pyridoxine, thiamine, biotin, E, stabilized C)',
    'choline chloride',
    'minerals (selenium, manganese, zinc, copper, iodine)',
    'propionic acid', 'ethoxyquin'
  ],
  modeling: {
    proteinFraction: 0.40,
    fatFraction: 0.08,
    moistureFraction: 0.10,
    ashFraction: 0.10,
    carbFraction: 0.28,
    ashRange: [0.08, 0.12],
    carbRange: [0.26, 0.30],
    nitrogenFraction: 0.40/6.25,
    macroRelease_mgL_per_g: 8.0,
    microRelease_mgL_per_g: 1.2,
    macroUptake_mgL_per_g_photo_day: 0.6,
    microUptake_mgL_per_g_photo_day: 0.12,
    copperFractionOfMicro: 0.05
  },
  notes: 'Stored feed profile for future aquarium calculations (retailer/brand listing).'
};

const PHOTO_MODEL = {
  o2_mg_g_day_peak: 6.0,
  co2_consumption_per_gO2: 1.0,
  q10: 2.0,
  refTempC: 25,
  growth_per_day: 0.25,
  decay_per_day: 0.05,
  resp_mg_g_day: 2.0,
  co2_per_g_growth: 1.5
};

const FISH_MODEL = {
  o2_mg_g_day_base: 5.0,
  q10: 2.0,
  refTempC: 25
};

const HET_MODEL = {
  growth_per_day: 0.35,
  decay_per_day: 0.08,
  macroUptake_mgL_per_g_day: 0.18,
  microUptake_mgL_per_g_day: 0.04
};

const FRACTIONS = {
  protein: FEED_PROFILE.modeling.proteinFraction,
  fat: FEED_PROFILE.modeling.fatFraction,
  carb: FEED_PROFILE.modeling.carbFraction
};
const CHEM = {
  // g O2 per g substrate oxidized to CO2 (approx)
  O2_protein_C: 1.42,
  O2_fat: 2.90,
  O2_carb: 1.185,
  CO2_per_gO2: 1.0,
  N_bio_per_COD: 0.1,

  // crude protein nitrogen fraction
  gN_per_g_protein: 1/6.25,

  // ion conversion ratios (mg/L as ion per mg/L as N)
  NH4_ion_per_N: 18.038/14.007,
  NO2_ion_per_N: 46.0055/14.007,
  NO3_ion_per_N: 62.0049/14.007,
  NH3_ion_per_N: 17.031/14.007,

  // nitrification stoich: per g N
  // NH4+ + 1.5 O2 -> NO2- + H2O + 2H+   (48 g O2 per 14 g N)
  // NO2- + 0.5 O2 -> NO3-              (16 g O2 per 14 g N)
  O2_per_gN_NH4_to_NO2: 48/14,
  O2_per_gN_NO2_to_NO3: 16/14
};

function pelletMassEach(pelLen_cm, pelDia_cm, rho_g_cm3){
  const r = pelDia_cm/2;
  const vol = Math.PI * r*r * pelLen_cm; // cm^3
  return vol * rho_g_cm3; // g
}

function nh3Fraction(pH, tempC){
  const T = tempC + 273.15;
  const pKa = 0.09018 + (2729.92 / T);
  const frac = 1 / (1 + Math.pow(10, pKa - pH));
  return clamp(frac, 0, 1);
}

// crude "sinks over first few days"
function sinkingHazard(day){
  if(day < 1) return 0;
  if(day >= 3) return 50;
  return 1 / Math.max(3 - day, 0.05);
}

function runSimulation(params){
  // dt: keep ~1200 points for smooth plots
  const targetPts = 1200;
  let dt = params.days/targetPts;
  dt = clamp(dt, 1/48, 1/6); // between 0.5h and 4h
  const n = Math.floor(params.days/dt) + 1;

  const oxy = oxygenationModel(params);

  // temperature factor (this is for biology only, not for physics C*)
  const Q10 = 2.0;
  const bioMult = (Number.isFinite(params.bioMult) ? params.bioMult : 1.0);

  // Kinetics base (1/day). Pellets slower than powder.
  const k_h_pel = {carb:0.35, prot:0.20, fat:0.08};
  const k_ox_pel= {carb:0.65, prot:0.40, fat:0.22};
  const Y_pel   = {carb:0.30, prot:0.42, fat:0.28};
  const k_endog_pel = 0.12;
  const k_nit_pel   = {nh4:0.75, no2:1.05};

  const k_h_pow = {carb:1.10, prot:0.80, fat:0.35};
  const k_ox_pow= {carb:1.60, prot:1.05, fat:0.55};
  const Y_pow   = {carb:0.34, prot:0.46, fat:0.30};
  const k_endog_pow = 0.18;
  const k_nit_pow   = {nh4:1.20, no2:1.70};

  const accessFloat = 1.00;
  const heaterLevel = clamp(Math.round(params.heaters || 0), 0, 2);
  const accessBottom= (heaterLevel === 2) ? 0.55 : (heaterLevel === 1 ? 0.40 : 0.30);
  const oxFloat = 1.00;
  const oxBottom= (heaterLevel === 2) ? 0.75 : (heaterLevel === 1 ? 0.55 : 0.45);

  // Pools (g as-fed broken into components)
  let pelFloat = {
    carb: params.pelletMass_g * FRACTIONS.carb,
    prot: params.pelletMass_g * FRACTIONS.protein,
    fat:  params.pelletMass_g * FRACTIONS.fat
  };
  let pelBot = {carb:0, prot:0, fat:0};
  let powBot = {
    carb: params.powderMass_g * FRACTIONS.carb,
    prot: params.powderMass_g * FRACTIONS.protein,
    fat:  params.powderMass_g * FRACTIONS.fat
  };

  let S = {carb:0, prot:0, fat:0}; // soluble pool (g)
  let S_slow = {carb:0, prot:0, fat:0}; // refractory pool (g)
  let COD_bio = 0; // g O2-eq stored in heterotroph biomass
  let N_bio = 0;   // g N stored in biomass
  let NH4 = 0;     // g N
  let NO2 = 0;     // g N
  let NO3 = 0;     // g N
  let CO2_g = 0;   // g CO2 produced
  let macro_g = 0; // g (proxy)
  let micro_g = 0; // g (proxy)
  let heteroMass_g = Math.max(0, Number(params.fishMass ?? 0));
  let phytoMass_g = Math.max(0, Number(params.photoMass ?? 0));
  const heteroMass0 = heteroMass_g;
  const phytoMass0 = phytoMass_g;
  let macroConsumed_g = 0;
  let microConsumed_g = 0;
  let co2Consumed_g = 0;
  let no3Denit_g = 0;
  let oxygenClampCount = 0;
  let plantLimitedSteps = 0;

  // Activity states (dimensionless 0..1)
  let Bhet = 0.04;
  let Bnit = 0.02;
  let Bden = 0.01;

  const Ks = 0.006; // g
  const Kn = 0.0012; // g N
  const rHet_base = 2.2;
  const dHet_base = 0.12;
  const nitQ10 = Number.isFinite(params.nitQ10) ? params.nitQ10 : 2.0;
  const rNit_base = 1.2;
  const dNit_base = 0.08;
  const rDen_base = 0.9;
  const dDen_base = 0.08;

  // DO dynamics
  const Cstar = oxy.Cstar;
  let DO = clamp(Cstar * (params.doInitPct/100), 0, Cstar*1.2);
  const kLa = oxy.kLa;

  const nitCap = clamp(Number(params.nitCap ?? 1), 0, 1);
  const denitCap = clamp(Number(params.denitCap ?? 1), 0, 1);
  const kNH4_g = (Number(params.kNH4Nit ?? 0) * params.volL) / 1000;
  const kNO2_g = (Number(params.kNO2Nit ?? 0) * params.volL) / 1000;
  const kDoHet = 0; // legacy metabolism: disable heterotroph O2 limitation
  const slowFrac = 0; // legacy metabolism: no refractory split
  const biofilmMult = 1; // legacy metabolism: no biofilm diffusion penalty
  const kDenit = 0; // legacy metabolism: denitrification off
  const fishMass = Number(params.fishMass ?? 0);
  const photoMass = Number(params.photoMass ?? 0);
  const tempAmp = Number(params.tempAmp ?? 0);
  const lightHour = Number(params.lightHour ?? 0);
  const macroRelease = FEED_PROFILE.modeling.macroRelease_mgL_per_g;
  const microRelease = FEED_PROFILE.modeling.microRelease_mgL_per_g;

  // Outputs
  const out = {
    t: new Array(n),
    rate: {
      carb:new Array(n).fill(0),
      prot:new Array(n).fill(0),
      fat:new Array(n).fill(0),
      endog:new Array(n).fill(0),
      nh4:new Array(n).fill(0),
      no2:new Array(n).fill(0),
      fish:new Array(n).fill(0),
      plant:new Array(n).fill(0),
      total:new Array(n).fill(0),
      supply:new Array(n).fill(0),
    },
    cum: {},
    DO_mgL: new Array(n).fill(0),
    DO_pct: new Array(n).fill(0),
    NH4_mgL: new Array(n).fill(0),
    NO2_mgL: new Array(n).fill(0),
    NO3_mgL: new Array(n).fill(0),
    NH3_mgL: new Array(n).fill(0),
    CO2_mgL: new Array(n).fill(0),
    macro_mgL: new Array(n).fill(0),
    micro_mgL: new Array(n).fill(0),
    chem: {
      nh4: new Array(n).fill(0),
      nh3: new Array(n).fill(0),
      no2: new Array(n).fill(0),
      no3: new Array(n).fill(0),
      co2: new Array(n).fill(0),
      macro: new Array(n).fill(0),
      micro: new Array(n).fill(0),
    },
    audit: {
      nh4_from_pro:0,
      nh4_from_endog:0,
      nh4_to_no2:0,
      no2_to_no3:0,
      no3_to_n2:0,
      co2_from_ox:0,
      co2_from_endog:0,
      co2_from_denit:0,
      macro_release:0,
      macro_uptake:0,
      micro_release:0,
      micro_uptake:0,
      n_balance_init:0,
      n_balance_end:0,
      c_balance_init:0,
      c_balance_end:0
    },
    meta: {
      dt,
      oxy,
      kLa,
      nitCap,
      denitCap,
      feedProfileId: FEED_PROFILE.id,
      photoModel: {
        photoMass_g: photoMass,
        o2_mg_g_day_peak: PHOTO_MODEL.o2_mg_g_day_peak,
        growth_per_day: PHOTO_MODEL.growth_per_day,
        resp_mg_g_day: PHOTO_MODEL.resp_mg_g_day,
        macroUptake_mgL_per_g_photo_day: FEED_PROFILE.modeling.macroUptake_mgL_per_g_photo_day,
        microUptake_mgL_per_g_photo_day: FEED_PROFILE.modeling.microUptake_mgL_per_g_photo_day,
        copperFractionOfMicro: FEED_PROFILE.modeling.copperFractionOfMicro
      },
      fishModel: {
        fishMass_g: fishMass,
        o2_mg_g_day_base: FISH_MODEL.o2_mg_g_day_base,
        q10: FISH_MODEL.q10
      },
      feedStart:0,
      feedEnd:0,
      maxDemand:0,
      maxSupply:0
    }
  };
  out.biomass = {
    hetero_g: new Array(n).fill(heteroMass_g),
    phyto_g: new Array(n).fill(phytoMass_g),
    hetero_pct: new Array(n).fill(0),
    phyto_pct: new Array(n).fill(0)
  };
  out.chemProd = {
    nh4: new Array(n).fill(0),
    nh3: new Array(n).fill(0),
    no2: new Array(n).fill(0),
    no3: new Array(n).fill(0),
    co2: new Array(n).fill(0),
    macro: new Array(n).fill(0),
    micro: new Array(n).fill(0),
  };

  // Events sorted
  const ev = [...params.events]
    .filter(e=>Number.isFinite(e.day) && Number.isFinite(e.pellets) && e.pellets>0)
    .sort((a,b)=>a.day-b.day);
  let evIdx = 0;

  const mEach = pelletMassEach(params.pelLen, params.pelDia, params.pelRho);

  function blend(a,b,w){ return a*(1-w) + b*w; }

  function pelTotalComp(){
    return {
      carb: pelFloat.carb + pelBot.carb,
      prot: pelFloat.prot + pelBot.prot,
      fat:  pelFloat.fat  + pelBot.fat
    };
  }
  function removeFromPellets(compMass){
    for(const k of ["carb","prot","fat"]){
      let need = compMass[k];
      const takeF = Math.min(need, pelFloat[k]);
      pelFloat[k] -= takeF;
      need -= takeF;
      const takeB = Math.min(need, pelBot[k]);
      pelBot[k] -= takeB;
    }
  }
  function addToPowder(compMass){
    for(const k of ["carb","prot","fat"]) powBot[k] += compMass[k];
  }

  function fluxPellet(Pmass, k, access){
    // surface-limited intact pellet: ~ M^(2/3)
    return k * access * Math.pow(Math.max(Pmass,0), 2/3);
  }
  function fluxPowder(Pmass, k){
    // distributed powder: first-order
    return k * Math.max(Pmass,0);
  }
  function capFlux(flux, mass){
    if(mass <= 0) return 0;
    return Math.min(flux, mass/dt);
  }

  const initialN = params.pelletMass_g * FRACTIONS.protein * CHEM.gN_per_g_protein
    + params.powderMass_g * FRACTIONS.protein * CHEM.gN_per_g_protein;
  const initialC = params.pelletMass_g + params.powderMass_g;
  out.audit.n_balance_init = initialN;
  out.audit.c_balance_init = initialC;
  out.meta.feedStart = initialC;
  const photoO2_g_day_peak = (PHOTO_MODEL.o2_mg_g_day_peak * photoMass) / 1000;
  const macroUptakeRate_g_day = (FEED_PROFILE.modeling.macroUptake_mgL_per_g_photo_day * photoMass * params.volL) / 1000;
  const microUptakeRate_g_day = (FEED_PROFILE.modeling.microUptake_mgL_per_g_photo_day * photoMass * params.volL) / 1000;

  for(let i=0;i<n;i++){
    const day = i*dt;
    out.t[i] = day;

    const dielPhase = 2 * Math.PI * ((day + lightHour/24) % 1);
    const lightFactor = Math.max(0, Math.sin(dielPhase));
    const tempNow = oxy.T + tempAmp * Math.sin(dielPhase);
    const tempF = clamp(Math.pow(Q10, (tempNow - 25.0)/10) * bioMult, 0.25, 6.0);
    const tempFNit = Math.pow(nitQ10, (tempNow - 25.0)/10);
    const fishO2Rate = FISH_MODEL.o2_mg_g_day_base * Math.pow(FISH_MODEL.q10, (tempNow - FISH_MODEL.refTempC)/10);
    const rHet = rHet_base * tempF;
    const dHet = dHet_base * tempF;
    const rNit = rNit_base * tempFNit;
    const dNit = dNit_base * tempFNit;
    const rDen_grow = rDen_base * tempF;
    const dDen = dDen_base * tempF;

    // Apply pop events at this time slice
    while(evIdx < ev.length && ev[evIdx].day <= day + dt/2){
      const e = ev[evIdx];
      const popMass_asfed = e.pellets * mEach;
      const popComp = {
        carb: popMass_asfed * FRACTIONS.carb,
        prot: popMass_asfed * FRACTIONS.protein,
        fat:  popMass_asfed * FRACTIONS.fat
      };
      const avail = pelTotalComp();
      const availTot = avail.carb+avail.prot+avail.fat;
      const wantTot = popComp.carb+popComp.prot+popComp.fat;
      const scale = (availTot>0 && wantTot>0) ? Math.min(1.0, availTot/wantTot) : 0;
      if(scale>0){
        const capped = {carb: popComp.carb*scale, prot: popComp.prot*scale, fat: popComp.fat*scale};
        removeFromPellets(capped);
        addToPowder(capped);
      }
      evIdx++;
    }

    // Sinking
    const hz = sinkingHazard(day);
    for(const k of ["carb","prot","fat"]){
      const dM = Math.min(hz * pelFloat[k] * dt, pelFloat[k]);
      pelFloat[k] -= dM;
      pelBot[k]   += dM;
    }
    const resus = clamp((params.ripplePct/100) * 0.15 + (params.airFlow/10) * 0.02, 0, 0.25);
    for(const k of ["carb","prot","fat"]){
      const up = Math.min(resus * pelBot[k] * dt, pelBot[k]);
      pelBot[k] -= up;
      pelFloat[k] += up;
    }

    // Blend kinetics based on how much is in powder state
    const pelMassNow = pelFloat.carb+pelFloat.prot+pelFloat.fat + pelBot.carb+pelBot.prot+pelBot.fat;
    const powMassNow = powBot.carb+powBot.prot+powBot.fat;
    const wPow = (pelMassNow + powMassNow) > 0 ? (powMassNow/(pelMassNow+powMassNow)) : 0;

    // Blend oxidation coefficients and yields
    const k_ox = {
      carb: tempF * blend(k_ox_pel.carb, k_ox_pow.carb, wPow),
      prot: tempF * blend(k_ox_pel.prot, k_ox_pow.prot, wPow),
      fat:  tempF * blend(k_ox_pel.fat,  k_ox_pow.fat,  wPow)
    };
    const Y = {
      carb: blend(Y_pel.carb, Y_pow.carb, wPow),
      prot: blend(Y_pel.prot, Y_pow.prot, wPow),
      fat:  blend(Y_pel.fat,  Y_pow.fat,  wPow)
    };
    const k_endog = tempF * blend(k_endog_pel, k_endog_pow, wPow);
    const k_nit_base = {
      nh4: tempFNit * blend(k_nit_pel.nh4, k_nit_pow.nh4, wPow),
      no2: tempFNit * blend(k_nit_pel.no2, k_nit_pow.no2, wPow)
    };

    // Optionally slow nitrification at low DO (a simple Monod term).
    let nitO2Mult = 1.0;
    if(params.o2Limit === "on"){
      const K = Math.max(1e-6, params.kDoNit);
      nitO2Mult = DO / (K + DO);
    }
    const k_nit = { nh4: k_nit_base.nh4 * nitO2Mult, no2: k_nit_base.no2 * nitO2Mult };

    // Hydrolysis coefficients
    const k_h_p = {
      carb: tempF * k_h_pel.carb,
      prot: tempF * k_h_pel.prot,
      fat:  tempF * k_h_pel.fat
    };
    const k_h_w = {
      carb: tempF * k_h_pow.carb,
      prot: tempF * k_h_pow.prot,
      fat:  tempF * k_h_pow.fat
    };

    let hydroTot = 0;
    // Hydrolysis fluxes per component
    for(const k of ["carb","prot","fat"]){
      const hf = capFlux(fluxPellet(pelFloat[k], k_h_p[k], accessFloat), pelFloat[k]);
      const hb = capFlux(fluxPellet(pelBot[k],   k_h_p[k], accessBottom), pelBot[k]);
      const hw = capFlux(fluxPowder(powBot[k],   k_h_w[k]), powBot[k]);

      pelFloat[k] -= hf*dt;
      pelBot[k]   -= hb*dt;
      powBot[k]   -= hw*dt;

      const fast = (hf+hb+hw) * (1 - slowFrac) * dt;
      const slow = (hf+hb+hw) * slowFrac * dt;
      S[k] += fast;
      S_slow[k] += slow;
      hydroTot += (hf+hb+hw)*dt;
    }

    for(const k of ["carb","prot","fat"]){
      const rel = Math.min(S_slow[k], (0.08 * tempF) * S_slow[k] * dt);
      S_slow[k] -= rel;
      S[k] += rel;
    }

    // Mixing penalty when hydrolysis happens mostly in bottom pellets
    const hPelFloat = fluxPellet(pelFloat.carb,k_h_p.carb,accessFloat)+fluxPellet(pelFloat.prot,k_h_p.prot,accessFloat)+fluxPellet(pelFloat.fat,k_h_p.fat,accessFloat);
    const hPelBot   = fluxPellet(pelBot.carb,k_h_p.carb,accessBottom)+fluxPellet(pelBot.prot,k_h_p.prot,accessBottom)+fluxPellet(pelBot.fat,k_h_p.fat,accessBottom);
    const hPow      = fluxPowder(powBot.carb,k_h_w.carb)+fluxPowder(powBot.prot,k_h_w.prot)+fluxPowder(powBot.fat,k_h_w.fat);
    const denom = (hPelFloat+hPelBot+hPow) + 1e-12;
    const mixMult = (oxFloat*hPelFloat + oxBottom*hPelBot + 1.0*hPow) / denom;

    // Nutrient release from hydrolyzed food (macro/micro proxy)
    const macroAdd_g = (macroRelease * hydroTot * params.volL) / 1000;
    const microAdd_g = (microRelease * hydroTot * params.volL) / 1000;
    macro_g += macroAdd_g;
    micro_g += microAdd_g;
    out.audit.macro_release += macroAdd_g;
    out.audit.micro_release += microAdd_g;

    // Biomass growth + nutrient consumption
    const S_tot = S.carb + S.prot + S.fat;
    const nutrientPool = macro_g + micro_g;
    const foodIndex = clamp((S_tot + nutrientPool * 0.3) / (S_tot + nutrientPool * 0.3 + 0.25), 0, 1);
    const phytoNutrientIndex = clamp(nutrientPool / (nutrientPool + 0.35), 0, 1);
    const co2Index = clamp(CO2_g / (CO2_g + 0.2), 0, 1);

    const heteroGrowth = heteroMass_g * HET_MODEL.growth_per_day * foodIndex * tempF * dt;
    const heteroDecay = heteroMass_g * HET_MODEL.decay_per_day * (1 - foodIndex) * dt;
    heteroMass_g = Math.max(0, heteroMass_g + heteroGrowth - heteroDecay);

    const phytoGrowth = phytoMass_g * PHOTO_MODEL.growth_per_day * lightFactor * phytoNutrientIndex * co2Index * dt;
    const phytoDecay = phytoMass_g * PHOTO_MODEL.decay_per_day * (1 - lightFactor) * dt;
    phytoMass_g = Math.max(0, phytoMass_g + phytoGrowth - phytoDecay);

    const heteroMacroUptake_g = Math.min(macro_g, (HET_MODEL.macroUptake_mgL_per_g_day * heteroMass_g * params.volL / 1000) * foodIndex * dt);
    const heteroMicroUptake_g = Math.min(micro_g, (HET_MODEL.microUptake_mgL_per_g_day * heteroMass_g * params.volL / 1000) * foodIndex * dt);
    macro_g = Math.max(0, macro_g - heteroMacroUptake_g);
    micro_g = Math.max(0, micro_g - heteroMicroUptake_g);
    macroConsumed_g += heteroMacroUptake_g;
    microConsumed_g += heteroMicroUptake_g;
    out.audit.macro_uptake += heteroMacroUptake_g;
    out.audit.micro_uptake += heteroMicroUptake_g;

    const phytoMacroUptake_g = Math.min(macro_g, (FEED_PROFILE.modeling.macroUptake_mgL_per_g_photo_day * phytoMass_g * params.volL / 1000) * lightFactor * phytoNutrientIndex * dt);
    const phytoMicroUptake_g = Math.min(micro_g, (FEED_PROFILE.modeling.microUptake_mgL_per_g_photo_day * phytoMass_g * params.volL / 1000) * lightFactor * phytoNutrientIndex * dt);
    macro_g = Math.max(0, macro_g - phytoMacroUptake_g);
    micro_g = Math.max(0, micro_g - phytoMicroUptake_g);
    macroConsumed_g += phytoMacroUptake_g;
    microConsumed_g += phytoMicroUptake_g;
    out.audit.macro_uptake += phytoMacroUptake_g;
    out.audit.micro_uptake += phytoMicroUptake_g;

    const co2GrowthCons_g = phytoGrowth * PHOTO_MODEL.co2_per_g_growth;
    CO2_g = Math.max(0, CO2_g - co2GrowthCons_g);
    co2Consumed_g += co2GrowthCons_g;

    // Oxidation of solubles
    const ox = {carb:0, prot:0, fat:0};
    for(const k of ["carb","prot","fat"]){
      const Ks_sub = 0.02;
      const fS = S[k] / (Ks_sub + S[k]);
      const fO2 = DO / (kDoHet + DO);
      const flux = k_ox[k] * Bhet * mixMult * fS * fO2 * S[k];
      ox[k] = Math.min(flux, S[k]/dt);
      S[k] -= ox[k]*dt;
    }

    // Oxygen demand (rates)
    const O2_carb = ox.carb * CHEM.O2_carb * (1 - Y.carb);
    const O2_prot = ox.prot * CHEM.O2_protein_C * (1 - Y.prot);
    const O2_fat  = ox.fat  * CHEM.O2_fat * (1 - Y.fat);

    // Biomass storage and endogenous respiration
    const COD_store = ox.carb*CHEM.O2_carb*Y.carb + ox.prot*CHEM.O2_protein_C*Y.prot + ox.fat*CHEM.O2_fat*Y.fat;
    const N_store   = ox.prot * CHEM.gN_per_g_protein * Y.prot;
    const NH4_prod  = ox.prot * CHEM.gN_per_g_protein * (1 - Y.prot);

    const endog = Math.min(k_endog * COD_bio, COD_bio/dt);
    const O2_endog = endog;
    const N_rel = (COD_bio > 1e-12) ? (N_bio / COD_bio) * endog : 0;

    COD_bio = COD_bio + COD_store*dt - endog*dt;
    const N_need = COD_store * CHEM.N_bio_per_COD;
    const N_assim = Math.min(NH4, Math.max(0, N_need - N_store) * dt);
    NH4 = NH4 - N_assim;
    N_bio   = N_bio   + N_store*dt + N_assim - N_rel*dt;

    // Nitrification (sequential)
    NH4 = NH4 + (NH4_prod + N_rel)*dt;

    const fNH4 = (kNH4_g > 0) ? (NH4 / (kNH4_g + NH4)) : 1.0;
    const fNO2 = (kNO2_g > 0) ? (NO2 / (kNO2_g + NO2)) : 1.0;

    const r1 = Math.min(Bnit * k_nit.nh4 * fNH4 * biofilmMult * NH4, NH4/dt); // g N/day
    NH4 = NH4 - r1*dt;
    NO2 = NO2 + r1*dt;

    const r2 = Math.min(Bnit * k_nit.no2 * fNO2 * biofilmMult * NO2, NO2/dt);
    NO2 = NO2 - r2*dt;
    NO3 = NO3 + r2*dt;

    const O2_nh4 = r1 * CHEM.O2_per_gN_NH4_to_NO2;
    const O2_no2 = r2 * CHEM.O2_per_gN_NO2_to_NO3;

    const fAnox = clamp(1 - DO/(kDoHet + DO), 0, 1);
    const rDen_flux = Math.min(Bden * kDenit * fAnox * NO3, NO3/dt);
    NO3 = NO3 - rDen_flux*dt;
    no3Denit_g += rDen_flux * dt;
    const COD_den = Math.min(COD_bio, rDen_flux * 2.5);
    COD_bio = Math.max(0, COD_bio - COD_den*dt);
    const CO2_den = COD_den;
    CO2_g += CO2_den * dt;
    out.audit.no3_to_n2 += rDen_flux * dt;
    out.audit.co2_from_denit += CO2_den * dt;

    const phytoResp_g_day = (PHOTO_MODEL.resp_mg_g_day * phytoMass_g / 1000) * (1 - lightFactor);
    const demand = O2_carb + O2_prot + O2_fat + O2_endog + O2_nh4 + O2_no2 + phytoResp_g_day;

    const CO2_from_ox = (O2_carb + O2_prot + O2_fat) * CHEM.CO2_per_gO2;
    const CO2_from_endog = O2_endog * CHEM.CO2_per_gO2;
    CO2_g += (CO2_from_ox + CO2_from_endog + phytoResp_g_day * CHEM.CO2_per_gO2) * dt;
    out.audit.co2_from_ox += CO2_from_ox * dt;
    out.audit.co2_from_endog += CO2_from_endog * dt;

    out.audit.nh4_from_pro += NH4_prod * dt;
    out.audit.nh4_from_endog += N_rel * dt;
    out.audit.nh4_to_no2 += r1 * dt;
    out.audit.no2_to_no3 += r2 * dt;

    // DO dynamics (Euler)
    // supply_g_day = kLa*(C* - DO)*V
    const satDef = Math.max(0, (Cstar - DO));
    const satFrac = (Cstar > 1e-9) ? clamp(satDef / Cstar, 0, 1) : 0;
    const supply_g_day = (kLa * satDef * params.volL) / 1000;
    const photoO2_g_day_peak = (PHOTO_MODEL.o2_mg_g_day_peak * phytoMass_g) / 1000;
    const plant_g_day = photoO2_g_day_peak * lightFactor * satFrac;
    if(plant_g_day < (photoO2_g_day_peak * lightFactor) && lightFactor > 0) plantLimitedSteps++;
    const fish_g_day = (heteroMass_g * fishO2Rate) / 1000;
    const dDO = ((supply_g_day + plant_g_day - demand - fish_g_day) * 1000 / params.volL) * dt; // mg/L
    DO = clamp(DO + dDO, 0, Cstar);
    if(DO >= Cstar - 1e-6) oxygenClampCount++;

    // Record outputs
    out.rate.carb[i]  = O2_carb;
    out.rate.prot[i]  = O2_prot;
    out.rate.fat[i]   = O2_fat;
    out.rate.endog[i] = O2_endog;
    out.rate.nh4[i]   = O2_nh4;
    out.rate.no2[i]   = O2_no2;
    out.rate.fish[i]  = fish_g_day;
    out.rate.plant[i] = plant_g_day;
    out.rate.total[i] = demand + fish_g_day;
    out.rate.supply[i]= supply_g_day + plant_g_day;
    out.meta.maxDemand = Math.max(out.meta.maxDemand, out.rate.total[i]);
    out.meta.maxSupply = Math.max(out.meta.maxSupply, out.rate.supply[i]);

    out.DO_mgL[i] = DO;
    out.DO_pct[i] = (Cstar>1e-9) ? (100*DO/Cstar) : 0;

    out.NH4_mgL[i] = (NH4*1000)/params.volL;
    out.NO2_mgL[i] = (NO2*1000)/params.volL;
    out.NO3_mgL[i] = (NO3*1000)/params.volL;

    const nh3Frac = nh3Fraction(params.pH ?? 7.0, oxy.T);
    const nh3AsN = out.NH4_mgL[i] * nh3Frac;
    out.NH3_mgL[i] = nh3AsN * CHEM.NH3_ion_per_N;

    const co2PhotoCons_g = plant_g_day * CHEM.CO2_per_gO2 * dt;
    CO2_g = Math.max(0, CO2_g - co2PhotoCons_g);
    co2Consumed_g += co2PhotoCons_g;
    out.CO2_mgL[i] = (CO2_g*1000)/params.volL;

    out.macro_mgL[i] = (macro_g*1000)/params.volL;
    out.micro_mgL[i] = (micro_g*1000)/params.volL;

    const nh4Disp = params.nUnits === 'asIon' ? out.NH4_mgL[i] * CHEM.NH4_ion_per_N : out.NH4_mgL[i];
    const no2Disp = params.nUnits === 'asIon' ? out.NO2_mgL[i] * CHEM.NO2_ion_per_N : out.NO2_mgL[i];
    const no3Disp = params.nUnits === 'asIon' ? out.NO3_mgL[i] * CHEM.NO3_ion_per_N : out.NO3_mgL[i];

    out.chem.nh4[i] = nh4Disp;
    out.chem.no2[i] = no2Disp;
    out.chem.no3[i] = no3Disp;
    out.chem.nh3[i] = out.NH3_mgL[i];
    out.chem.co2[i] = out.CO2_mgL[i];
    out.chem.macro[i] = out.macro_mgL[i];
    out.chem.micro[i] = out.micro_mgL[i];

    const no3Prod_g = NO3 + no3Denit_g;
    const no3ProdDisp = params.nUnits === 'asIon' ? (no3Prod_g*1000/params.volL) * CHEM.NO3_ion_per_N : (no3Prod_g*1000/params.volL);
    out.chemProd.nh4[i] = nh4Disp;
    out.chemProd.no2[i] = no2Disp;
    out.chemProd.no3[i] = no3ProdDisp;
    out.chemProd.nh3[i] = out.NH3_mgL[i];
    out.chemProd.co2[i] = ((CO2_g + co2Consumed_g) * 1000) / params.volL;
    out.chemProd.macro[i] = ((macro_g + macroConsumed_g) * 1000) / params.volL;
    out.chemProd.micro[i] = ((micro_g + microConsumed_g) * 1000) / params.volL;

    out.biomass.hetero_g[i] = heteroMass_g;
    out.biomass.phyto_g[i] = phytoMass_g;
    out.biomass.hetero_pct[i] = heteroMass0 > 0 ? ((heteroMass_g - heteroMass0) / heteroMass0) * 100 : 0;
    out.biomass.phyto_pct[i] = phytoMass0 > 0 ? ((phytoMass_g - phytoMass0) / phytoMass0) * 100 : 0;

    // Update activity states
    const fS = S_tot / (Ks + S_tot);
    const fN = NH4 / (Kn + NH4);

    Bhet = clamp(Bhet + (rHet*fS*(1-Bhet) - dHet*Bhet)*dt, 0.0, 1.0);
    Bnit = clamp(Bnit + (rNit*fN*(nitCap-Bnit) - dNit*Bnit)*dt, 0.0, nitCap);
    const fDen = NO3 / (Kn + NO3);
    Bden = clamp(Bden + (rDen_grow*fDen*(denitCap-Bden) - dDen*Bden)*dt, 0.0, denitCap);
  }

  // cumulative arrays
  out.cum = {};
  for(const k of Object.keys(out.rate)){
    const arr = out.rate[k];
    const cum = new Array(n).fill(0);
    let s = 0;
    for(let i=0;i<n;i++){ s += arr[i]*dt; cum[i] = s; }
    out.cum[k] = cum;
  }
  const chemCumResult = buildCumulativeSeries(out.chem, dt);
  out.chemCum = chemCumResult.series;
  out.meta.chemCumInfo = chemCumResult.info;
  const chemProdCumResult = buildCumulativeSeries(out.chemProd, dt);
  out.chemProdCum = chemProdCumResult.series;
  out.meta.chemProdCumInfo = chemProdCumResult.info;

  out.audit.n_balance_end = NH4 + NO2 + NO3 + N_bio;
  out.audit.c_balance_end = CO2_g + COD_bio + S.carb + S.prot + S.fat + S_slow.carb + S_slow.prot + S_slow.fat
    + pelFloat.carb + pelFloat.prot + pelFloat.fat + pelBot.carb + pelBot.prot + pelBot.fat + powBot.carb + powBot.prot + powBot.fat;
  out.meta.feedEnd = pelFloat.carb + pelFloat.prot + pelFloat.fat + pelBot.carb + pelBot.prot + pelBot.fat + powBot.carb + powBot.prot + powBot.fat;
  out.meta.oxygenClampCount = oxygenClampCount;
  out.meta.plantLimitedSteps = plantLimitedSteps;
  if(initialN > 0 && Math.abs(out.audit.n_balance_end - initialN)/initialN > 0.15){
    addWarning('Nitrogen balance drift exceeds 15% — check kinetics or timestep.');
  }
  if(initialC > 0 && Math.abs(out.audit.c_balance_end - initialC)/initialC > 0.25){
    addWarning('Carbon balance drift exceeds 25% — check hydrolysis/CO2 terms.');
  }

  return out;
}
/* =========================================================
   Uncertainty mode (Monte Carlo)
========================================================= */

// Small PRNG so “seed” is reproducible across browsers.
function mulberry32(seed){
  let a = seed >>> 0;
  return function(){
    a |= 0; a = (a + 0x6D2B79F5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function randn(rng){
  // Box–Muller
  let u = 0, v = 0;
  while(u === 0) u = rng();
  while(v === 0) v = rng();
  return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}

function sampleLogNormalMean1(rng, cv){
  // lognormal with mean=1 and desired coefficient of variation
  const sigma = Math.sqrt(Math.log(1 + cv*cv));
  const mu = -0.5 * sigma * sigma;
  return Math.exp(mu + sigma * randn(rng));
}

function bandToQuantiles(bandPreset){
  if(bandPreset === '25-75') return {qLo:0.25, qHi:0.75};
  if(bandPreset === '5-95')  return {qLo:0.05, qHi:0.95};
  return {qLo:0.10, qHi:0.90}; // default 10–90
}

function profileForLevel(level){
  // These are “priors”: intentionally conservative. With calibration, shrink these.
  if(level === 'tight'){
    return {cvFlow:0.07, cvSote:0.12, cvSurf:0.18, cvBio:0.18, sdTemp:0.35, sdTight:0.10, cvInit:0.06};
  }
  if(level === 'wide'){
    return {cvFlow:0.25, cvSote:0.55, cvSurf:0.70, cvBio:0.70, sdTemp:1.20, sdTight:0.35, cvInit:0.18};
  }
  return {cvFlow:0.14, cvSote:0.30, cvSurf:0.35, cvBio:0.35, sdTemp:0.70, sdTight:0.20, cvInit:0.10}; // typical
}

function meanDeliveryFactor(diffType){
  // Rated pump flow is often higher than delivered flow once you add depth + diffuser backpressure.
  // This is a gentle, realism-biased default. Uncertainty adds noise around it.
  if(diffType === 'wood') return 0.65;
  if(diffType === 'microbubble') return 0.70;
  if(diffType === 'airstone_fine') return 0.80;
  return 0.90; // airstone_med or custom
}

function quantileFromSorted(sorted, q){
  if(sorted.length === 0) return NaN;
  const x = q * (sorted.length - 1);
  const i0 = Math.floor(x);
  const i1 = Math.min(sorted.length - 1, i0 + 1);
  const t = x - i0;
  return sorted[i0] * (1 - t) + sorted[i1] * t;
}

function scalarStats(values, qLo, qHi){
  const arr = values.slice().sort((a,b)=>a-b);
  return {
    lo: quantileFromSorted(arr, qLo),
    mid: quantileFromSorted(arr, 0.5),
    hi: quantileFromSorted(arr, qHi)
  };
}

function runMonteCarlo(baseParams){
  const runs = clamp(Math.round(baseParams.mcRuns || 0), 10, 5000);
  const {qLo, qHi} = bandToQuantiles(baseParams.bandPreset);
  const prof = profileForLevel(baseParams.uncLevel);
  const rng = mulberry32((Number.isFinite(baseParams.seed) ? baseParams.seed : 12345) | 0);

  // Keep time grid consistent for all runs by using base dt (as implemented inside runSimulation).
  // (runSimulation derives dt only from days.)
  const baseSim = runSimulation(baseParams);
  const n = baseSim.t.length;

  // Store per-run arrays we care about
  const DO_runs = new Array(runs);
  const rate_runs = Object.fromEntries(RATE_SERIES.map(s=>[s.key, new Array(runs)]));
  const cum_runs = new Array(runs);
  const chem_runs = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, new Array(runs)]));
  const chem_prod_runs = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, new Array(runs)]));
  const chem_cum_runs = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, new Array(runs)]));
  const bio_runs = {
    hetero_g: new Array(runs),
    phyto_g: new Array(runs),
    hetero_pct: new Array(runs),
    phyto_pct: new Array(runs)
  };

  // Per-run scalars
  const minDO = new Array(runs);
  const minDO_day = new Array(runs);
  const under2 = new Array(runs);
  const under1 = new Array(runs);
  const deficitArea = new Array(runs);
  const nh4pk = new Array(runs);
  const no2pk = new Array(runs);
  const no3pk = new Array(runs);
  const nh3pk = new Array(runs);
  const co2pk = new Array(runs);
  const macroPk = new Array(runs);
  const microPk = new Array(runs);
  const otrMax = new Array(runs);
  const kLa = new Array(runs);
  const Cstar = new Array(runs);
  const effFlow = new Array(runs);

  for(let r=0;r<runs;r++){
    const p = JSON.parse(JSON.stringify(baseParams)); // cheap clone; fine at these sizes

    // Sample uncertainties around the base choices
    if(baseParams.u && baseParams.u.temp){
      p.Tnow = p.Tnow + randn(rng) * prof.sdTemp;
    }

    if(baseParams.u && baseParams.u.initDO){
      p.doInitPct = clamp(p.doInitPct * sampleLogNormalMean1(rng, prof.cvInit), 10, 150);
    }

    if(baseParams.u && baseParams.u.tight){
      p.tight = clamp(p.tight + randn(rng) * prof.sdTight, 0, 1);
    }

    // Delivered flow: treat user-entered flow as “rated-ish”, then sample delivery factor.
    if(baseParams.u && baseParams.u.air){
      const mean = meanDeliveryFactor(p.diffType);
      const mult = sampleLogNormalMean1(rng, prof.cvFlow);
      p.airFlow = clamp(p.airFlow * mean * mult, 0.05, 50);
      effFlow[r] = p.airFlow;
    }else{
      effFlow[r] = p.airFlow;
    }

    if(baseParams.u && baseParams.u.diff){
      p.sotePerM = clamp(p.sotePerM * sampleLogNormalMean1(rng, prof.cvSote), 0.1, 25);
    }

    if(baseParams.u && baseParams.u.surf){
      const m = sampleLogNormalMean1(rng, prof.cvSurf);
      const m2 = sampleLogNormalMean1(rng, prof.cvSurf * 0.35);
      p.kCalm = clamp(p.kCalm * m, 0.01, 6.0);
      p.kRipple = clamp(p.kRipple * m * m2, 0.01, 10.0);
    }

    if(baseParams.u && baseParams.u.bio){
      p.bioMult = clamp(sampleLogNormalMean1(rng, prof.cvBio), 0.1, 6.0);
    }else{
      p.bioMult = 1.0;
    }

    const sim = runSimulation(p);
    DO_runs[r]  = sim.DO_mgL;
    for(const s of RATE_SERIES){
      rate_runs[s.key][r] = sim.rate[s.key];
    }
    cum_runs[r] = sim.cum.total;
    for(const s of CHEM_SERIES){
      chem_runs[s.key][r] = sim.chem[s.key];
      chem_prod_runs[s.key][r] = sim.chemProd[s.key];
      chem_cum_runs[s.key][r] = sim.chemProdCum[s.key];
    }
    bio_runs.hetero_g[r] = sim.biomass.hetero_g;
    bio_runs.phyto_g[r] = sim.biomass.phyto_g;
    bio_runs.hetero_pct[r] = sim.biomass.hetero_pct;
    bio_runs.phyto_pct[r] = sim.biomass.phyto_pct;

    // scalars
    let dmin = Infinity, dminDay = 0;
    let tU2 = 0, tU1 = 0;
    let defA = 0;
    for(let i=0;i<n;i++){
      const d = sim.DO_mgL[i];
      if(d < dmin){ dmin = d; dminDay = sim.t[i]; }
      if(d < 2.0) tU2 += sim.meta.dt;
      if(d < 1.0) tU1 += sim.meta.dt;
      const def = sim.rate.total[i] - sim.rate.supply[i];
      if(def > 0) defA += def * sim.meta.dt; // g/day * day = g
    }
    minDO[r] = dmin;
    minDO_day[r] = dminDay;
    under2[r] = tU2;
    under1[r] = tU1;
    deficitArea[r] = defA;

    let nh = 0, n2 = 0, n3 = 0, nh3 = 0, co2 = 0, mA = 0, mI = 0;
    for(let i=0;i<sim.NH4_mgL.length;i++) if(sim.NH4_mgL[i] > nh) nh = sim.NH4_mgL[i];
    for(let i=0;i<sim.NO2_mgL.length;i++) if(sim.NO2_mgL[i] > n2) n2 = sim.NO2_mgL[i];
    for(let i=0;i<sim.NO3_mgL.length;i++) if(sim.NO3_mgL[i] > n3) n3 = sim.NO3_mgL[i];
    for(let i=0;i<sim.NH3_mgL.length;i++) if(sim.NH3_mgL[i] > nh3) nh3 = sim.NH3_mgL[i];
    for(let i=0;i<sim.CO2_mgL.length;i++) if(sim.CO2_mgL[i] > co2) co2 = sim.CO2_mgL[i];
    for(let i=0;i<sim.macro_mgL.length;i++) if(sim.macro_mgL[i] > mA) mA = sim.macro_mgL[i];
    for(let i=0;i<sim.micro_mgL.length;i++) if(sim.micro_mgL[i] > mI) mI = sim.micro_mgL[i];
    nh4pk[r] = nh;
    no2pk[r] = n2;
    no3pk[r] = n3;
    nh3pk[r] = nh3;
    co2pk[r] = co2;
    macroPk[r] = mA;
    microPk[r] = mI;

    otrMax[r] = sim.meta.oxy.OTR_max;
    kLa[r] = sim.meta.oxy.kLa;
    Cstar[r] = sim.meta.oxy.Cstar;
  }

  // Quantile arrays (time series)
  const qDO = {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)};
  const qRate = Object.fromEntries(RATE_SERIES.map(s=>[s.key, {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}]));
  const qCum= {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)};
  const qChem = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}]));
  const qChemProd = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}]));
  const qChemCum = Object.fromEntries(CHEM_SERIES.map(s=>[s.key, {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}]));
  const qBio = {
    hetero_g: {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)},
    phyto_g: {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}
  };
  const qBioPct = {
    hetero_pct: {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)},
    phyto_pct: {lo:new Float32Array(n), mid:new Float32Array(n), hi:new Float32Array(n)}
  };

  const tmp = new Array(runs);

  function fillQ(srcRuns, out){
    for(let i=0;i<n;i++){
      for(let r=0;r<runs;r++) tmp[r] = srcRuns[r][i];
      tmp.sort((a,b)=>a-b);
      out.lo[i]  = quantileFromSorted(tmp, qLo);
      out.mid[i] = quantileFromSorted(tmp, 0.5);
      out.hi[i]  = quantileFromSorted(tmp, qHi);
    }
  }

  fillQ(DO_runs, qDO);
  for(const s of RATE_SERIES){
    fillQ(rate_runs[s.key], qRate[s.key]);
  }
  fillQ(cum_runs, qCum);
  for(const s of CHEM_SERIES){
    fillQ(chem_runs[s.key], qChem[s.key]);
    fillQ(chem_prod_runs[s.key], qChemProd[s.key]);
    fillQ(chem_cum_runs[s.key], qChemCum[s.key]);
  }
  fillQ(bio_runs.hetero_g, qBio.hetero_g);
  fillQ(bio_runs.phyto_g, qBio.phyto_g);
  fillQ(bio_runs.hetero_pct, qBioPct.hetero_pct);
  fillQ(bio_runs.phyto_pct, qBioPct.phyto_pct);

  // Scalar bands
  const sMinDO = scalarStats(minDO, qLo, qHi);
  const sMinDODay = scalarStats(minDO_day, qLo, qHi);
  const sDefA  = scalarStats(deficitArea, qLo, qHi);
  const sNH4   = scalarStats(nh4pk, qLo, qHi);
  const sNO2   = scalarStats(no2pk, qLo, qHi);
  const sNO3   = scalarStats(no3pk, qLo, qHi);
  const sNH3   = scalarStats(nh3pk, qLo, qHi);
  const sCO2   = scalarStats(co2pk, qLo, qHi);
  const sMacro = scalarStats(macroPk, qLo, qHi);
  const sMicro = scalarStats(microPk, qLo, qHi);
  const sOTR   = scalarStats(otrMax, qLo, qHi);
  const sKLA   = scalarStats(kLa, qLo, qHi);
  const sCstar = scalarStats(Cstar, qLo, qHi);

  // Probabilities (based on min DO)
  let pU2 = 0, pU1 = 0;
  for(let r=0;r<runs;r++){
    if(minDO[r] < 2.0) pU2++;
    if(minDO[r] < 1.0) pU1++;
  }
  pU2 /= runs; pU1 /= runs;

  return {
    baseSim,
    q: {
      DO:qDO,
      rateBands:qRate,
      rateTotal:qRate.total,
      rateSupply:qRate.supply,
      cumTotal:qCum,
      chemBands:qChem,
      chemProdBands:qChemProd,
      chemCumBands:qChemCum,
      bioBands:qBio,
      bioPctBands:qBioPct
    },
    scalars: {
      minDO:sMinDO,
      minDO_day:sMinDODay,
      deficitArea:sDefA,
      nh4pk:sNH4,
      no2pk:sNO2,
      no3pk:sNO3,
      nh3pk:sNH3,
      co2pk:sCO2,
      macroPk:sMacro,
      microPk:sMicro,
      otrMax:sOTR,
      kLa:sKLA,
      Cstar:sCstar,
      runs
    },
    probs: {anyUnder2:pU2, anyUnder1:pU1}
  };
}


/* =========================================================
   Plotting (canvas)
========================================================= */


// ---- Chart scaling helpers (avoid “mystery math”, just readable axes) ----
// niceTop(yMax): round the plot ceiling to 1/2/5 * 10^n
function niceTop(max){
  max = Math.max(0, max);
  if(max === 0) return 1;
  const p = Math.pow(10, Math.floor(Math.log10(max)));
  const n = max / p;
  let top;
  if(n <= 1) top = 1;
  else if(n <= 2) top = 2;
  else if(n <= 5) top = 5;
  else top = 10;
  return top * p;
}
// niceStep(yTop): choose a “pleasant” grid step for ~4–6 lines
function niceStep(top){
  top = Math.max(0, top);
  if(top === 0) return 1;
  const raw = top / 5;
  const p = Math.pow(10, Math.floor(Math.log10(raw)));
  const n = raw / p;
  let step;
  if(n < 1.5) step = 1 * p;
  else if(n < 3) step = 2 * p;
  else if(n < 7) step = 5 * p;
  else step = 10 * p;
  return step;
}

// niceXStep(xMax): choose a pleasant x-grid step (days) for ~5–7 vertical lines.
function niceXStep(xMax){
  xMax = Math.max(1e-9, xMax);
  const targetLines = 6;
  const raw = xMax / targetLines;
  const p = Math.pow(10, Math.floor(Math.log10(raw)));
  const n = raw / p;
  let step;
  if(n < 1.5) step = 1 * p;
  else if(n < 3) step = 2 * p;
  else if(n < 7) step = 5 * p;
  else step = 10 * p;
  // Avoid “0” step and keep labels sensible for short runs
  if(step <= 0) step = xMax;
  // If the run is very short, allow half-day ticks
  if(xMax <= 5 && step > 1) step = 1;
  if(xMax <= 2 && step > 0.5) step = 0.5;
  return step;
}

function drawPlot(canvas, tArr, seriesDict, opts={}){
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const m = {l:56*devicePixelRatio, r:56*devicePixelRatio, t:30*devicePixelRatio, b:34*devicePixelRatio};
  const pw = w - m.l - m.r;
  const ph = h - m.t - m.b;

  const xMax = tArr[tArr.length-1] || 1;

  const seriesList = opts.series || RATE_SERIES;
  const visibleMap = opts.visible || visibleRate;

  // y max from visible series + optional bands
  let yMax = 0;
  for(const s of seriesList){
    if(!visibleMap[s.key]) continue;
    const arr = seriesDict[s.key];
    if(arr) for(const v of arr) if(v>yMax) yMax=v;
  }
  if(opts.bands){
    for(const key of Object.keys(opts.bands)){
      if(visibleMap[key] === false) continue;
      const b = opts.bands[key];
      if(b && b.hi){
        for(let i=0;i<b.hi.length;i++){
          const v = b.hi[i];
          if(v>yMax) yMax=v;
        }
      }
    }
  }
  yMax = Math.max(0.0001, yMax);
  const yTop = opts.fitYMax ? yMax : niceTop(yMax);
  const yStep = niceStep(yTop);
  const fmtAxis = (val)=>{
    const abs = Math.abs(val);
    if(abs >= 100) return val.toFixed(0);
    if(abs >= 10) return val.toFixed(1);
    if(abs >= 1) return val.toFixed(2);
    if(abs >= 0.1) return val.toFixed(3);
    if(abs >= 0.01) return val.toFixed(4);
    if(abs >= 0.001) return val.toFixed(5);
    return val.toFixed(6);
  };

  // frame
  ctx.strokeStyle = 'rgba(231,236,255,0.18)';
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.strokeRect(m.l, m.t, pw, ph);

  // grid
  ctx.strokeStyle = 'rgba(231,236,255,0.06)';
  ctx.lineWidth = 1*devicePixelRatio;
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
  }
  const xStep = niceXStep(xMax);
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.beginPath();
    ctx.moveTo(px, m.t);
    ctx.lineTo(px, m.t+ph);
    ctx.stroke();
  }

  // axis labels
  ctx.fillStyle = 'rgba(231,236,255,0.75)';
  ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    ctx.fillText(fmtAxis(y), m.l-8, py);
  }
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.fillStyle = 'rgba(231,236,255,0.70)';
    const xLbl = (xStep < 1) ? x.toFixed(1) : String(Math.round(x));

        ctx.fillText(xLbl, px, m.t+ph+10);
  }

  // title
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillStyle = 'rgba(231,236,255,0.9)';
  ctx.font = `13px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
  ctx.fillText(opts.title || '', m.l, 10);

  // helper: band fill
  const drawBand = (lo, hi, alpha, color)=>{
    if(!lo || !hi) return;
    const pattern = (()=>{
      if(!opts.bandPattern) return null;
      const size = Math.max(6, Math.round(10 * devicePixelRatio));
      const pat = document.createElement('canvas');
      pat.width = size;
      pat.height = size;
      const pctx = pat.getContext('2d');
      pctx.strokeStyle = color;
      pctx.globalAlpha = 0.25;
      pctx.lineWidth = Math.max(1, Math.round(1 * devicePixelRatio));
      pctx.beginPath();
      pctx.moveTo(0, size);
      pctx.lineTo(size, 0);
      pctx.stroke();
      pctx.beginPath();
      pctx.moveTo(-size * 0.25, size);
      pctx.lineTo(size, -size * 0.25);
      pctx.stroke();
      return ctx.createPattern(pat, 'repeat');
    })();
    ctx.save();
    ctx.globalAlpha = alpha ?? 0.15;
    ctx.fillStyle = pattern || color;
    ctx.beginPath();
    // upper
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (hi[i]/yTop)*ph;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    // lower (reverse)
    for(let i=tArr.length-1;i>=0;i--){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (lo[i]/yTop)*ph;
      ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  };

  // draw bands first (so lines sit on top)
  if(opts.bands){
    for(const [key,b] of Object.entries(opts.bands)){
      if(visibleMap[key] === false) continue;
      let color = 'rgba(255,140,171,1)'; // demand-ish
      if(key === 'supply') color = 'rgba(97,230,180,1)';
      if(key === 'total')  color = 'rgba(255,140,171,1)';
      if(opts.bandColors && opts.bandColors[key]) color = opts.bandColors[key];
      drawBand(b.lo, b.hi, b.alpha ?? 0.14, color);
    }
  }

  // series (base lines)
  for(const s of seriesList){
    if(!visibleMap[s.key]) continue;
    const arr = seriesDict[s.key];
    if(!arr) continue;

    // If we have uncertainty bands for this series, draw base line more subtly to avoid clutter
    const hasBand = opts.bands && opts.bands[s.key] && opts.bands[s.key].mid;
    if(hasBand){
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.setLineDash([3*devicePixelRatio, 3*devicePixelRatio]);
    }else{
      ctx.setLineDash([]);
    }

    ctx.lineWidth = (s.bold ? 2.6 : 1) * devicePixelRatio;
    ctx.strokeStyle = s.color;
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (arr[i]/yTop)*ph;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // median lines from bands (draw on top)
  if(opts.bands){
    for(const [key,b] of Object.entries(opts.bands)){
      if(visibleMap[key] === false) continue;
      if(!b.mid) continue;
      let color = 'rgba(255,140,171,1)';
      if(key === 'supply') color = 'rgba(97,230,180,1)';
      if(key === 'total')  color = 'rgba(255,140,171,1)';
      if(opts.bandColors && opts.bandColors[key]) color = opts.bandColors[key];
      ctx.save();
      ctx.lineWidth = 2.2 * devicePixelRatio;
      ctx.strokeStyle = color;
      ctx.setLineDash([]);
      ctx.beginPath();
      for(let i=0;i<tArr.length;i++){
        const x = m.l + (tArr[i]/xMax)*pw;
        const y = m.t + ph - (b.mid[i]/yTop)*ph;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  return {m, pw, ph, xMax, yTop, tArr, seriesDict, opts};
}

function drawDOPlot(canvas, sim, overlay=null){
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const m = {l:56*devicePixelRatio, r:16*devicePixelRatio, t:30*devicePixelRatio, b:34*devicePixelRatio};
  const pw = w - m.l - m.r;
  const ph = h - m.t - m.b;

  const tArr = sim.t;
  const xMax = tArr[tArr.length-1] || 1;

  let yMax = sim.meta.oxy.Cstar * 1.1;
  for(const v of sim.DO_mgL) if(v>yMax) yMax=v;
  if(overlay && overlay.DO && overlay.DO.hi){
    for(let i=0;i<overlay.DO.hi.length;i++) if(overlay.DO.hi[i] > yMax) yMax = overlay.DO.hi[i];
  }
  if(overlay && overlay.Cstar && Number.isFinite(overlay.Cstar.hi)){
    yMax = Math.max(yMax, overlay.Cstar.hi * 1.1);
  }
  yMax = Math.max(0.1, yMax);
  const yTop = niceTop(yMax);
  const yStep = niceStep(yTop);

  // frame
  ctx.strokeStyle = 'rgba(231,236,255,0.18)';
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.strokeRect(m.l, m.t, pw, ph);

  // grid
  ctx.strokeStyle = 'rgba(231,236,255,0.06)';
  ctx.lineWidth = 1*devicePixelRatio;
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
  }
  const xStep = niceXStep(xMax);
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.beginPath();
    ctx.moveTo(px, m.t);
    ctx.lineTo(px, m.t+ph);
    ctx.stroke();
  }

  const CstarRef = (overlay && overlay.Cstar && Number.isFinite(overlay.Cstar.mid)) ? overlay.Cstar.mid : sim.meta.oxy.Cstar;

  // y labels (mg/L)
  ctx.fillStyle = 'rgba(231,236,255,0.75)';
  ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    ctx.fillText(y.toFixed(1), m.l-8, py);
  }
  // right axis (% saturation)
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  for(let y=0;y<=yTop+1e-12;y+=yStep){
    const py = m.t + ph - (y/yTop)*ph;
    const pct = (CstarRef > 1e-9) ? (100 * y / CstarRef) : 0;
    ctx.fillText(`${Math.round(pct)}%`, m.l+pw+8, py);
  }
  // x labels
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.fillStyle = 'rgba(231,236,255,0.70)';
    const xLbl = (xStep < 1) ? x.toFixed(1) : String(Math.round(x));

        ctx.fillText(xLbl, px, m.t+ph+10);
  }

  // title
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillStyle = 'rgba(231,236,255,0.9)';
  ctx.font = `13px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
  ctx.fillText('Dissolved Oxygen (mg/L)', m.l, 10);
  ctx.textAlign = 'right';
  ctx.fillText('% saturation', m.l + pw, 10);

  // C* band + line
  const drawHBand = (yLo, yHi, alpha)=>{
    const py1 = m.t + ph - (yHi/yTop)*ph;
    const py2 = m.t + ph - (yLo/yTop)*ph;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = 'rgba(231,236,255,1)';
    ctx.fillRect(m.l, py1, pw, py2-py1);
    ctx.restore();
  };

  if(overlay && overlay.Cstar && Number.isFinite(overlay.Cstar.lo)){
    drawHBand(overlay.Cstar.lo, overlay.Cstar.hi, 0.07);
    const yMed = overlay.Cstar.mid;
    const py = m.t + ph - (yMed/yTop)*ph;
    ctx.save();
    ctx.setLineDash([6*devicePixelRatio, 6*devicePixelRatio]);
    ctx.strokeStyle = 'rgba(231,236,255,0.75)';
    ctx.lineWidth = 2*devicePixelRatio;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
    ctx.restore();
  }else{
    const y = sim.meta.oxy.Cstar;
    const py = m.t + ph - (y/yTop)*ph;
    ctx.save();
    ctx.setLineDash([6*devicePixelRatio, 6*devicePixelRatio]);
    ctx.strokeStyle = 'rgba(231,236,255,0.65)';
    ctx.lineWidth = 2*devicePixelRatio;
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
    ctx.restore();
  }

  // DO band
  if(overlay && overlay.DO && overlay.DO.lo && overlay.DO.hi){
    const makePattern = ()=>{
      const size = Math.max(6, Math.round(10 * devicePixelRatio));
      const pat = document.createElement('canvas');
      pat.width = size;
      pat.height = size;
      const pctx = pat.getContext('2d');
      pctx.strokeStyle = 'rgba(118,178,255,1)';
      pctx.globalAlpha = 0.25;
      pctx.lineWidth = Math.max(1, Math.round(1 * devicePixelRatio));
      pctx.beginPath();
      pctx.moveTo(0, size);
      pctx.lineTo(size, 0);
      pctx.stroke();
      pctx.beginPath();
      pctx.moveTo(-size * 0.25, size);
      pctx.lineTo(size, -size * 0.25);
      pctx.stroke();
      return ctx.createPattern(pat, 'repeat');
    };
    const bandPattern = makePattern();
    ctx.save();
    ctx.globalAlpha = overlay.DO.alpha ?? 0.16;
    ctx.fillStyle = bandPattern || 'rgba(118,178,255,1)';
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (overlay.DO.hi[i]/yTop)*ph;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    for(let i=tArr.length-1;i>=0;i--){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (overlay.DO.lo[i]/yTop)*ph;
      ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // base DO (subtle if band exists)
  ctx.save();
  ctx.lineWidth = 2.4*devicePixelRatio;
  ctx.strokeStyle = 'rgba(118,178,255,1)';
  if(overlay && overlay.DO && overlay.DO.mid){
    ctx.globalAlpha = 0.30;
    ctx.setLineDash([3*devicePixelRatio, 3*devicePixelRatio]);
  }else{
    ctx.setLineDash([]);
  }
  ctx.beginPath();
  for(let i=0;i<tArr.length;i++){
    const x = m.l + (tArr[i]/xMax)*pw;
    const y = m.t + ph - (sim.DO_mgL[i]/yTop)*ph;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.restore();

  // median DO line
  if(overlay && overlay.DO && overlay.DO.mid){
    ctx.save();
    ctx.lineWidth = 2.8*devicePixelRatio;
    ctx.strokeStyle = 'rgba(118,178,255,1)';
    ctx.setLineDash([]);
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = m.t + ph - (overlay.DO.mid[i]/yTop)*ph;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  return {m, pw, ph, xMax, yTop, tArr, sim, overlay};
}

function drawBiomassPlot(canvas, sim, overlay=null){
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0,0,w,h);

  const m = {l:56*devicePixelRatio, r:56*devicePixelRatio, t:30*devicePixelRatio, b:34*devicePixelRatio};
  const pw = w - m.l - m.r;
  const ph = h - m.t - m.b;

  const tArr = sim.t;
  const xMax = tArr[tArr.length-1] || 1;

  let yMaxG = Math.max(...sim.biomass.hetero_g, ...sim.biomass.phyto_g, 0.1);
  if(overlay && overlay.bioBands){
    yMaxG = Math.max(yMaxG, Math.max(...overlay.bioBands.hetero_g.hi, ...overlay.bioBands.phyto_g.hi));
  }
  const yTopG = niceTop(yMaxG);
  const yStepG = niceStep(yTopG);

  const pctVals = sim.biomass.hetero_pct.concat(sim.biomass.phyto_pct);
  let pctMin = Math.min(...pctVals, 0);
  let pctMax = Math.max(...pctVals, 0);
  if(overlay && overlay.bioPctBands){
    pctMin = Math.min(pctMin, Math.min(...overlay.bioPctBands.hetero_pct.lo, ...overlay.bioPctBands.phyto_pct.lo));
    pctMax = Math.max(pctMax, Math.max(...overlay.bioPctBands.hetero_pct.hi, ...overlay.bioPctBands.phyto_pct.hi));
  }
  const pctSpan = Math.max(1, Math.max(Math.abs(pctMin), Math.abs(pctMax)));
  const pctTop = niceTop(pctSpan);

  const yFromG = (val)=> m.t + ph - (val / yTopG) * ph;
  const yFromPct = (val)=> m.t + ph - ((val + pctTop) / (pctTop * 2)) * ph;

  // frame
  ctx.strokeStyle = 'rgba(231,236,255,0.18)';
  ctx.lineWidth = 1*devicePixelRatio;
  ctx.strokeRect(m.l, m.t, pw, ph);

  // grid (grams scale)
  ctx.strokeStyle = 'rgba(231,236,255,0.06)';
  ctx.lineWidth = 1*devicePixelRatio;
  for(let y=0;y<=yTopG+1e-12;y+=yStepG){
    const py = yFromG(y);
    ctx.beginPath();
    ctx.moveTo(m.l, py);
    ctx.lineTo(m.l+pw, py);
    ctx.stroke();
  }
  const xStep = niceXStep(xMax);
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.beginPath();
    ctx.moveTo(px, m.t);
    ctx.lineTo(px, m.t+ph);
    ctx.stroke();
  }

  // axis labels
  ctx.fillStyle = 'rgba(231,236,255,0.75)';
  ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue('--mono')}`;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for(let y=0;y<=yTopG+1e-12;y+=yStepG){
    const py = yFromG(y);
    ctx.fillText(y.toFixed(1), m.l-8, py);
  }
  ctx.textAlign = 'left';
  for(let y=-pctTop;y<=pctTop+1e-12;y+=pctTop/4){
    const py = yFromPct(y);
    ctx.fillText(`${Math.round(y)}%`, m.l+pw+8, py);
  }

  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for(let x=0;x<=xMax+1e-9;x+=xStep){
    const px = m.l + (x/xMax)*pw;
    ctx.fillStyle = 'rgba(231,236,255,0.70)';
    const xLbl = (xStep < 1) ? x.toFixed(1) : String(Math.round(x));
    ctx.fillText(xLbl, px, m.t+ph+10);
  }

  // title
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillStyle = 'rgba(231,236,255,0.9)';
  ctx.font = `13px ${getComputedStyle(document.documentElement).getPropertyValue('--sans')}`;
  ctx.fillText('Expected biomass fluctuations', m.l, 10);
  ctx.textAlign = 'right';
  ctx.fillText('% change', m.l + pw, 10);

  const drawBand = (lo, hi, color, alpha=0.12)=>{
    const size = Math.max(6, Math.round(10 * devicePixelRatio));
    const pat = document.createElement('canvas');
    pat.width = size;
    pat.height = size;
    const pctx = pat.getContext('2d');
    pctx.strokeStyle = color;
    pctx.globalAlpha = 0.25;
    pctx.lineWidth = Math.max(1, Math.round(1 * devicePixelRatio));
    pctx.beginPath();
    pctx.moveTo(0, size);
    pctx.lineTo(size, 0);
    pctx.stroke();
    const pattern = ctx.createPattern(pat, 'repeat');
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = pattern || color;
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = yFromG(hi[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    for(let i=tArr.length-1;i>=0;i--){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = yFromG(lo[i]);
      ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  };

  if(overlay && overlay.bioBands){
    drawBand(overlay.bioBands.hetero_g.lo, overlay.bioBands.hetero_g.hi, '#ff9f43', 0.10);
    drawBand(overlay.bioBands.phyto_g.lo, overlay.bioBands.phyto_g.hi, '#1dd1a1', 0.10);
  }

  // grams lines
  const drawLine = (arr, color, bold=false)=>{
    ctx.save();
    ctx.lineWidth = (bold ? 2.4 : 1.4) * devicePixelRatio;
    ctx.strokeStyle = color;
    ctx.setLineDash([]);
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = yFromG(arr[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  };
  drawLine(sim.biomass.hetero_g, '#ff9f43', true);
  drawLine(sim.biomass.phyto_g, '#1dd1a1', true);

  // percent lines
  const drawPct = (arr, color)=>{
    ctx.save();
    ctx.lineWidth = 1.2 * devicePixelRatio;
    ctx.strokeStyle = color;
    ctx.setLineDash([4*devicePixelRatio, 3*devicePixelRatio]);
    ctx.beginPath();
    for(let i=0;i<tArr.length;i++){
      const x = m.l + (tArr[i]/xMax)*pw;
      const y = yFromPct(arr[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  };
  drawPct(sim.biomass.hetero_pct, '#ffd166');
  drawPct(sim.biomass.phyto_pct, '#a8e6cf');

  return {m, pw, ph, xMax, yTopG, pctTop, tArr, sim, overlay};
}

/* =========================================================
   Legend + events
========================================================= */
function buildLegendRate(){
  const root = el('legendRate');
  if(!root) return;
  root.innerHTML = '';
  for(const s of RATE_SERIES){
    const d = document.createElement('div');
    d.className = 'leg' + (visibleRate[s.key] ? '' : ' off');
    d.innerHTML = `<span class="dot" style="background:${s.color}"></span><span>${s.name}</span>`;
    d.addEventListener('click', ()=>{
      visibleRate[s.key] = !visibleRate[s.key];
      buildLegendRate();
      recompute();
    });
    root.appendChild(d);
  }
}

function buildLegendChem(){
  const root = el('legendChem');
  if(!root) return;
  root.innerHTML = '';
  for(const s of CHEM_SERIES){
    const d = document.createElement('div');
    d.className = 'leg' + (visibleChem[s.key] ? '' : ' off');
    d.innerHTML = `<span class="dot" style="background:${s.color}"></span><span>${s.name}</span>`;
    d.addEventListener('click', ()=>{
      visibleChem[s.key] = !visibleChem[s.key];
      buildLegendChem();
      recompute();
    });
    root.appendChild(d);
  }
}

function buildLegendBio(){
  const root = el('legendBio');
  if(!root) return;
  root.innerHTML = '';
  for(const s of BIOMASS_SERIES){
    const d = document.createElement('div');
    d.className = 'leg';
    const dash = s.dash ? 'border-bottom:2px dashed ' + s.color : `background:${s.color}`;
    d.innerHTML = `<span class="dot" style="${dash}"></span><span>${s.name}</span>`;
    root.appendChild(d);
  }
}

let EVENTS = [];

function maxPelletCountFromInputs(){
  const mEach = pelletMassEach(Number(el('pelLen')?.value || 1.0), Number(el('pelDia')?.value || 0.2), Number(el('pelRho')?.value || 0.55));
  const totalMass = Number(el('pelMassN')?.value || 0);
  return mEach > 0 ? totalMass / mEach : 0;
}

function normalizeEvents(){
  const daysMax = Number(el('daysN')?.value);
  const maxPel = maxPelletCountFromInputs();
  let remaining = maxPel;
  let truncated = false;
  const cleaned = [];

  EVENTS.sort((a,b)=>a.day-b.day);
  for(const raw of EVENTS){
    const day = clamp(Number(raw.day || 0), 0, Number.isFinite(daysMax) ? daysMax : raw.day);
    let pel = Math.max(0, Math.round(Number(raw.pellets || 0)));
    if(pel > remaining){
      pel = Math.max(0, Math.floor(remaining));
      truncated = true;
    }
    if(pel > 0){
      cleaned.push({day, pellets: pel});
      remaining -= pel;
    }
  }
  if(truncated){
    addWarning('Pop events truncated to avoid exceeding available pellets.');
  }
  EVENTS = cleaned;
}

function renderEvents(){
  const table = el('eventsTable');
  if(!table){
    addWarning('Events table missing (#eventsTable). Skipping event rendering.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'eventsTable', context:'renderEvents'});
    return;
  }
  const tb = table.querySelector('tbody');
  if(!tb){
    addWarning('Events table missing tbody. Skipping event rendering.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'eventsTable.tbody', context:'renderEvents'});
    return;
  }
  normalizeEvents();
  tb.innerHTML = '';
  EVENTS.forEach((e, idx)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="number" step="0.1" min="0" value="${Number(e.day).toFixed(1)}" data-idx="${idx}" data-k="day"></td>
      <td><input type="number" step="1" min="0" value="${Math.round(Number(e.pellets))}" data-idx="${idx}" data-k="pellets"></td>
      <td><button class="btn danger" data-del="${idx}">Remove</button></td>
    `;
    tb.appendChild(tr);
  });

  tb.querySelectorAll('input').forEach(inp=>{
    inp.addEventListener('input', (ev)=>{
      const i = Number(ev.target.dataset.idx);
      const k = ev.target.dataset.k;
      EVENTS[i][k] = Number(ev.target.value);
      saveState();
      renderEvents();
      recompute();
    });
  });

  tb.querySelectorAll('button[data-del]').forEach(btn=>{
    btn.addEventListener('click',(ev)=>{
      const i = Number(ev.target.dataset.del);
      EVENTS.splice(i,1);
      saveState();
      renderEvents();
      recompute();
    });
  });
}

/* =========================================================
   State persistence
========================================================= */
const STATE_VERSION = 6;

function saveState(){
  const s = {
    version: STATE_VERSION,
    // main sliders
    pelMass: Number(el('pelMassN').value),
    powMass: Number(el('powMassN').value),
    blanket: Number(el('blanketN').value),
    days: Number(el('daysN').value),

    // environment
    volL: Number(el('volL').value),
    airFlow: Number(el('airFlow').value),
    Tnow: Number(el('Tnow').value),
    pH: Number(el('pH').value),
    altM: Number(el('altM').value),
    tds: Number(el('tds').value),

    // geometry + exchange
    ripplePct: Number(el('ripplePct').value),
    lenCm: Number(el('lenCm').value),
    widCm: Number(el('widCm').value),
    tankHCm: Number(el('tankHCm').value),
    waterSurfCm: Number(el('waterSurfCm').value),
    blanketGapCm: Number(el('blanketGapCm').value),
    diffDepthCm: Number(el('diffDepthCm').value),
    heaters: Number(el('heaters').value),

    // presets + numbers
    diffType: el('diffType').value,
    sotePerM: Number(el('sotePerM').value),

    surfacePreset: el('surfacePreset') ? el('surfacePreset').value : 'typical',
    kCalm: Number(el('kCalm').value),
    kRipple: Number(el('kRipple').value),

    tightPreset: el('tightPreset') ? el('tightPreset').value : 'loose_high',
    tight: Number(el('tight').value),

    otrPreset: el('otrPreset') ? el('otrPreset').value : 'typical',
    otrCal: Number(el('otrCal').value),

    initDOPreset: el('initDOPreset') ? el('initDOPreset').value : '95',
    doInitPct: Number(el('doInitPct').value),

    // kinetics options
    o2Limit: el('o2Limit').value,
    kDoNit: Number(el('kDoNit').value),
    kDoHet: Number(el('kDoHet').value),
    slowFrac: Number(el('slowFrac').value),
    biofilmMm: Number(el('biofilmMm').value),
    kDenit: Number(el('kDenit').value),
    denitCap: Number(el('denitCap').value),
    fishMass: Number(el('fishMass').value),
    photoMass: Number(el('photoMass').value),
    tempAmp: Number(el('tempAmp').value),
    lightHour: Number(el('lightHour').value),
    kNH4Nit: Number(el('kNH4Nit').value),
    kNO2Nit: Number(el('kNO2Nit').value),
    nitCap: Number(el('nitCap').value),
    nitQ10: Number(el('nitQ10').value),
    nUnits: el('nUnits').value,
    chemNerd: !!el('chemNerd').checked,
    chemDisplay: el('chemDisplay') ? el('chemDisplay').value : 'bio',

    // pellet geometry
    pelLen: 1.00, // hardcoded
    pelDia: 0.20, // hardcoded
    pelRho: Number(el('pelRho').value),

    // uncertainty mode
    runMode: el('runMode') ? el('runMode').value : 'uncertainty',
    uncLevel: el('uncLevel') ? el('uncLevel').value : 'typical',
    mcRuns: el('mcRuns') ? Number(el('mcRuns').value) : 200,
    bandPreset: el('bandPreset') ? el('bandPreset').value : '10-90',
    seed: el('seed') ? Number(el('seed').value) : 12345,
    liveRecompute: el('liveRecompute') ? el('liveRecompute').value : 'on',
    uAir: el('uAir') ? !!el('uAir').checked : true,
    uDiff: el('uDiff') ? !!el('uDiff').checked : true,
    uSurf: el('uSurf') ? !!el('uSurf').checked : true,
    uTight: el('uTight') ? !!el('uTight').checked : true,
    uBio: el('uBio') ? !!el('uBio').checked : true,
    uTemp: el('uTemp') ? !!el('uTemp').checked : true,
    uInitDO: el('uInitDO') ? !!el('uInitDO').checked : true,

    events: EVENTS
  };
  localStorage.setItem('o2planner_state_v3', JSON.stringify(s));
}

function loadState(){
  try{
    let raw = localStorage.getItem('o2planner_state_v3');
    if(!raw) raw = localStorage.getItem('o2planner_state_v2'); // backwards compatibility
    if(!raw) return;

    const s = JSON.parse(raw);
    const set = (id, v)=>{ if(el(id) && v !== undefined && v !== null) el(id).value = v; };
    const setCheck = (id, v)=>{ if(el(id) && v !== undefined && v !== null) el(id).checked = !!v; };

    // sliders (range+number pairs)
    if(s.pelMass !== undefined){ el('pelMass').value = s.pelMass; el('pelMassN').value = s.pelMass; }
    if(s.powMass !== undefined){ el('powMass').value = s.powMass; el('powMassN').value = s.powMass; }
    if(s.blanket !== undefined){ el('blanket').value = s.blanket; el('blanketN').value = s.blanket; }
    if(s.days !== undefined){ el('days').value = s.days; el('daysN').value = s.days; }

    // environment + geometry
    ['volL','airFlow','Tnow','pH','altM','tds','ripplePct','lenCm','widCm','tankHCm','waterSurfCm','blanketGapCm','diffDepthCm',
     'heaters','sotePerM','kCalm','kRipple','tight','otrCal','doInitPct','kDoNit','kNH4Nit','kNO2Nit','nitCap','nitQ10',
     'kDoHet','slowFrac','biofilmMm','kDenit','denitCap','fishMass','photoMass','tempAmp','lightHour',
     'pelLen','pelDia','pelRho'
    ].forEach(k=>set(k, s[k]));

    if(!s.version || s.version < STATE_VERSION){
      if(s.fishMass === undefined) set('fishMass', 0);
      if(s.photoMass === undefined) set('photoMass', 0);
    }

    if(s.diffType !== undefined) el('diffType').value = s.diffType;
    if(s.surfacePreset !== undefined && el('surfacePreset')) el('surfacePreset').value = s.surfacePreset;
    if(s.tightPreset !== undefined && el('tightPreset')) el('tightPreset').value = s.tightPreset;
    if(s.otrPreset !== undefined && el('otrPreset')) el('otrPreset').value = s.otrPreset;
    if(s.initDOPreset !== undefined && el('initDOPreset')) el('initDOPreset').value = s.initDOPreset;

    if(s.o2Limit !== undefined) el('o2Limit').value = s.o2Limit;
    if(s.nUnits !== undefined && el('nUnits')) el('nUnits').value = s.nUnits;
    setCheck('chemNerd', s.chemNerd);
    if(s.chemDisplay !== undefined && el('chemDisplay')) el('chemDisplay').value = s.chemDisplay;

    // uncertainty mode
    if(el('runMode') && s.runMode !== undefined) el('runMode').value = s.runMode;
    if(el('uncLevel') && s.uncLevel !== undefined) el('uncLevel').value = s.uncLevel;
    if(el('mcRuns') && s.mcRuns !== undefined){ el('mcRuns').value = s.mcRuns; if(el('mcRunsRange')) el('mcRunsRange').value = s.mcRuns; }
    if(el('bandPreset') && s.bandPreset !== undefined) el('bandPreset').value = s.bandPreset;
    if(el('seed') && s.seed !== undefined) el('seed').value = s.seed;
    if(el('liveRecompute') && s.liveRecompute !== undefined) el('liveRecompute').value = s.liveRecompute;

    setCheck('uAir', s.uAir);
    setCheck('uDiff', s.uDiff);
    setCheck('uSurf', s.uSurf);
    setCheck('uTight', s.uTight);
    setCheck('uBio', s.uBio);
    setCheck('uTemp', s.uTemp);
    setCheck('uInitDO', s.uInitDO);

    EVENTS = Array.isArray(s.events) ? s.events : [];
    EVENTS = EVENTS.map(ev=>{
      if(ev && ev.pop !== undefined && ev.pellets === undefined){
        return {day: ev.day, pellets: ev.pop};
      }
      return ev;
    });
    // re-sync preset numeric fields after load
    try{ applyAllPresets(); }catch(_){}
  }catch(_){}
}

/* =========================================================
   Tooltips + click-to-add-event (bind once)
========================================================= */
let lastSim = null;
let lastMC = null;
let rateGeom = null;
let doGeom = null;
let chemGeom = null;
let bioGeom = null;
let interactionsBound = false;

function initCanvasInteractions(){
  const tip = ensureTooltip();

  const hide = ()=>{ if(!tip) return; tip.style.display='none'; };
  const show = (ev, html)=>{
    if(!tip) return;
    tip.innerHTML = html;
    tip.style.display = 'block';
    const pad = 14;
    const x = ev.clientX + pad;
    const y = ev.clientY + pad;
    tip.style.left = x + 'px';
    tip.style.top = y + 'px';
  };

  function idxFromEvent(ev, geom){
    const rect = ev.target.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * devicePixelRatio;
    const y = (ev.clientY - rect.top) * devicePixelRatio;
    if(x < geom.m.l || x > geom.m.l + geom.pw || y < geom.m.t || y > geom.m.t + geom.ph) return null;
    const frac = clamp((x - geom.m.l)/geom.pw, 0, 1);
    const day = frac * geom.xMax;
    const idx = clamp(Math.round(day / lastSim.meta.dt), 0, lastSim.t.length-1);
    return idx;
  }

  function bandLine(label, mid, lo, hi, color){
    return `<div style="margin-top:4px; color:${color}; opacity:.95">${label}: <span class="mono">${mid.toFixed(3)}</span> <span class="small" style="opacity:.9">[${lo.toFixed(3)}–${hi.toFixed(3)}]</span></div>`;
  }
  function bandLine2(label, mid, lo, hi, color){
    return `<div style="margin-top:4px; color:${color}; opacity:.95">${label}: <span class="mono">${mid.toFixed(2)}</span> <span class="small" style="opacity:.9">[${lo.toFixed(2)}–${hi.toFixed(2)}]</span></div>`;
  }

  const bind = (canvas, getGeom, kind)=>{
    if(canvas.dataset.bound === '1') return;
    canvas.dataset.bound = '1';

    canvas.addEventListener('mousemove', (ev)=>{
      if(!lastSim) return;
      const geom = getGeom();
      if(!geom) return;
      const idx = idxFromEvent(ev, geom);
      if(idx === null){ hide(); return; }

      const day = lastSim.t[idx];

      if(kind === 'rate'){
        const lines = [];
        lines.push(`<div><b>Day ${day.toFixed(2)}</b></div>`);
        for(const s of RATE_SERIES){
          if(!visibleRate[s.key]) continue;
          const v = lastSim.rate[s.key]?.[idx];
          if(v === undefined) continue;
          lines.push(`<div style="margin-top:4px"><span style="color:${s.color}">●</span> ${s.name}: <b class="mono">${v.toFixed(3)}</b></div>`);
        }

        const DO = lastSim.DO_mgL[idx], DOpc = lastSim.DO_pct[idx];
        lines.push(`<div style="margin-top:6px; color:rgba(231,236,255,0.8)">DO (base): <span class="mono">${DO.toFixed(2)} mg/L</span> (${DOpc.toFixed(0)}%)</div>`);

        if(lastMC){
          const tmid = lastMC.q.rateTotal.mid[idx], tlo = lastMC.q.rateTotal.lo[idx], thi = lastMC.q.rateTotal.hi[idx];
          const smid = lastMC.q.rateSupply.mid[idx], slo = lastMC.q.rateSupply.lo[idx], shi = lastMC.q.rateSupply.hi[idx];
          lines.push(`<div class="hr" style="margin:8px 0"></div>`);
          lines.push(`<div class="small" style="opacity:.85">Uncertainty band:</div>`);
          lines.push(bandLine('Total demand', tmid, tlo, thi, 'rgba(255,140,171,1)'));
          lines.push(bandLine('O₂ supply', smid, slo, shi, 'rgba(97,230,180,1)'));
          const dmid = lastMC.q.DO.mid[idx], dlo = lastMC.q.DO.lo[idx], dhi = lastMC.q.DO.hi[idx];
          lines.push(bandLine2('DO', dmid, dlo, dhi, 'rgba(118,178,255,1)'));
        }

        show(ev, lines.join(''));
      }

      if(kind === 'chem'){
        const lines = [];
        lines.push(`<div><b>Day ${day.toFixed(2)}</b></div>`);
        const mode = getChemDisplayMode();
        const chemSeries = resolveChemSeries(lastSim, mode).series;
        for(const s of CHEM_SERIES){
          if(!visibleChem[s.key]) continue;
          const v = chemSeries?.[s.key]?.[idx];
          if(v === undefined) continue;
          lines.push(`<div style="margin-top:4px"><span style="color:${s.color}">●</span> ${s.name}: <b class="mono">${v.toFixed(3)}</b></div>`);
        }

        if(lastMC){
          const band = mode === 'prod' ? lastMC.q.chemProdBands : (mode === 'cum' ? lastMC.q.chemCumBands : lastMC.q.chemBands);
          if(band){
            lines.push(`<div class="hr" style="margin:8px 0"></div>`);
            lines.push(`<div class="small" style="opacity:.85">Uncertainty band:</div>`);
            for(const s of CHEM_SERIES){
              if(!visibleChem[s.key]) continue;
              const b = band[s.key];
              if(!b) continue;
              lines.push(bandLine2(s.name, b.mid[idx], b.lo[idx], b.hi[idx], s.color));
            }
          }
        }

        show(ev, lines.join(''));
      }

      if(kind === 'bio'){
        const lines = [];
        lines.push(`<div><b>Day ${day.toFixed(2)}</b></div>`);
        const hG = lastSim.biomass.hetero_g[idx];
        const pG = lastSim.biomass.phyto_g[idx];
        const hP = lastSim.biomass.hetero_pct[idx];
        const pP = lastSim.biomass.phyto_pct[idx];
        lines.push(`<div style="margin-top:4px"><span style="color:#ff9f43">●</span> Heterotroph: <b class="mono">${hG.toFixed(2)} g</b> (${hP.toFixed(1)}%)</div>`);
        lines.push(`<div style="margin-top:4px"><span style="color:#1dd1a1">●</span> Phyto: <b class="mono">${pG.toFixed(2)} g</b> (${pP.toFixed(1)}%)</div>`);
        if(lastMC){
          const band = lastMC.q.bioBands;
          const bandPct = lastMC.q.bioPctBands;
          lines.push(`<div class="hr" style="margin:8px 0"></div>`);
          lines.push(`<div class="small" style="opacity:.85">Uncertainty band:</div>`);
          lines.push(bandLine2('Hetero (g)', band.hetero_g.mid[idx], band.hetero_g.lo[idx], band.hetero_g.hi[idx], '#ff9f43'));
          lines.push(bandLine2('Phyto (g)', band.phyto_g.mid[idx], band.phyto_g.lo[idx], band.phyto_g.hi[idx], '#1dd1a1'));
          lines.push(bandLine2('Hetero (%)', bandPct.hetero_pct.mid[idx], bandPct.hetero_pct.lo[idx], bandPct.hetero_pct.hi[idx], '#ffd166'));
          lines.push(bandLine2('Phyto (%)', bandPct.phyto_pct.mid[idx], bandPct.phyto_pct.lo[idx], bandPct.phyto_pct.hi[idx], '#a8e6cf'));
        }
        show(ev, lines.join(''));
      }

      if(kind === 'do'){
        const lines = [];
        lines.push(`<div><b>Day ${day.toFixed(2)}</b></div>`);
        const DO = lastSim.DO_mgL[idx], DOpc = lastSim.DO_pct[idx];
        lines.push(`<div style="margin-top:4px"><span style="color:rgba(118,178,255,1)">●</span> DO (base): <b class="mono">${DO.toFixed(2)} mg/L</b> (${DOpc.toFixed(0)}%)</div>`);
        const c = lastSim.meta.oxy.Cstar;
        lines.push(`<div style="margin-top:4px; opacity:.8">C* (base): <span class="mono">${c.toFixed(2)} mg/L</span></div>`);

        if(lastMC){
          const dmid = lastMC.q.DO.mid[idx], dlo = lastMC.q.DO.lo[idx], dhi = lastMC.q.DO.hi[idx];
          lines.push(`<div class="hr" style="margin:8px 0"></div>`);
          lines.push(`<div class="small" style="opacity:.85">Uncertainty band:</div>`);
          lines.push(bandLine2('DO', dmid, dlo, dhi, 'rgba(118,178,255,1)'));
          lines.push(`<div style="margin-top:4px; opacity:.8">C*: <span class="mono">${lastMC.scalars.Cstar.mid.toFixed(2)} mg/L</span> <span class="small">[${lastMC.scalars.Cstar.lo.toFixed(2)}–${lastMC.scalars.Cstar.hi.toFixed(2)}]</span></div>`);
        }

        show(ev, lines.join(''));
      }
    });

    canvas.addEventListener('mouseleave', hide);
  };

  const rateCanvas = el('rateCanvas');
  bind(rateCanvas, ()=>rateGeom, 'rate');
  bind(el('chemCanvas'), ()=>chemGeom, 'chem');
  bind(el('doCanvas'), ()=>doGeom, 'do');
  bind(el('bioCanvas'), ()=>bioGeom, 'bio');

  if(rateCanvas && rateGeom && rateCanvas.dataset.clickBound !== '1'){
    rateCanvas.dataset.clickBound = '1';
    rateCanvas.addEventListener('click', (ev)=>{
      if(!lastSim || !rateGeom) return;
      const idx = idxFromEvent(ev, rateGeom);
      if(idx === null) return;
      el('evDay').value = lastSim.t[idx].toFixed(2);
    });
  }
}

/* =========================================================
   Flags + summary
========================================================= */
function fmtVal(value, unit='', decimals=null){
  if(!Number.isFinite(value)) return unit ? `— ${unit}` : '—';
  const abs = Math.abs(value);
  const d = (decimals != null) ? decimals : (abs >= 10 ? 1 : (abs >= 1 ? 2 : 3));
  return `${value.toFixed(d)}${unit ? ` ${unit}` : ''}`;
}

function fmtBandLine(mode, good, warn, unit=''){
  if(mode === 'min'){
    return `Safe ≥ ${fmtVal(good, unit)} • Watch ${fmtVal(warn, unit)}–${fmtVal(good, unit)} • Risk < ${fmtVal(warn, unit)}`;
  }
  return `Safe ≤ ${fmtVal(good, unit)} • Watch ${fmtVal(good, unit)}–${fmtVal(warn, unit)} • Risk > ${fmtVal(warn, unit)}`;
}

function drawTagSparkline(canvas, series, mode, good, warn){
  if(!canvas || !series || !series.length) return;
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.clientWidth * devicePixelRatio;
  const h = canvas.height = canvas.clientHeight * devicePixelRatio;
  ctx.clearRect(0, 0, w, h);
  const pad = 3 * devicePixelRatio;
  const ph = h - pad * 2;
  const pw = w - pad * 2;
  const maxVal = Math.max(...series, good ?? 0, warn ?? 0, 0.0001);
  const minVal = 0;
  const yFromVal = (v)=> pad + ph - ((v - minVal) / (maxVal - minVal)) * ph;
  const step = Math.max(1, Math.floor(series.length / 60));

  const mid = (Number.isFinite(good) && Number.isFinite(warn)) ? ((good + warn) / 2) : null;
  // threshold lines
  ctx.save();
  ctx.setLineDash([2*devicePixelRatio, 2*devicePixelRatio]);
  ctx.lineWidth = 1 * devicePixelRatio;
  if(Number.isFinite(good)){
    ctx.strokeStyle = 'rgba(99,230,190,0.6)';
    const y = yFromVal(good);
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(pad + pw, y);
    ctx.stroke();
  }
  if(Number.isFinite(mid)){
    ctx.strokeStyle = 'rgba(255,207,90,0.55)';
    const y = yFromVal(mid);
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(pad + pw, y);
    ctx.stroke();
  }
  if(Number.isFinite(warn)){
    ctx.strokeStyle = 'rgba(255,107,107,0.6)';
    const y = yFromVal(warn);
    ctx.beginPath();
    ctx.moveTo(pad, y);
    ctx.lineTo(pad + pw, y);
    ctx.stroke();
  }
  ctx.restore();

  // series line
  ctx.save();
  ctx.lineWidth = 1.4 * devicePixelRatio;
  ctx.strokeStyle = mode === 'min' ? 'rgba(99,230,190,0.9)' : 'rgba(122,162,255,0.9)';
  ctx.beginPath();
  let iPlot = 0;
  for(let i=0;i<series.length;i+=step){
    const x = pad + (iPlot / Math.max(1, Math.ceil(series.length/step)-1)) * pw;
    const y = yFromVal(series[i]);
    if(iPlot === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    iPlot++;
  }
  ctx.stroke();
  ctx.restore();
}

function setFlags(sim, params, mc){
  let flags = el('flags');
  if(!flags){
    addWarning('Flags container missing (#flags). Creating fallback container.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'flags', context:'setFlags'});
    const cards = document.querySelectorAll('.wrap .card');
    const host = cards.length ? cards[cards.length-1] : document.body;
    flags = document.createElement('div');
    flags.id = 'flags';
    flags.className = 'flags';
    flags.style.marginTop = '10px';
    host.appendChild(flags);
  }
  flags.innerHTML = '';
  let tags = el('chemTags');
  if(!tags){
    addWarning('Chemistry tag container missing (#chemTags). Creating fallback container.');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'chemTags', context:'setFlags'});
    tags = document.createElement('div');
    tags.id = 'chemTags';
    tags.className = 'tag-stack';
    tags.style.marginTop = '10px';
    flags.parentNode?.insertBefore(tags, flags);
  }
  tags.innerHTML = '';
  let flagCount = 0;
  const tagSummary = [];

  const kindAliases = {ok:'ok', warn:'warn', danger:'danger', note:'note', good:'ok'};
  const good = kindAliases.good;
  const normalizeKind = (kind)=>{
    if(typeof kind !== 'string') return 'note';
    const norm = kindAliases[kind] || 'note';
    if(norm !== kind){
      addWarning(`Unknown flag kind "${kind}" normalized to "${norm}".`);
    }
    return norm;
  };

  const add = (kind, title, msg)=>{
    const div = document.createElement('div');
    const safeKind = normalizeKind(kind);
    div.className = 'flag-card';
    div.innerHTML = `
      <div class="flag-tag ${safeKind}">${title}<span>${safeKind.toUpperCase()}</span></div>
      <div class="flag-body"><div class="small">${msg}</div></div>
    `;
    flags.appendChild(div);
    flagCount++;
  };

  const estPellets = pelletMassEach(params.pelLen, params.pelDia, params.pelRho);
  const pelCount = estPellets > 0 ? (params.pelletMass_g / estPellets) : 0;
  const eventTotal = (params.events || []).reduce((acc, e)=>acc + (Number(e.pellets) || 0), 0);
  if(eventTotal > pelCount + 1){
    add('warn', 'Pop events exceed pellets', `Total pops (${eventTotal.toFixed(0)}) exceed estimated pellet count (${pelCount.toFixed(0)}). The model caps pops automatically, but the schedule is probably too aggressive.`);
  }
  if(sim.meta?.chemCumInfo?.invalidCount){
    add('warn', 'Chemistry cumulative data gap', `Detected ${sim.meta.chemCumInfo.invalidCount} non-finite chemistry samples. Cumulative plot replaces them with 0 so the chart remains readable.`);
  }

  const rate = sim.rate.total;
  const supply = sim.rate.supply;

  // Peak demand and peak deficit vs supply (base run)
  let peak = {v:0, day:0, idx:0};
  let peakDef = {v:0, day:0, idx:0};
  for(let i=0;i<rate.length;i++){
    if(rate[i] > peak.v) peak = {v:rate[i], day:sim.t[i], idx:i};
    const def = rate[i] - supply[i];
    if(def > peakDef.v) peakDef = {v:def, day:sim.t[i], idx:i};
  }

  // Base deficit area
  let baseArea = 0;
  for(let i=0;i<rate.length;i++) baseArea += Math.max(0, rate[i]-supply[i]) * sim.meta.dt;

  // Base DO min
  let doMinStats = {v:Infinity, day:0, idx:0};
  let tUnder2 = 0, tUnder1 = 0;
  for(let i=0;i<sim.DO_mgL.length;i++){
    const v = sim.DO_mgL[i];
    if(v < doMinStats.v) doMinStats = {v, day:sim.t[i], idx:i};
    if(v < 2.0) tUnder2 += sim.meta.dt;
    if(v < 1.0) tUnder1 += sim.meta.dt;
  }

  let nh4PeakValue = 0, no2PeakValue = 0, no3PeakValue = 0, nh3PeakValue = 0;
  for(let i=0;i<sim.NH4_mgL.length;i++) if(sim.NH4_mgL[i] > nh4PeakValue) nh4PeakValue = sim.NH4_mgL[i];
  for(let i=0;i<sim.NO2_mgL.length;i++) if(sim.NO2_mgL[i] > no2PeakValue) no2PeakValue = sim.NO2_mgL[i];
  for(let i=0;i<sim.NO3_mgL.length;i++) if(sim.NO3_mgL[i] > no3PeakValue) no3PeakValue = sim.NO3_mgL[i];
  for(let i=0;i<sim.NH3_mgL.length;i++) if(sim.NH3_mgL[i] > nh3PeakValue) nh3PeakValue = sim.NH3_mgL[i];
  const denitN_mgL = (sim.audit.no3_to_n2 * 1000) / params.volL;

  // --------------------------
  // Uncertainty mode flags
  // --------------------------
  if(mc){
    const p2 = mc.probs.anyUnder2;
    const p1 = mc.probs.anyUnder1;

    // Severity by probability of dipping below thresholds (based on min DO across the run)
    if(p1 > 0.25){
      add('danger', 'Very high hypoxia risk', `In ${fmtPct(p1)} of runs, DO dips below <b>1 mg/L</b> at least once. That's “fish emergency” territory.`);
    }else if(p1 > 0.10){
      add('warn', 'High hypoxia risk', `In ${fmtPct(p1)} of runs, DO dips below <b>1 mg/L</b>. Consider reducing input, increasing aeration, or increasing open surface exchange.`);
    }
  };
  const classify = (mode, value, good, warn)=>{
    if(!Number.isFinite(value)){
      addWarning('Chem tag value missing; check simulation outputs.');
      return {tone:'warn', label:'unknown'};
    }
    if(mode === 'min'){
      if(value >= good) return {tone:'ok', label:'good'};
      if(value >= warn) return {tone:'warn', label:'watch'};
      return {tone:'danger', label:'risk'};
    }
    if(value <= good) return {tone:'ok', label:'good'};
    if(value <= warn) return {tone:'warn', label:'watch'};
    return {tone:'danger', label:'risk'};
  };
  let sparkCount = 0;
  const addTag = ({label, tone, status, summary, details, spark})=>{
    const det = document.createElement('details');
    det.className = `tag-line tone-${tone}`;
    const sparkEl = spark ? '<canvas class="tag-spark" aria-hidden="true"></canvas>' : '';
    det.innerHTML = `
      <summary>
        <span class="tag-title">${label}</span>
        <span class="tag-meta">${summary}</span>
        ${sparkEl}
        <span class="tag-chip ${tone}">${status}</span>
      </summary>
      <div class="tag-details">${details.map(line=>`<div>${line}</div>`).join('')}</div>
    `;
    tags.appendChild(det);
    tagSummary.push({label, tone, status, summary});
    if(spark){
      const canvas = det.querySelector('.tag-spark');
      if(canvas){
        drawTagSparkline(canvas, spark.series, spark.mode, spark.good, spark.warn);
        sparkCount++;
      }
    }
  };

  const isMC = !!mc;
  const nFactorNH4 = params.nUnits === 'asIon' ? CHEM.NH4_ion_per_N : 1;
  const nFactorNO2 = params.nUnits === 'asIon' ? CHEM.NO2_ion_per_N : 1;
  const nFactorNO3 = params.nUnits === 'asIon' ? CHEM.NO3_ion_per_N : 1;
  const seriesNH4 = sim.NH4_mgL.map(v=>v * nFactorNH4);
  const seriesNO2 = sim.NO2_mgL.map(v=>v * nFactorNO2);
  const seriesNO3 = sim.NO3_mgL.map(v=>v * nFactorNO3);
  const seriesNH3 = sim.NH3_mgL;
  const seriesCO2 = sim.CO2_mgL;
  const seriesMacro = sim.macro_mgL;
  const seriesMicro = sim.micro_mgL;
  const seriesCopper = seriesMicro.map(v=>v * FEED_PROFILE.modeling.copperFractionOfMicro);

  const doMin = isMC ? mc.scalars.minDO.mid : Math.min(...sim.DO_mgL);
  const nh3Peak = isMC ? mc.scalars.nh3pk.mid : Math.max(...sim.NH3_mgL);
  const nh4Peak = isMC ? (mc.scalars.nh4pk.mid * nFactorNH4) : Math.max(...seriesNH4);
  const no2Peak = isMC ? (mc.scalars.no2pk.mid * nFactorNO2) : Math.max(...seriesNO2);
  const no3Peak = isMC ? (mc.scalars.no3pk.mid * nFactorNO3) : Math.max(...seriesNO3);
  const co2Peak = isMC ? mc.scalars.co2pk.mid : Math.max(...seriesCO2);
  const macroPeak = isMC ? mc.scalars.macroPk.mid : Math.max(...seriesMacro);
  const microPeak = isMC ? mc.scalars.microPk.mid : Math.max(...seriesMicro);
  const copperPeak = microPeak * FEED_PROFILE.modeling.copperFractionOfMicro;

  const doClass = classify('min', doMin, 5, 2);
  addTag({
    label:'Dissolved oxygen (DO)',
    tone: doClass.tone,
    status: doClass.label,
    summary:`min ${fmtVal(doMin, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median minimum' : 'minimum'}: ${fmtVal(doMin, 'mg/L')}.`,
      fmtBandLine('min', 5, 2, 'mg/L'),
      `Context: pH ${params.pH}, temperature ${params.Tnow}°C, volume ${params.volL} L.`
    ],
    spark:{series: sim.DO_mgL, mode:'min', good:5, warn:2}
  });

  const nh3Class = classify('max', nh3Peak, 0.02, 0.05);
  addTag({
    label:'NH₃ (unionized)',
    tone: nh3Class.tone,
    status: nh3Class.label,
    summary:`peak ${fmtVal(nh3Peak, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(nh3Peak, 'mg/L')}.`,
      fmtBandLine('max', 0.02, 0.05, 'mg/L'),
      `Unionized fraction depends on pH ${params.pH} and temperature ${params.Tnow}°C.`
    ],
    spark:{series: seriesNH3, mode:'max', good:0.02, warn:0.05}
  });

  // --------------------------
  // Single-run flags
  // --------------------------
  if(doMinStats.v < 1.0){
    add('danger', 'DO crash', `Min DO is <b>${doMinStats.v.toFixed(2)} mg/L</b> at day ${doMinStats.day.toFixed(2)}. That’s a crash risk.`);
  }else if(doMinStats.v < 2.0){
    add('warn', 'Low DO window', `Min DO is <b>${doMinStats.v.toFixed(2)} mg/L</b> at day ${doMinStats.day.toFixed(2)}. Many animals get stressed below ~2 mg/L.`);
  }else if(doMinStats.v < 4.0){
    add('note', 'Moderate DO dip', `Min DO is ${doMinStats.v.toFixed(2)} mg/L at day ${doMinStats.day.toFixed(2)}. Probably fine for hardier stock, but still worth watching.`);
  }else{
    add('note', 'DO looks comfortable', `Min DO is ${doMinStats.v.toFixed(2)} mg/L at day ${doMinStats.day.toFixed(2)}.`);
  }

  if(peakDef.v > 0.1){
    add('warn', 'Demand exceeds supply', `Peak deficit is <b>${peakDef.v.toFixed(2)} g/day</b> at day ${peakDef.day.toFixed(2)}. Expect DO to trend downward around that window.`);
  }else{
    add('note', 'Supply generally keeps up', `Peak deficit is ${peakDef.v.toFixed(2)} g/day.`);
  }

  const co2Class = classify('max', co2Peak, 15, 30);
  addTag({
    label:'CO₂ (produced)',
    tone: co2Class.tone,
    status: co2Class.label,
    summary:`peak ${fmtVal(co2Peak, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(co2Peak, 'mg/L')}.`,
      fmtBandLine('max', 15, 30, 'mg/L'),
      `CO₂ spikes often track heavy feeding or respiration loads.`
    ],
    spark:{series: seriesCO2, mode:'max', good:15, warn:30}
  });

  const macroClass = classify('max', macroPeak, 1.5, 3.0);
  addTag({
    label:'Macros (proxy)',
    tone: macroClass.tone,
    status: macroClass.label,
    summary:`peak ${fmtVal(macroPeak, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(macroPeak, 'mg/L')}.`,
      fmtBandLine('max', 1.5, 3.0, 'mg/L'),
      `Proxy nutrients help compare relative load across scenarios.`
    ],
    spark:{series: seriesMacro, mode:'max', good:1.5, warn:3.0}
  });

  const no2Class = classify('max', no2Peak, 0.15, 0.30);
  addTag({
    label:'Nitrite (NO₂)',
    tone: no2Class.tone,
    status: no2Class.label,
    summary:`peak ${fmtVal(no2Peak, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(no2Peak, 'mg/L')}.`,
      fmtBandLine('max', 0.15, 0.30, 'mg/L'),
      `Nitrite is an acute toxicity risk; maintain strong biofiltration.`
    ],
    spark:{series: seriesNO2, mode:'max', good:0.15, warn:0.30}
  });

  const no3Class = classify('max', no3Peak, 20, 40);
  addTag({
    label:'Nitrate (NO₃)',
    tone: no3Class.tone,
    status: no3Class.label,
    summary:`peak ${fmtVal(no3Peak, 'mg/L')}`,
    details:[
      `Modeled ${isMC ? 'median peak' : 'peak'}: ${fmtVal(no3Peak, 'mg/L')}.`,
      fmtBandLine('max', 20, 40, 'mg/L'),
      `Nitrate accumulates over time; dilution or denitrification reduces it.`
    ],
    spark:{series: seriesNO3, mode:'max', good:20, warn:40}
  });

  const copperClass = classify('max', copperPeak, 0.02, 0.05);
  addTag({
    label:'Copper (proxy)',
    tone: copperClass.tone,
    status: copperClass.label,
    summary:`peak ${fmtVal(copperPeak, 'mg/L')}`,
    details:[
      `Proxy from micronutrients: ${fmtVal(copperPeak, 'mg/L')}.`,
      fmtBandLine('max', 0.02, 0.05, 'mg/L'),
      `Copper is invertebrate-sensitive; consider targeted test kits for confirmation.`
    ],
    spark:{series: seriesCopper, mode:'max', good:0.02, warn:0.05}
  });

  if(isMC){
    DEBUG_STATE.lastFlagsCount = flagCount;
    DEBUG_STATE.lastFlagsMode = 'uncertainty';
    DEBUG_STATE.lastTagSummary = {mode:'uncertainty', tags: tagSummary};
    DEBUG_STATE.lastTagSparkCount = sparkCount;
    return;
  }

  if(nh3PeakValue > 0.10){
    add('danger', 'NH₃ toxicity risk', `Unionized NH₃ peaks near ${nh3PeakValue.toFixed(3)} mg/L. Consider lower pH, reduced load, or more nitrification capacity.`);
  }else if(nh3PeakValue > 0.05){
    add('warn', 'NH₃ watch zone', `Unionized NH₃ peaks near ${nh3PeakValue.toFixed(3)} mg/L. Keep an eye on sensitive stock.`);
  }else{
    add('note', 'NH₃ stays low', `Unionized NH₃ peaks near ${nh3PeakValue.toFixed(3)} mg/L.`);
  }

  add('note', 'Nitrogen peaks (single run)', `NH₄: ${nh4PeakValue.toFixed(3)} mg/L • NO₂: ${no2PeakValue.toFixed(3)} mg/L • NO₃: ${no3PeakValue.toFixed(3)} mg/L.`);
  if(denitN_mgL > 0.2){
    add('note', 'Denitrification activity', `Estimated NO₃ → N₂ conversion: ${denitN_mgL.toFixed(2)} mg/L as N. Low-DO windows are driving denitrification.`);
  }
  DEBUG_STATE.lastFlagsCount = flagCount;
  DEBUG_STATE.lastFlagsMode = 'single';
  DEBUG_STATE.lastTagSummary = {mode:'single', tags: tagSummary};
  DEBUG_STATE.lastTagSparkCount = sparkCount;
}

/* =========================================================
   Main recompute + render
========================================================= */
function getParams(){
  // Keep “preset selectors” synced to their numeric fields before reading
  try{ applyAllPresets(); }catch(_){}

  // Hardcoded pellet geometry (project standard)
  try{
    if(el('pelLen')) el('pelLen').value = '1.00';
    if(el('pelDia')) el('pelDia').value = '0.20';
  }catch(_){}

  const p = {
    pelletMass_g: Number(el('pelMassN').value),
    powderMass_g: Number(el('powMassN').value),
    blanketPct: Number(el('blanketN').value),
    days: Number(el('daysN').value),

    volL: Number(el('volL').value),
    airFlow: Number(el('airFlow').value),
    Tnow: Number(el('Tnow').value),
    pH: Number(el('pH').value),
    altM: Number(el('altM').value),
    tds: Number(el('tds').value),

    ripplePct: Number(el('ripplePct').value),

    lenCm: Number(el('lenCm').value),
    widCm: Number(el('widCm').value),
    tankHCm: Number(el('tankHCm').value),
    waterSurfCm: Number(el('waterSurfCm').value),
    blanketGapCm: Number(el('blanketGapCm').value),
    diffDepthCm: Number(el('diffDepthCm').value),
    heaters: Number(el('heaters').value),

    diffType: el('diffType').value,
    sotePerM: Number(el('sotePerM').value),
    surfacePreset: el('surfacePreset') ? el('surfacePreset').value : 'typical',
    kCalm: Number(el('kCalm').value),
    kRipple: Number(el('kRipple').value),

    tightPreset: el('tightPreset') ? el('tightPreset').value : 'loose_high',
    tight: Number(el('tight').value),

    otrPreset: el('otrPreset') ? el('otrPreset').value : 'typical',
    otrCal: Number(el('otrCal').value),

    initDOPreset: el('initDOPreset') ? el('initDOPreset').value : '95',
    doInitPct: Number(el('doInitPct').value),

    o2Limit: el('o2Limit').value,
    kDoNit: Number(el('kDoNit').value),
    kDoHet: Number(el('kDoHet').value),
    slowFrac: Number(el('slowFrac').value),
    biofilmMm: Number(el('biofilmMm').value),
    kDenit: Number(el('kDenit').value),
    denitCap: Number(el('denitCap').value),
    fishMass: Number(el('fishMass').value),
    photoMass: Number(el('photoMass').value),
    tempAmp: Number(el('tempAmp').value),
    lightHour: Number(el('lightHour').value),
    kNH4Nit: Number(el('kNH4Nit').value),
    kNO2Nit: Number(el('kNO2Nit').value),
    nitCap: Number(el('nitCap').value),
    nitQ10: Number(el('nitQ10').value),
    nUnits: el('nUnits').value,
    chemNerd: !!el('chemNerd').checked,

    pelLen: Number(el('pelLen').value),
    pelDia: Number(el('pelDia').value),
    pelRho: Number(el('pelRho').value),

    // Uncertainty mode controls
    runMode: el('runMode') ? el('runMode').value : 'uncertainty',
    uncLevel: el('uncLevel') ? el('uncLevel').value : 'typical',
    mcRuns: el('mcRuns') ? Number(el('mcRuns').value) : 200,
    bandPreset: el('bandPreset') ? el('bandPreset').value : '10-90',
    seed: el('seed') ? Number(el('seed').value) : 12345,
    liveRecompute: el('liveRecompute') ? el('liveRecompute').value : 'on',
    u: {
      air: el('uAir') ? el('uAir').checked : true,
      diff: el('uDiff') ? el('uDiff').checked : true,
      surf: el('uSurf') ? el('uSurf').checked : true,
      tight: el('uTight') ? el('uTight').checked : true,
      bio: el('uBio') ? el('uBio').checked : true,
      temp: el('uTemp') ? el('uTemp').checked : true,
      initDO: el('uInitDO') ? el('uInitDO').checked : true,
    },

    events: EVENTS
  };

  // light sanitization
  p.mcRuns = clamp(Math.round(p.mcRuns || 0), 10, 5000);
  p.pH = clamp(Number.isFinite(p.pH) ? p.pH : 7.0, 5.0, 9.5);
  p.nitCap = clamp(Number.isFinite(p.nitCap) ? p.nitCap : 1.0, 0, 1);
  p.denitCap = clamp(Number.isFinite(p.denitCap) ? p.denitCap : 1.0, 0, 1);
  p.lightHour = clamp(Number.isFinite(p.lightHour) ? p.lightHour : 8, 0, 23);
  p.photoMass = clamp(Number.isFinite(p.photoMass) ? p.photoMass : 0, 0, 100000);
  return p;
}

function fmtBand(stats, unit, decimals=2){
  const lo = stats.lo, mid = stats.mid, hi = stats.hi;
  if(!Number.isFinite(lo) || !Number.isFinite(mid) || !Number.isFinite(hi)) return '—';
  return `${mid.toFixed(decimals)} ${unit}  [${lo.toFixed(decimals)}–${hi.toFixed(decimals)}]`;
}

function convertStats(stats, factor){
  if(!stats) return stats;
  return {lo: stats.lo*factor, mid: stats.mid*factor, hi: stats.hi*factor};
}

function fmtPct(p){
  if(!Number.isFinite(p)) return '—';
  return `${(100*p).toFixed(1)}%`;
}

function getChemDisplayMode(){
  const mode = el('chemDisplay') ? el('chemDisplay').value : 'bio';
  if(['bio','prod','cum'].includes(mode)) return mode;
  return 'bio';
}

function resolveChemSeries(sim, mode){
  if(mode === 'prod') return {series: sim.chemProd, titleSuffix:'(production only)'};
  if(mode === 'cum') return {series: sim.chemProdCum, titleSuffix:'(cumulative production)'};
  return {series: sim.chem, titleSuffix:'(net)'}; // bio
}

function recompute(){
  clearError();
  setStage('recompute', 'start');
  DEBUG_STATE.warnings = [];
  const recomputeStart = performance.now();

  try{
    setStage('UI', 'apply presets');
    applyAllPresets();

    setStage('UI', 'read params');
    const params = getParams();
    DEBUG_STATE.lastParams = params;
    DEBUG_STATE.lastMode = params.runMode;
    DEBUG_STATE.lastUpdateISO = new Date().toISOString();
    const chemMode = getChemDisplayMode();

    updateChemSeriesLabels(params.nUnits);
    buildLegendChem();
    buildLegendBio();

    assertFinite('days', params.days);
    assertFinite('volL', params.volL);

    saveState();

    // Pellet derived quantities
    setStage('Pellets', 'derive pellet count');
    const mEach = pelletMassEach(params.pelLen, params.pelDia, params.pelRho);
    const nPel = (mEach > 0) ? (params.pelletMass_g / mEach) : 0;
    setText('pelCount', `${nPel.toFixed(1)} pellets`);
    setText('pelEach', `${mEach.toFixed(4)} g`);

    // Base sim (used for breakdown lines + UI even in uncertainty mode)
    setStage('Simulation', 'run base sim');
    const baseSim = runSimulation(params);
    lastSim = baseSim;
    lastMC = null;

    const oxy = baseSim.meta.oxy;
    DEBUG_STATE.lastOxy = oxy;
    DEBUG_STATE.lastSimMeta = baseSim.meta;
    DEBUG_STATE.lastChemCumInfo = baseSim.meta.chemCumInfo || null;
    DEBUG_STATE.lastPhotoModel = baseSim.meta.photoModel || null;
    DEBUG_STATE.lastFeedProfileId = baseSim.meta.feedProfileId || FEED_PROFILE.id;
    DEBUG_STATE.lastOxygenClampCount = baseSim.meta.oxygenClampCount ?? null;
    DEBUG_STATE.lastPlantLimitedSteps = baseSim.meta.plantLimitedSteps ?? null;
    DEBUG_STATE.lastBiomassSummary = {
      heteroStart: baseSim.biomass?.hetero_g?.[0] ?? null,
      heteroEnd: baseSim.biomass?.hetero_g?.[baseSim.biomass?.hetero_g?.length - 1] ?? null,
      phytoStart: baseSim.biomass?.phyto_g?.[0] ?? null,
      phytoEnd: baseSim.biomass?.phyto_g?.[baseSim.biomass?.phyto_g?.length - 1] ?? null
    };
    if(baseSim.meta.chemCumInfo?.invalidCount){
      addWarning(`Chemistry cumulative series had ${baseSim.meta.chemCumInfo.invalidCount} non-finite samples; treated as 0 in the cumulative plot.`);
    }

    // If uncertainty mode: run MC overlay
    if(params.runMode === 'uncertainty'){
      setStage('Uncertainty', 'Monte Carlo');
      const mc = runMonteCarlo(params);
      lastMC = mc;
      DEBUG_STATE.lastScalars = mc.scalars;

      // Oxygenation meta (bands)
      setText('cStarOut', fmtBand(mc.scalars.Cstar, 'mg/L', 2));
      setText('otrOut', fmtBand(mc.scalars.otrMax, 'g/day', 2));
      setText('klaOut', fmtBand(mc.scalars.kLa, '1/day', 3));

      // DO min + risk
      setText('doMinOut', `${fmtBand(mc.scalars.minDO, 'mg/L', 2)}  @ day ${fmtBand(mc.scalars.minDO_day, '', 2).replace('  [','[')}`);
      setText('pUnder2Out', fmtPct(mc.probs.anyUnder2));
      setText('pUnder1Out', fmtPct(mc.probs.anyUnder1));

      const nh4Stats = params.nUnits === 'asIon' ? convertStats(mc.scalars.nh4pk, CHEM.NH4_ion_per_N) : mc.scalars.nh4pk;
      const no2Stats = params.nUnits === 'asIon' ? convertStats(mc.scalars.no2pk, CHEM.NO2_ion_per_N) : mc.scalars.no2pk;
      const no3Stats = params.nUnits === 'asIon' ? convertStats(mc.scalars.no3pk, CHEM.NO3_ion_per_N) : mc.scalars.no3pk;

      setText('nh4Out', fmtBand(nh4Stats, 'mg/L', 3));
      setText('no2Out', fmtBand(no2Stats, 'mg/L', 3));
      setText('no3Out', fmtBand(no3Stats, 'mg/L', 3));
      setText('nh3Out', fmtBand(mc.scalars.nh3pk, 'mg/L', 3));
      setText('co2Out', fmtBand(mc.scalars.co2pk, 'mg/L', 2));
      const macroStats = mc.scalars.macroPk;
      const microStats = mc.scalars.microPk;
      setText('nutrOut', `${fmtBand(macroStats, 'mg/L', 2)} • ${fmtBand(microStats, 'mg/L', 2)}`);

      // Plots with bands
      setStage('Plots', 'rate');
      const rateBands = Object.fromEntries(RATE_SERIES.map(s=>[
        s.key,
        {lo:mc.q.rateBands[s.key].lo, hi:mc.q.rateBands[s.key].hi, mid:mc.q.rateBands[s.key].mid, alpha:(s.key === 'total' ? 0.18 : (s.key === 'supply' ? 0.14 : 0.08))}
      ]));
      DEBUG_STATE.lastRateBandKeys = Object.keys(rateBands);
      const missingRateBands = RATE_SERIES.filter(s=>!rateBands[s.key] || !rateBands[s.key].hi).map(s=>s.key);
      if(missingRateBands.length){
        addWarning(`Missing rate uncertainty bands for: ${missingRateBands.join(', ')}`);
      }
      rateGeom = drawPlot(el('rateCanvas'), baseSim.t, baseSim.rate, {
        title:"Oxygen RATE (g O₂/day)",
        bands: rateBands,
        bandColors: Object.fromEntries(RATE_SERIES.map(s=>[s.key, s.color])),
        fitYMax: true,
        bandPattern: true
      });

      setStage('Plots', 'dissolved oxygen');
      doGeom = drawDOPlot(el('doCanvas'), baseSim, {
        DO:{lo:mc.q.DO.lo, hi:mc.q.DO.hi, mid:mc.q.DO.mid, alpha:0.18},
        Cstar: mc.scalars.Cstar
      });

      setStage('Plots', 'chemistry');
      const chemBands = chemMode === 'prod' ? mc.q.chemProdBands : (chemMode === 'cum' ? mc.q.chemCumBands : mc.q.chemBands);
      DEBUG_STATE.lastChemBandKeys = Object.keys(chemBands);
      const missingChemBands = CHEM_SERIES.filter(s=>!chemBands[s.key] || !chemBands[s.key].hi).map(s=>s.key);
      if(missingChemBands.length){
        addWarning(`Missing chemistry uncertainty bands for: ${missingChemBands.join(', ')}`);
      }
      const chemSeries = resolveChemSeries(baseSim, chemMode);
      chemGeom = drawPlot(el('chemCanvas'), baseSim.t, chemSeries.series, {
        title:`Chemistry / Compounds (mg/L) ${chemSeries.titleSuffix}`,
        series: CHEM_SERIES,
        visible: visibleChem,
        bands: Object.fromEntries(CHEM_SERIES.map(s=>[
          s.key,
          {lo:chemBands[s.key].lo, hi:chemBands[s.key].hi, mid:chemBands[s.key].mid, alpha:0.12}
        ])),
        bandColors: Object.fromEntries(CHEM_SERIES.map(s=>[s.key, s.color])),
        bandPattern: true
      });

      setStage('Plots', 'biomass');
      bioGeom = drawBiomassPlot(el('bioCanvas'), baseSim, {
        bioBands: mc.q.bioBands,
        bioPctBands: mc.q.bioPctBands
      });
      if(!mc.q.bioBands || !mc.q.bioPctBands){
        addWarning('Missing biomass uncertainty bands; check Monte Carlo aggregation.');
      }

      setStage('Flags', 'evaluate');
      setFlags(baseSim, params, mc);

      // Debug (human-readable summary + machine snapshot)
      const dbg = [];
      dbg.push(`Mode: Uncertainty (Monte Carlo)`);
      dbg.push(`Runs: ${mc.scalars.runs}, band: ${params.bandPreset}, level: ${params.uncLevel}`);
      dbg.push(`What varies: air=${params.u.air}, diffuser=${params.u.diff}, surface=${params.u.surf}, cover=${params.u.tight}, bio=${params.u.bio}, temp=${params.u.temp}, initDO=${params.u.initDO}`);
      dbg.push(`Pressure @ altitude: ${pressureFromAltitude_kPa(params.altM).toFixed(2)} kPa`);
      dbg.push(`Base O2 in pumped air (rated flow): ${oxy.O2_in_air_g_day.toFixed(2)} g/day`);
      dbg.push(`Base bubble eff fraction: ${(100*oxy.eff_bubble).toFixed(2)}%  (depth ${params.diffDepthCm.toFixed(1)} cm, SOTE/m ${params.sotePerM.toFixed(2)}%)`);
      dbg.push(`Surface areas: total ${oxy.areas.A_total.toFixed(4)} m²; open ${oxy.areas.A_open.toFixed(4)}; covered ${oxy.areas.A_cov.toFixed(4)}`);
      dbg.push(`Cover leak factor (base): ${oxy.leak.toFixed(3)} (tight=${params.tight.toFixed(2)}, headspace ${oxy.head.V_head_L.toFixed(1)} L)`);
      dbg.push(`Base OTR surface max: ${oxy.OTR_surface_max.toFixed(3)} g/day  (kCalm ${params.kCalm}, kRipple ${params.kRipple}, ripple ${params.ripplePct}%)`);
      dbg.push(`Base OTR bubble max: ${oxy.OTR_bubble_max.toFixed(3)} g/day`);
      dbg.push(`Base OTR max: ${oxy.OTR_max.toFixed(3)} g/day`);
      dbg.push(`Base kLa inferred: ${oxy.kLa.toFixed(4)} 1/day`);
      dbg.push(`Sim dt: ${baseSim.meta.dt.toFixed(4)} days (~${(baseSim.meta.dt*24).toFixed(2)} h)`);
      dbg.push(`Feed mass: start ${baseSim.meta.feedStart.toFixed(3)} g → end ${baseSim.meta.feedEnd.toFixed(3)} g`);
      dbg.push(`Rate peaks: demand ${baseSim.meta.maxDemand.toFixed(3)} g/day • supply ${baseSim.meta.maxSupply.toFixed(3)} g/day`);
      dbg.push('Metabolism mode: inferred fish + photosynthesis (legacy denit/slow COD disabled)');
      dbg.push(`Biofilm proxy: ${params.biofilmMm} mm • slowFrac ${params.slowFrac}`);
      dbg.push(`Denit: k=${params.kDenit} 1/day • cap=${params.denitCap}`);
      dbg.push(`Fish mass: ${params.fishMass} g (base ${FISH_MODEL.o2_mg_g_day_base} mg/g/day @ ${FISH_MODEL.refTempC}°C)`);
      dbg.push(`Photosynthetic mass: ${params.photoMass} g (peak ${PHOTO_MODEL.o2_mg_g_day_peak} mg/g/day)`);
      dbg.push(`Diurnal: tempAmp ${params.tempAmp}°C • lights @ ${params.lightHour}:00`);
      dbg.push(`Feed profile: ${FEED_PROFILE.name}`);
      dbg.push(`Chem display: ${chemMode}`);
      dbg.push(`N units: ${params.nUnits} • pH=${params.pH} • NH3 frac=${nh3Fraction(params.pH ?? 7.0, params.Tnow).toFixed(3)}`);
      dbg.push('');
      dbg.push('--- Snapshot ---');
      dbg.push(...buildDebugSnapshot([]));
      setDebugText(dbg);

    }else{
      setStage('Mode', 'deterministic single run');

      // Deterministic (single)
      setText('cStarOut', `${oxy.Cstar.toFixed(2)} mg/L`);
      setText('otrOut', `${oxy.OTR_max.toFixed(2)} g/day`);
      setText('klaOut', `${oxy.kLa.toFixed(3)} 1/day`);

      // Min DO display
      let doMinValue = Infinity;
      let doMinDay = 0;
      for(let i=0;i<baseSim.DO_mgL.length;i++){
        if(baseSim.DO_mgL[i] < doMinValue){ doMinValue = baseSim.DO_mgL[i]; doMinDay = baseSim.t[i]; }
      }
      el('doMinOut').textContent = `${doMinValue.toFixed(2)} mg/L @ day ${doMinDay.toFixed(2)}`;
      el('pUnder2Out').textContent = '—';
      el('pUnder1Out').textContent = '—';

      const nFactorNH4 = params.nUnits === 'asIon' ? CHEM.NH4_ion_per_N : 1;
      const nFactorNO2 = params.nUnits === 'asIon' ? CHEM.NO2_ion_per_N : 1;
      const nFactorNO3 = params.nUnits === 'asIon' ? CHEM.NO3_ion_per_N : 1;
      const nh4Peak = Math.max(...baseSim.NH4_mgL) * nFactorNH4;
      const no2Peak = Math.max(...baseSim.NO2_mgL) * nFactorNO2;
      const no3Peak = Math.max(...baseSim.NO3_mgL) * nFactorNO3;
      const nh3Peak = Math.max(...baseSim.NH3_mgL);
      const co2Peak = Math.max(...baseSim.CO2_mgL);
      const macroPeak = Math.max(...baseSim.macro_mgL);
      const microPeak = Math.max(...baseSim.micro_mgL);
      setText('nh4Out', `${nh4Peak.toFixed(3)} mg/L`);
      setText('no2Out', `${no2Peak.toFixed(3)} mg/L`);
      setText('no3Out', `${no3Peak.toFixed(3)} mg/L`);
      setText('nh3Out', `${nh3Peak.toFixed(3)} mg/L`);
      setText('co2Out', `${co2Peak.toFixed(2)} mg/L`);
      setText('nutrOut', `${macroPeak.toFixed(2)} mg/L • ${microPeak.toFixed(2)} mg/L`);

      // Draw plots
      setStage('Plots', 'rate');
      rateGeom = drawPlot(el('rateCanvas'), baseSim.t, baseSim.rate, {
        title:"Oxygen RATE (g O₂/day)",
        fitYMax: true,
        bandPattern: false
      });
      setStage('Plots', 'dissolved oxygen');
      doGeom   = drawDOPlot(el('doCanvas'), baseSim);
      setStage('Plots', 'chemistry');
      const chemSeries = resolveChemSeries(baseSim, chemMode);
      chemGeom  = drawPlot(el('chemCanvas'),  baseSim.t, chemSeries.series,  {
        title:`Chemistry / Compounds (mg/L) ${chemSeries.titleSuffix}`,
        series: CHEM_SERIES,
        visible: visibleChem
      });

      setStage('Plots', 'biomass');
      bioGeom = drawBiomassPlot(el('bioCanvas'), baseSim);

      // Flags
      setStage('Flags', 'evaluate');
      setFlags(baseSim, params, null);

      // Debug text
      const dbg = [];
      dbg.push(`Mode: Single run (deterministic)`);
      dbg.push(`Pressure @ altitude: ${pressureFromAltitude_kPa(params.altM).toFixed(2)} kPa`);
      dbg.push(`O2 in pumped air: ${oxy.O2_in_air_g_day.toFixed(2)} g O2/day`);
      dbg.push(`Bubble eff fraction: ${(100*oxy.eff_bubble).toFixed(2)}%  (depth ${params.diffDepthCm.toFixed(1)} cm, SOTE/m ${params.sotePerM.toFixed(2)}%)`);
      dbg.push(`Surface areas: total ${oxy.areas.A_total.toFixed(4)} m²; open ${oxy.areas.A_open.toFixed(4)}; covered ${oxy.areas.A_cov.toFixed(4)}`);
      dbg.push(`Cover leak factor: ${oxy.leak.toFixed(3)}  (tight ${params.tight.toFixed(2)}, headspace ${oxy.head.V_head_L.toFixed(1)} L)`);
      dbg.push(`OTR surface max: ${oxy.OTR_surface_max.toFixed(3)} g/day  (kCalm ${params.kCalm}, kRipple ${params.kRipple}, ripple ${params.ripplePct}%)`);
      dbg.push(`OTR bubble max: ${oxy.OTR_bubble_max.toFixed(3)} g/day`);
      dbg.push(`OTR max: ${oxy.OTR_max.toFixed(3)} g/day`);
      dbg.push(`kLa inferred: ${oxy.kLa.toFixed(4)} 1/day`);
      dbg.push(`Sim dt: ${baseSim.meta.dt.toFixed(4)} days (~${(baseSim.meta.dt*24).toFixed(2)} h)`);
      dbg.push(`Feed mass: start ${baseSim.meta.feedStart.toFixed(3)} g → end ${baseSim.meta.feedEnd.toFixed(3)} g`);
      dbg.push(`Rate peaks: demand ${baseSim.meta.maxDemand.toFixed(3)} g/day • supply ${baseSim.meta.maxSupply.toFixed(3)} g/day`);
      dbg.push('Metabolism mode: inferred fish + photosynthesis (legacy denit/slow COD disabled)');
      dbg.push(`Biofilm proxy: ${params.biofilmMm} mm • slowFrac ${params.slowFrac}`);
      dbg.push(`Denit: k=${params.kDenit} 1/day • cap=${params.denitCap}`);
      dbg.push(`Fish mass: ${params.fishMass} g (base ${FISH_MODEL.o2_mg_g_day_base} mg/g/day @ ${FISH_MODEL.refTempC}°C)`);
      dbg.push(`Photosynthetic mass: ${params.photoMass} g (peak ${PHOTO_MODEL.o2_mg_g_day_peak} mg/g/day)`);
      dbg.push(`Diurnal: tempAmp ${params.tempAmp}°C • lights @ ${params.lightHour}:00`);
      dbg.push(`Feed profile: ${FEED_PROFILE.name}`);
      dbg.push(`Chem display: ${chemMode}`);
      dbg.push(`N units: ${params.nUnits} • pH=${params.pH} • NH3 frac=${nh3Fraction(params.pH ?? 7.0, params.Tnow).toFixed(3)}`);
      dbg.push('');
      dbg.push('--- Snapshot ---');
      dbg.push(...buildDebugSnapshot([]));
      setDebugText(dbg);
    }

    const auditEl = el('chemAudit');
    const auditDetails = el('chemAuditDetails');
    if(auditEl && auditDetails){
      const showAudit = !!params.chemNerd;
      auditDetails.style.display = showAudit ? 'block' : 'none';
      auditDetails.open = showAudit;
      if(showAudit){
        const a = baseSim.audit;
        const lines = [
          `NH₄ from protein oxidation: ${(a.nh4_from_pro*1000/params.volL).toFixed(3)} mg/L as N`,
          `NH₄ from biomass turnover: ${(a.nh4_from_endog*1000/params.volL).toFixed(3)} mg/L as N`,
          `NH₄ → NO₂ consumed: ${(a.nh4_to_no2*1000/params.volL).toFixed(3)} mg/L as N`,
          `NO₂ → NO₃ consumed: ${(a.no2_to_no3*1000/params.volL).toFixed(3)} mg/L as N`,
          `NO₃ → N₂ (denit): ${(a.no3_to_n2*1000/params.volL).toFixed(3)} mg/L as N`,
          `CO₂ from oxidation: ${(a.co2_from_ox*1000/params.volL).toFixed(2)} mg/L`,
          `CO₂ from endogenous: ${(a.co2_from_endog*1000/params.volL).toFixed(2)} mg/L`,
          `CO₂ from denit: ${(a.co2_from_denit*1000/params.volL).toFixed(2)} mg/L`,
          `Macros released: ${(a.macro_release*1000/params.volL).toFixed(2)} mg/L`,
          `Macros uptake: ${(a.macro_uptake*1000/params.volL).toFixed(2)} mg/L`,
          `Micros released: ${(a.micro_release*1000/params.volL).toFixed(2)} mg/L`,
          `Micros uptake: ${(a.micro_uptake*1000/params.volL).toFixed(2)} mg/L`,
          `N balance: ${(a.n_balance_end*1000/params.volL).toFixed(3)} mg/L as N (initial ${(a.n_balance_init*1000/params.volL).toFixed(3)})`,
          `C balance: ${(a.c_balance_end*1000/params.volL).toFixed(2)} mg/L (initial ${(a.c_balance_init*1000/params.volL).toFixed(2)})`
        ];
        auditEl.textContent = lines.join('\n');
      }
    }

    setStage('Interactions', 'init canvases');
    initCanvasInteractions();

    setStage('recompute', 'done');
    DEBUG_STATE.lastRecomputeMs = performance.now() - recomputeStart;
    if(DEBUG_STATE.lastRecomputeMs > 800){
      addWarning(`Recompute took ${DEBUG_STATE.lastRecomputeMs.toFixed(0)} ms. Consider reducing Monte Carlo runs or disabling live recompute.`);
    }

  }catch(err){
    showError(err);
  }
}

function applyDiffuserPreset(){
  const t = el('diffType').value;
  const s = el('sotePerM');
  let v = null;

  // “Reasonable starting points”. Real SOTE depends a lot on bubble size, contact time, and circulation.
  if(t === 'airstone_med')      v = 2.5;
  else if(t === 'airstone_fine')v = 3.5;
  else if(t === 'microbubble') v = 5.5;
  else if(t === 'wood')        v = 4.5;

  if(v !== null){
    s.value = v;
    s.disabled = true;
    s.title = 'Preset value. Choose Custom to edit.';
  }else{
    s.disabled = false;
    s.title = '';
  }
}

function applySurfacePreset(){
  const t = el('surfacePreset').value;
  const kc = el('kCalm');
  const kr = el('kRipple');
  let v = null;

  if(t === 'still')        v = {kCalm:0.15, kRipple:0.45};
  else if(t === 'typical') v = {kCalm:0.30, kRipple:1.00};
  else if(t === 'rippling')v = {kCalm:0.45, kRipple:1.60};
  else if(t === 'splashy') v = {kCalm:0.70, kRipple:2.50};

  if(v){
    kc.value = v.kCalm;
    kr.value = v.kRipple;
    kc.disabled = true; kr.disabled = true;
    kc.title = 'Preset value. Choose Custom to edit.';
    kr.title = 'Preset value. Choose Custom to edit.';
  }else{
    kc.disabled = false; kr.disabled = false;
    kc.title = ''; kr.title = '';
  }
}

function applyTightPreset(){
  const t = el('tightPreset').value;
  const ti = el('tight');
  let v = null;

  if(t === 'open')        v = 0.00;
  else if(t === 'loose_high') v = 0.15;
  else if(t === 'typical')    v = 0.35;
  else if(t === 'near_sealed')v = 0.80;

  if(v !== null){
    ti.value = v;
    ti.disabled = true;
    ti.title = 'Preset value. Choose Custom to edit.';
  }else{
    ti.disabled = false;
    ti.title = '';
  }
}

function applyOtrPreset(){
  const t = el('otrPreset').value;
  const o = el('otrCal');
  let v = null;
  if(t === 'typical') v = 1.00;
  else if(t === 'under') v = 0.75;
  else if(t === 'over') v = 1.25;

  if(v !== null){
    o.value = v;
    o.disabled = true;
    o.title = 'Preset value. Choose Custom to edit.';
  }else{
    o.disabled = false;
    o.title = '';
  }
}

function applyInitDOPreset(){
  const t = el('initDOPreset').value;
  const d = el('doInitPct');
  if(t !== 'custom'){
    d.value = Number(t);
    d.disabled = true;
    d.title = 'Preset value. Choose Custom to edit.';
  }else{
    d.disabled = false;
    d.title = '';
  }
}

function applyAllPresets(){
  // These keep the “human presets” and the numeric fields in sync.
  if(el('diffType')) applyDiffuserPreset();
  if(el('surfacePreset')) applySurfacePreset();
  if(el('tightPreset')) applyTightPreset();
  if(el('otrPreset')) applyOtrPreset();
  if(el('initDOPreset')) applyInitDOPreset();
}


/* =========================================================
   Init
========================================================= */
let recomputeTimer = null;
function scheduleRecompute(){
  const mode = el('liveRecompute') ? el('liveRecompute').value : 'on';
  if(mode === 'off'){
    if(el('recomputeBtn')) el('recomputeBtn').style.display = 'inline-block';
    return;
  }
  if(el('recomputeBtn')) el('recomputeBtn').style.display = 'none';
  clearTimeout(recomputeTimer);
  recomputeTimer = setTimeout(()=>recompute(), 150);
}

function updateModeUI(){
  if(!el('runMode')) return;
  const mode = el('runMode').value;
  if(el('uncSection')) el('uncSection').style.display = (mode === 'uncertainty') ? 'block' : 'none';
  if(el('singleNote')) el('singleNote').style.display = (mode === 'single') ? 'block' : 'none';
}

function init(){
  installGlobalErrorHandlers();
  ensureFeedProfileMemory();
  loadState();
  try{ applyAllPresets(); }catch(_){}

  updateModeUI();
  setDebugText(buildDebugSnapshot(['Init: handlers ready, awaiting recompute.']));

  // Link sliders
  linkRangeAndNumber(el('pelMass'), el('pelMassN'), ()=>{ scheduleRecompute(); });
  linkRangeAndNumber(el('powMass'), el('powMassN'), ()=>{ scheduleRecompute(); });
  linkRangeAndNumber(el('blanket'), el('blanketN'), ()=>{ scheduleRecompute(); });
  linkRangeAndNumber(el('days'), el('daysN'), ()=>{ scheduleRecompute(); });

  if(el('mcRunsRange') && el('mcRuns')){
    linkRangeAndNumber(el('mcRunsRange'), el('mcRuns'), ()=>{ scheduleRecompute(); });
  }

  // Inputs that trigger recompute
  [
    'volL','airFlow','Tnow','pH','altM','tds','ripplePct',
    'lenCm','widCm','tankHCm','waterSurfCm','blanketGapCm','diffDepthCm','heaters',
    'sotePerM','kCalm','kRipple','tight','otrCal',
    'doInitPct','kDoNit','kNH4Nit','kNO2Nit','nitCap','nitQ10','nUnits',
    'kDoHet','slowFrac','biofilmMm','kDenit','denitCap','fishMass','photoMass','tempAmp','lightHour',
    'chemNerd','chemDisplay',
    'pelLen','pelDia','pelRho',
    'diffType','surfacePreset','tightPreset','otrPreset','initDOPreset',
    'runMode','uncLevel','bandPreset','seed','liveRecompute',
    'uAir','uDiff','uSurf','uTight','uBio','uTemp','uInitDO',
    'o2Limit'
  ].forEach(id=>{
    const e = el(id);
    if(!e) return;
    const ev = (e.type === 'checkbox' || e.tagName === 'SELECT') ? 'change' : 'input';
    e.addEventListener(ev, ()=>{
      if(id === 'runMode') updateModeUI();
      // presets need to refresh numeric fields before sim
      if(['diffType','surfacePreset','tightPreset','otrPreset','initDOPreset'].includes(id)){
        try{ applyAllPresets(); }catch(_){}
      }
      scheduleRecompute();
    });
  });

  // Events UI
  const addBtn = el('addEventBtn');
  if(!addBtn){
    addWarning('Missing add-event button (#addEventBtn).');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'addEventBtn', context:'init'});
  }else{
    addBtn.addEventListener('click', ()=>{
    const day = Number(el('evDay').value);
    const pellets = Number(el('evPellets').value);
    const daysMax = Number(el('daysN').value);
    if(!Number.isFinite(day) || !Number.isFinite(pellets)) return;
    const safeDay = clamp(day, 0, Number.isFinite(daysMax) ? daysMax : day);
    const safePel = Math.max(0, Math.round(pellets));
    if(safePel <= 0) return;
    EVENTS.push({day: safeDay, pellets: safePel});
    normalizeEvents();
    saveState();
    renderEvents();
    scheduleRecompute();
    });
  }

  const clearBtn = el('clearEventsBtn');
  if(!clearBtn){
    addWarning('Missing clear-events button (#clearEventsBtn).');
    DEBUG_STATE.missingContainers.push({timeISO: new Date().toISOString(), id:'clearEventsBtn', context:'init'});
  }else{
    clearBtn.addEventListener('click', ()=>{
    EVENTS = [];
    saveState();
    renderEvents();
    scheduleRecompute();
    });
  }

  const recomputeBtn = el('recomputeBtn');
  if(recomputeBtn){
    recomputeBtn.addEventListener('click', ()=>{
      recompute();
      if(el('liveRecompute') && el('liveRecompute').value !== 'off'){
        recomputeBtn.style.display = 'none';
      }
    });
  }

  buildLegendRate();
  buildLegendChem();
  buildLegendBio();
  renderEvents();
  recompute();
}

function boot(){
  DEBUG_STATE.initReadyState = document.readyState;
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init, {once:true});
  }else{
    init();
  }
}

boot();

</script>
</body>
</html>
